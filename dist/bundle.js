/*! For license information please see bundle.js.LICENSE.txt */
(() => {
    var t = {
            800: (t, e, n) => {
                'use strict';
                n.d(e, { Z: () => s });
                var i = n(81),
                    r = n.n(i),
                    a = n(645),
                    o = n.n(a)()(r());
                o.push([
                    t.id,
                    ':root{--zoomFactor: 1.0;--colorInputOutput: rgb(255, 238, 203);--colorMlModule:rgb(86, 125, 150);--colorSoModule: #60a48f;--colorMacroModule: rgb(163, 146, 117)}html{height:100%}body{margin:0;box-sizing:border-box;display:flex;width:100%;height:100%;font-family:sans-serif}h1{color:blue}p{margin:0}canvas{width:50% !important;height:100% !important;z-index:3;position:absolute;left:50%;transition:left 1s ease-in-out, width 1s ease-in-out;pointer-events:none}button{line-height:0;background-color:#5990b6;color:white;text-align:center;margin:auto;border:none;cursor:pointer;border-radius:50%;font-size:30px;width:35px;height:35px}button p{margin:auto}button#dropdbutton{z-index:2;position:relative}button#toggleCanvas{z-index:4;left:calc(50% - 45px);top:10px;position:absolute;transition:left 1s ease-in-out, transform 1s ease-in-out, opacity 0.5s ease-in-out}button.remove,button.cancel{background:none;border:1px solid #fff;line-height:0px;font-size:10px;position:absolute;border-radius:15px;width:20px;height:20px;right:3px;top:3px}button.cancel{background-color:#5990b6;border:none}button.update{border-radius:15px;width:fit-content;margin:0;height:20px;font-size:14px}svg{z-index:0;position:absolute;width:100%;height:100%}#workspace{overflow:hidden;background-color:#d5d5d5;width:50%;position:relative}#modules{z-index:1;height:100%;width:100%;position:relative}#infoRendering{color:white;position:absolute;top:10px;right:10px;width:auto;z-index:100;display:block;margin:0;text-align:right;user-select:none}#infoRendering p{margin:0}#dropdown{z-index:2;position:absolute;left:10px;bottom:10px}#dropdown .displayBlock{display:block !important}.canvasWindowWidth canvas{width:100% !important;left:0}.canvasWindowWidth button#toggleCanvas{opacity:0.5;left:10px;transform:rotate(180deg)}.canvasWindowWidth button#toggleCanvas:hover{opacity:1.0}#modulesDropdown{display:none;position:absolute;bottom:35px}.moduleButton{background-color:#8a979f;display:block;color:white;width:auto;height:35px;text-align:center;margin:0;margin-right:1px;margin-bottom:1px;border:none;cursor:pointer;border-radius:15px;font-size:18px;white-space:nowrap}.module{color:white;display:block;height:auto;width:max-content;position:absolute;text-align:center;background-color:black;border:solid 1px white;border-radius:15px;user-select:none;cursor:pointer;padding:23px}.module .innerModule{margin:10px 0}.module .image-data{width:0;height:0;border-left:7.5px solid transparent;border-right:7.5px solid transparent}.module .scene{width:15px;height:10px;background-color:var(--colorInputOutput)}.module .base-object{height:15px;width:15px;background-color:var(--colorInputOutput)}.module .input,.module .output{display:flex;justify-content:center;margin-left:5px;height:15px}.module .input:first-child,.module .output:first-child{margin-left:0}.module .input{margin-bottom:-23px;align-items:flex-end}.module .input span{position:relative;top:-23px}.module .input.connected{cursor:pointer !important}.module .input .image-data{cursor:default;border-bottom:15px solid;border-bottom-color:var(--colorInputOutput)}.module .input .scene{cursor:default;border-radius:100% 100% 0 0}.module .input .base-object{cursor:default}.module .output{align-items:flex-start;margin-top:-23px}.module .output .image-data{border-top:15px solid;border-top-color:var(--colorInputOutput)}.module .output .scene{border-radius:0 0 100% 100%}.module .icon{width:18px;position:absolute;bottom:5px;right:5px}.activeDot{height:10px;width:10px;position:absolute;top:4.5px;left:4.5px;background-color:#15f45b;border-radius:50%;display:none}.renderer{background-color:var(--colorMacroModule)}.renderer#activeRenderer .activeDot{display:inline-block}.dataLoader{background-color:var(--colorMlModule)}.dataLoader select{margin-top:10px}.filter{background-color:var(--colorMlModule)}.sceneGeometry{background-color:var(--colorSoModule)}.loaderSection{position:absolute;top:0;left:50%;width:50%;height:100%;z-index:100;background-color:rgba(240,240,240,0.7)}.loader{position:relative;top:calc(50% - 60px);margin:auto;border:16px solid #f3f3f3;border-top:16px solid #3498db;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.dialog{cursor:default;overflow:auto;z-index:999;position:fixed;top:45%;left:25%;transform:translate(-50%, -50%);width:auto;min-width:300px;border:none;border-radius:15px;padding:23px;background:white;color:black;box-shadow:2px 2px 5px rgba(0,0,0,0.3)}.dialog input{display:flex;width:fit-content}.dialog-backdrop{width:50%;height:100%;z-index:99;position:fixed;top:0%;left:0%;background:rgba(250,250,250,0.8)}.grid{display:grid;grid-template-columns:1fr 1fr;text-align:left}.grid:not(:first-of-type){margin-top:15px}.grid .autoUpdate{display:inline-flex}.grid select{width:fit-content}.grid .checkbox{cursor:pointer}\n',
                    '',
                ]);
                const s = o;
            },
            645: (t) => {
                'use strict';
                t.exports = function (t) {
                    var e = [];
                    return (
                        (e.toString = function () {
                            return this.map(function (e) {
                                var n = '',
                                    i = void 0 !== e[5];
                                return (
                                    e[4] &&
                                        (n += '@supports ('.concat(
                                            e[4],
                                            ') {'
                                        )),
                                    e[2] && (n += '@media '.concat(e[2], ' {')),
                                    i &&
                                        (n += '@layer'.concat(
                                            e[5].length > 0
                                                ? ' '.concat(e[5])
                                                : '',
                                            ' {'
                                        )),
                                    (n += t(e)),
                                    i && (n += '}'),
                                    e[2] && (n += '}'),
                                    e[4] && (n += '}'),
                                    n
                                );
                            }).join('');
                        }),
                        (e.i = function (t, n, i, r, a) {
                            'string' == typeof t && (t = [[null, t, void 0]]);
                            var o = {};
                            if (i)
                                for (var s = 0; s < this.length; s++) {
                                    var l = this[s][0];
                                    null != l && (o[l] = !0);
                                }
                            for (var c = 0; c < t.length; c++) {
                                var u = [].concat(t[c]);
                                (i && o[u[0]]) ||
                                    (void 0 !== a &&
                                        (void 0 === u[5] ||
                                            (u[1] = '@layer'
                                                .concat(
                                                    u[5].length > 0
                                                        ? ' '.concat(u[5])
                                                        : '',
                                                    ' {'
                                                )
                                                .concat(u[1], '}')),
                                        (u[5] = a)),
                                    n &&
                                        (u[2]
                                            ? ((u[1] = '@media '
                                                  .concat(u[2], ' {')
                                                  .concat(u[1], '}')),
                                              (u[2] = n))
                                            : (u[2] = n)),
                                    r &&
                                        (u[4]
                                            ? ((u[1] = '@supports ('
                                                  .concat(u[4], ') {')
                                                  .concat(u[1], '}')),
                                              (u[4] = r))
                                            : (u[4] = ''.concat(r))),
                                    e.push(u));
                            }
                        }),
                        e
                    );
                };
            },
            81: (t) => {
                'use strict';
                t.exports = function (t) {
                    return t[1];
                };
            },
            187: (t) => {
                'use strict';
                var e,
                    n = 'object' == typeof Reflect ? Reflect : null,
                    i =
                        n && 'function' == typeof n.apply
                            ? n.apply
                            : function (t, e, n) {
                                  return Function.prototype.apply.call(t, e, n);
                              };
                e =
                    n && 'function' == typeof n.ownKeys
                        ? n.ownKeys
                        : Object.getOwnPropertySymbols
                          ? function (t) {
                                return Object.getOwnPropertyNames(t).concat(
                                    Object.getOwnPropertySymbols(t)
                                );
                            }
                          : function (t) {
                                return Object.getOwnPropertyNames(t);
                            };
                var r =
                    Number.isNaN ||
                    function (t) {
                        return t != t;
                    };
                function a() {
                    a.init.call(this);
                }
                (t.exports = a),
                    (t.exports.once = function (t, e) {
                        return new Promise(function (n, i) {
                            function r(n) {
                                t.removeListener(e, a), i(n);
                            }
                            function a() {
                                'function' == typeof t.removeListener &&
                                    t.removeListener('error', r),
                                    n([].slice.call(arguments));
                            }
                            m(t, e, a, { once: !0 }),
                                'error' !== e &&
                                    (function (t, e, n) {
                                        'function' == typeof t.on &&
                                            m(t, 'error', e, { once: !0 });
                                    })(t, r);
                        });
                    }),
                    (a.EventEmitter = a),
                    (a.prototype._events = void 0),
                    (a.prototype._eventsCount = 0),
                    (a.prototype._maxListeners = void 0);
                var o = 10;
                function s(t) {
                    if ('function' != typeof t)
                        throw new TypeError(
                            'The "listener" argument must be of type Function. Received type ' +
                                typeof t
                        );
                }
                function l(t) {
                    return void 0 === t._maxListeners
                        ? a.defaultMaxListeners
                        : t._maxListeners;
                }
                function c(t, e, n, i) {
                    var r, a, o, c;
                    if (
                        (s(n),
                        void 0 === (a = t._events)
                            ? ((a = t._events = Object.create(null)),
                              (t._eventsCount = 0))
                            : (void 0 !== a.newListener &&
                                  (t.emit(
                                      'newListener',
                                      e,
                                      n.listener ? n.listener : n
                                  ),
                                  (a = t._events)),
                              (o = a[e])),
                        void 0 === o)
                    )
                        (o = a[e] = n), ++t._eventsCount;
                    else if (
                        ('function' == typeof o
                            ? (o = a[e] = i ? [n, o] : [o, n])
                            : i
                              ? o.unshift(n)
                              : o.push(n),
                        (r = l(t)) > 0 && o.length > r && !o.warned)
                    ) {
                        o.warned = !0;
                        var u = new Error(
                            'Possible EventEmitter memory leak detected. ' +
                                o.length +
                                ' ' +
                                String(e) +
                                ' listeners added. Use emitter.setMaxListeners() to increase limit'
                        );
                        (u.name = 'MaxListenersExceededWarning'),
                            (u.emitter = t),
                            (u.type = e),
                            (u.count = o.length),
                            (c = u),
                            console && console.warn && console.warn(c);
                    }
                    return t;
                }
                function u() {
                    if (!this.fired)
                        return (
                            this.target.removeListener(this.type, this.wrapFn),
                            (this.fired = !0),
                            0 === arguments.length
                                ? this.listener.call(this.target)
                                : this.listener.apply(this.target, arguments)
                        );
                }
                function h(t, e, n) {
                    var i = {
                            fired: !1,
                            wrapFn: void 0,
                            target: t,
                            type: e,
                            listener: n,
                        },
                        r = u.bind(i);
                    return (r.listener = n), (i.wrapFn = r), r;
                }
                function d(t, e, n) {
                    var i = t._events;
                    if (void 0 === i) return [];
                    var r = i[e];
                    return void 0 === r
                        ? []
                        : 'function' == typeof r
                          ? n
                              ? [r.listener || r]
                              : [r]
                          : n
                            ? (function (t) {
                                  for (
                                      var e = new Array(t.length), n = 0;
                                      n < e.length;
                                      ++n
                                  )
                                      e[n] = t[n].listener || t[n];
                                  return e;
                              })(r)
                            : f(r, r.length);
                }
                function p(t) {
                    var e = this._events;
                    if (void 0 !== e) {
                        var n = e[t];
                        if ('function' == typeof n) return 1;
                        if (void 0 !== n) return n.length;
                    }
                    return 0;
                }
                function f(t, e) {
                    for (var n = new Array(e), i = 0; i < e; ++i) n[i] = t[i];
                    return n;
                }
                function m(t, e, n, i) {
                    if ('function' == typeof t.on)
                        i.once ? t.once(e, n) : t.on(e, n);
                    else {
                        if ('function' != typeof t.addEventListener)
                            throw new TypeError(
                                'The "emitter" argument must be of type EventEmitter. Received type ' +
                                    typeof t
                            );
                        t.addEventListener(e, function r(a) {
                            i.once && t.removeEventListener(e, r), n(a);
                        });
                    }
                }
                Object.defineProperty(a, 'defaultMaxListeners', {
                    enumerable: !0,
                    get: function () {
                        return o;
                    },
                    set: function (t) {
                        if ('number' != typeof t || t < 0 || r(t))
                            throw new RangeError(
                                'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                                    t +
                                    '.'
                            );
                        o = t;
                    },
                }),
                    (a.init = function () {
                        (void 0 !== this._events &&
                            this._events !==
                                Object.getPrototypeOf(this)._events) ||
                            ((this._events = Object.create(null)),
                            (this._eventsCount = 0)),
                            (this._maxListeners = this._maxListeners || void 0);
                    }),
                    (a.prototype.setMaxListeners = function (t) {
                        if ('number' != typeof t || t < 0 || r(t))
                            throw new RangeError(
                                'The value of "n" is out of range. It must be a non-negative number. Received ' +
                                    t +
                                    '.'
                            );
                        return (this._maxListeners = t), this;
                    }),
                    (a.prototype.getMaxListeners = function () {
                        return l(this);
                    }),
                    (a.prototype.emit = function (t) {
                        for (var e = [], n = 1; n < arguments.length; n++)
                            e.push(arguments[n]);
                        var r = 'error' === t,
                            a = this._events;
                        if (void 0 !== a) r = r && void 0 === a.error;
                        else if (!r) return !1;
                        if (r) {
                            var o;
                            if (
                                (e.length > 0 && (o = e[0]), o instanceof Error)
                            )
                                throw o;
                            var s = new Error(
                                'Unhandled error.' +
                                    (o ? ' (' + o.message + ')' : '')
                            );
                            throw ((s.context = o), s);
                        }
                        var l = a[t];
                        if (void 0 === l) return !1;
                        if ('function' == typeof l) i(l, this, e);
                        else {
                            var c = l.length,
                                u = f(l, c);
                            for (n = 0; n < c; ++n) i(u[n], this, e);
                        }
                        return !0;
                    }),
                    (a.prototype.addListener = function (t, e) {
                        return c(this, t, e, !1);
                    }),
                    (a.prototype.on = a.prototype.addListener),
                    (a.prototype.prependListener = function (t, e) {
                        return c(this, t, e, !0);
                    }),
                    (a.prototype.once = function (t, e) {
                        return s(e), this.on(t, h(this, t, e)), this;
                    }),
                    (a.prototype.prependOnceListener = function (t, e) {
                        return (
                            s(e), this.prependListener(t, h(this, t, e)), this
                        );
                    }),
                    (a.prototype.removeListener = function (t, e) {
                        var n, i, r, a, o;
                        if ((s(e), void 0 === (i = this._events))) return this;
                        if (void 0 === (n = i[t])) return this;
                        if (n === e || n.listener === e)
                            0 == --this._eventsCount
                                ? (this._events = Object.create(null))
                                : (delete i[t],
                                  i.removeListener &&
                                      this.emit(
                                          'removeListener',
                                          t,
                                          n.listener || e
                                      ));
                        else if ('function' != typeof n) {
                            for (r = -1, a = n.length - 1; a >= 0; a--)
                                if (n[a] === e || n[a].listener === e) {
                                    (o = n[a].listener), (r = a);
                                    break;
                                }
                            if (r < 0) return this;
                            0 === r
                                ? n.shift()
                                : (function (t, e) {
                                      for (; e + 1 < t.length; e++)
                                          t[e] = t[e + 1];
                                      t.pop();
                                  })(n, r),
                                1 === n.length && (i[t] = n[0]),
                                void 0 !== i.removeListener &&
                                    this.emit('removeListener', t, o || e);
                        }
                        return this;
                    }),
                    (a.prototype.off = a.prototype.removeListener),
                    (a.prototype.removeAllListeners = function (t) {
                        var e, n, i;
                        if (void 0 === (n = this._events)) return this;
                        if (void 0 === n.removeListener)
                            return (
                                0 === arguments.length
                                    ? ((this._events = Object.create(null)),
                                      (this._eventsCount = 0))
                                    : void 0 !== n[t] &&
                                      (0 == --this._eventsCount
                                          ? (this._events = Object.create(null))
                                          : delete n[t]),
                                this
                            );
                        if (0 === arguments.length) {
                            var r,
                                a = Object.keys(n);
                            for (i = 0; i < a.length; ++i)
                                'removeListener' !== (r = a[i]) &&
                                    this.removeAllListeners(r);
                            return (
                                this.removeAllListeners('removeListener'),
                                (this._events = Object.create(null)),
                                (this._eventsCount = 0),
                                this
                            );
                        }
                        if ('function' == typeof (e = n[t]))
                            this.removeListener(t, e);
                        else if (void 0 !== e)
                            for (i = e.length - 1; i >= 0; i--)
                                this.removeListener(t, e[i]);
                        return this;
                    }),
                    (a.prototype.listeners = function (t) {
                        return d(this, t, !0);
                    }),
                    (a.prototype.rawListeners = function (t) {
                        return d(this, t, !1);
                    }),
                    (a.listenerCount = function (t, e) {
                        return 'function' == typeof t.listenerCount
                            ? t.listenerCount(e)
                            : p.call(t, e);
                    }),
                    (a.prototype.listenerCount = p),
                    (a.prototype.eventNames = function () {
                        return this._eventsCount > 0 ? e(this._events) : [];
                    });
            },
            91: (t) => {
                'use strict';
                t.exports = function (t, e) {
                    return (
                        e || (e = {}),
                        t
                            ? ((t = String(t.__esModule ? t.default : t)),
                              e.hash && (t += e.hash),
                              e.maybeNeedQuotes && /[\t\n\f\r "'=<>`]/.test(t)
                                  ? '"'.concat(t, '"')
                                  : t)
                            : t
                    );
                };
            },
            379: (t) => {
                'use strict';
                var e = [];
                function n(t) {
                    for (var n = -1, i = 0; i < e.length; i++)
                        if (e[i].identifier === t) {
                            n = i;
                            break;
                        }
                    return n;
                }
                function i(t, i) {
                    for (var a = {}, o = [], s = 0; s < t.length; s++) {
                        var l = t[s],
                            c = i.base ? l[0] + i.base : l[0],
                            u = a[c] || 0,
                            h = ''.concat(c, ' ').concat(u);
                        a[c] = u + 1;
                        var d = n(h),
                            p = {
                                css: l[1],
                                media: l[2],
                                sourceMap: l[3],
                                supports: l[4],
                                layer: l[5],
                            };
                        if (-1 !== d) e[d].references++, e[d].updater(p);
                        else {
                            var f = r(p, i);
                            (i.byIndex = s),
                                e.splice(s, 0, {
                                    identifier: h,
                                    updater: f,
                                    references: 1,
                                });
                        }
                        o.push(h);
                    }
                    return o;
                }
                function r(t, e) {
                    var n = e.domAPI(e);
                    return (
                        n.update(t),
                        function (e) {
                            if (e) {
                                if (
                                    e.css === t.css &&
                                    e.media === t.media &&
                                    e.sourceMap === t.sourceMap &&
                                    e.supports === t.supports &&
                                    e.layer === t.layer
                                )
                                    return;
                                n.update((t = e));
                            } else n.remove();
                        }
                    );
                }
                t.exports = function (t, r) {
                    var a = i((t = t || []), (r = r || {}));
                    return function (t) {
                        t = t || [];
                        for (var o = 0; o < a.length; o++) {
                            var s = n(a[o]);
                            e[s].references--;
                        }
                        for (var l = i(t, r), c = 0; c < a.length; c++) {
                            var u = n(a[c]);
                            0 === e[u].references &&
                                (e[u].updater(), e.splice(u, 1));
                        }
                        a = l;
                    };
                };
            },
            569: (t) => {
                'use strict';
                var e = {};
                t.exports = function (t, n) {
                    var i = (function (t) {
                        if (void 0 === e[t]) {
                            var n = document.querySelector(t);
                            if (
                                window.HTMLIFrameElement &&
                                n instanceof window.HTMLIFrameElement
                            )
                                try {
                                    n = n.contentDocument.head;
                                } catch (t) {
                                    n = null;
                                }
                            e[t] = n;
                        }
                        return e[t];
                    })(t);
                    if (!i)
                        throw new Error(
                            "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
                        );
                    i.appendChild(n);
                };
            },
            216: (t) => {
                'use strict';
                t.exports = function (t) {
                    var e = document.createElement('style');
                    return (
                        t.setAttributes(e, t.attributes),
                        t.insert(e, t.options),
                        e
                    );
                };
            },
            565: (t, e, n) => {
                'use strict';
                t.exports = function (t) {
                    var e = n.nc;
                    e && t.setAttribute('nonce', e);
                };
            },
            795: (t) => {
                'use strict';
                t.exports = function (t) {
                    var e = t.insertStyleElement(t);
                    return {
                        update: function (n) {
                            !(function (t, e, n) {
                                var i = '';
                                n.supports &&
                                    (i += '@supports ('.concat(
                                        n.supports,
                                        ') {'
                                    )),
                                    n.media &&
                                        (i += '@media '.concat(n.media, ' {'));
                                var r = void 0 !== n.layer;
                                r &&
                                    (i += '@layer'.concat(
                                        n.layer.length > 0
                                            ? ' '.concat(n.layer)
                                            : '',
                                        ' {'
                                    )),
                                    (i += n.css),
                                    r && (i += '}'),
                                    n.media && (i += '}'),
                                    n.supports && (i += '}');
                                var a = n.sourceMap;
                                a &&
                                    'undefined' != typeof btoa &&
                                    (i +=
                                        '\n/*# sourceMappingURL=data:application/json;base64,'.concat(
                                            btoa(
                                                unescape(
                                                    encodeURIComponent(
                                                        JSON.stringify(a)
                                                    )
                                                )
                                            ),
                                            ' */'
                                        )),
                                    e.styleTagTransform(i, t, e.options);
                            })(e, t, n);
                        },
                        remove: function () {
                            !(function (t) {
                                if (null === t.parentNode) return !1;
                                t.parentNode.removeChild(t);
                            })(e);
                        },
                    };
                };
            },
            589: (t) => {
                'use strict';
                t.exports = function (t, e) {
                    if (e.styleSheet) e.styleSheet.cssText = t;
                    else {
                        for (; e.firstChild; ) e.removeChild(e.firstChild);
                        e.appendChild(document.createTextNode(t));
                    }
                };
            },
            294: (t, e, n) => {
                'use strict';
                n.d(e, { Z: () => o });
                var i,
                    r = (function () {
                        function t(t) {
                            var e, n;
                            (this.dialog = document.createElement('div')),
                                (this.checkbox =
                                    document.createElement('input')),
                                (this.backdrop = document.createElement('div')),
                                (this.cancelButton =
                                    document.createElement('button')),
                                (this.updateButton =
                                    document.createElement('button')),
                                null === (e = this.dialog) ||
                                    void 0 === e ||
                                    e.classList.add('dialog'),
                                null === (n = this.backdrop) ||
                                    void 0 === n ||
                                    n.classList.add('dialog-backdrop'),
                                (this.submitCallback = t),
                                this.createDialog(),
                                this.onSubmit(),
                                this.onCancel();
                        }
                        return (
                            (t.prototype.openDialog = function () {
                                var t, e;
                                this.dialog &&
                                    this.backdrop &&
                                    (null ===
                                        (t =
                                            document.getElementById(
                                                'workspace'
                                            )) ||
                                        void 0 === t ||
                                        t.appendChild(this.dialog),
                                    null ===
                                        (e =
                                            document.getElementById(
                                                'workspace'
                                            )) ||
                                        void 0 === e ||
                                        e.appendChild(this.backdrop));
                            }),
                            (t.prototype.destroy = function () {
                                this.releaseResources(), this.releaseInChild();
                            }),
                            (t.prototype.onSubmit = function () {
                                var t,
                                    e = this;
                                null === (t = this.updateButton) ||
                                    void 0 === t ||
                                    t.addEventListener('click', function (t) {
                                        t.preventDefault(),
                                            e.submit(),
                                            e.callback(),
                                            e.closeDialog();
                                    });
                            }),
                            (t.prototype.onCancel = function () {
                                var t,
                                    e = this;
                                null === (t = this.cancelButton) ||
                                    void 0 === t ||
                                    t.addEventListener('click', function (t) {
                                        t.preventDefault(),
                                            e.cancel(),
                                            e.closeDialog();
                                    });
                            }),
                            (t.prototype.closeDialog = function () {
                                var t, e;
                                null === (t = this.dialog) ||
                                    void 0 === t ||
                                    t.remove(),
                                    null === (e = this.backdrop) ||
                                        void 0 === e ||
                                        e.remove();
                            }),
                            (t.prototype.createDialog = function () {
                                var t, e;
                                this.cancelButton &&
                                    (this.cancelButton.classList.add('cancel'),
                                    (this.cancelButton.innerHTML = '<p>x</p>'),
                                    (this.cancelButton.value = 'cancel'),
                                    (this.cancelButton.formMethod = 'dialog'),
                                    null === (t = this.dialog) ||
                                        void 0 === t ||
                                        t.appendChild(this.cancelButton)),
                                    this.createDialogSettings();
                                var n = document.createElement('div');
                                if (
                                    (n.classList.add('grid'),
                                    null === (e = this.dialog) ||
                                        void 0 === e ||
                                        e.appendChild(n),
                                    this.checkbox)
                                ) {
                                    var i = document.createElement('div');
                                    i.classList.add('autoUpdate'),
                                        (this.checkbox.type = 'checkbox'),
                                        this.checkbox.classList.add('checkbox'),
                                        (this.checkbox.checked = !1),
                                        i.appendChild(this.checkbox);
                                    var r = document.createElement('span');
                                    (r.innerHTML = '<p>Auto update</p>'),
                                        i.appendChild(r),
                                        n.appendChild(i);
                                }
                                this.updateButton &&
                                    (this.updateButton.classList.add('update'),
                                    (this.updateButton.innerHTML =
                                        '<p>Update</p>'),
                                    (this.updateButton.value = 'default'),
                                    n.appendChild(this.updateButton));
                            }),
                            (t.prototype.releaseResources = function () {
                                delete this.submitCallback,
                                    delete this.dialog,
                                    delete this.checkbox,
                                    delete this.cancelButton,
                                    delete this.updateButton;
                            }),
                            t
                        );
                    })(),
                    a =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    o = (function (t) {
                        function e(e, n) {
                            var i = t.call(this, e) || this;
                            return (i.gaussSigma = n), i.onSelect(), i;
                        }
                        return (
                            a(e, t),
                            (e.prototype.callback = function () {
                                var t;
                                null === (t = this.submitCallback) ||
                                    void 0 === t ||
                                    t.call(
                                        this,
                                        this.gaussSigma ? this.gaussSigma : 0
                                    );
                            }),
                            (e.prototype.cancel = function () {
                                var t;
                                this.select &&
                                    this.dialog &&
                                    (this.select.value = this.gaussSigma
                                        ? null === (t = this.gaussSigma) ||
                                          void 0 === t
                                            ? void 0
                                            : t.toString()
                                        : '0');
                            }),
                            (e.prototype.createDialogSettings = function () {
                                var t;
                                (this.label = document.createElement('label')),
                                    (this.select =
                                        document.createElement('input'));
                                var e = document.createElement('div');
                                e.classList.add('grid'),
                                    null === (t = this.dialog) ||
                                        void 0 === t ||
                                        t.appendChild(e),
                                    this.label &&
                                        ((this.label.textContent =
                                            'Gauss sigma:'),
                                        e.appendChild(this.label)),
                                    this.select &&
                                        ((this.select.type = 'number'),
                                        (this.select.min = '0.5'),
                                        (this.select.max = '5'),
                                        (this.select.step = '0.5'),
                                        (this.select.value = this.gaussSigma
                                            ? this.gaussSigma.toString()
                                            : '1'),
                                        e.appendChild(this.select));
                            }),
                            (e.prototype.submit = function () {
                                this.dialog &&
                                    this.select &&
                                    (this.gaussSigma = parseFloat(
                                        this.select.value
                                    ));
                            }),
                            (e.prototype.releaseInChild = function () {
                                delete this.label,
                                    delete this.select,
                                    delete this.gaussSigma;
                            }),
                            (e.prototype.onSelect = function () {
                                var t,
                                    e = this;
                                null === (t = this.select) ||
                                    void 0 === t ||
                                    t.addEventListener('change', function () {
                                        var t, n;
                                        e.select &&
                                            (null === (t = e.checkbox) ||
                                            void 0 === t
                                                ? void 0
                                                : t.checked) &&
                                            e.dialog &&
                                            ((e.gaussSigma = parseFloat(
                                                e.select.value
                                            )),
                                            null === (n = e.submitCallback) ||
                                                void 0 === n ||
                                                n.call(e, e.gaussSigma));
                                    });
                            }),
                            e
                        );
                    })(r);
            },
            362: (t, e, n) => {
                'use strict';
                n.d(e, { X: () => c });
                var i,
                    r = n(423),
                    a = n(734),
                    o =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    s = function (t, e, n, i) {
                        return new (n || (n = Promise))(function (r, a) {
                            function o(t) {
                                try {
                                    l(i.next(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function s(t) {
                                try {
                                    l(i.throw(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function l(t) {
                                var e;
                                t.done
                                    ? r(t.value)
                                    : ((e = t.value),
                                      e instanceof n
                                          ? e
                                          : new n(function (t) {
                                                t(e);
                                            })).then(o, s);
                            }
                            l((i = i.apply(t, e || [])).next());
                        });
                    },
                    l = function (t, e) {
                        var n,
                            i,
                            r,
                            a,
                            o = {
                                label: 0,
                                sent: function () {
                                    if (1 & r[0]) throw r[1];
                                    return r[1];
                                },
                                trys: [],
                                ops: [],
                            };
                        return (
                            (a = { next: s(0), throw: s(1), return: s(2) }),
                            'function' == typeof Symbol &&
                                (a[Symbol.iterator] = function () {
                                    return this;
                                }),
                            a
                        );
                        function s(s) {
                            return function (l) {
                                return (function (s) {
                                    if (n)
                                        throw new TypeError(
                                            'Generator is already executing.'
                                        );
                                    for (; a && ((a = 0), s[0] && (o = 0)), o; )
                                        try {
                                            if (
                                                ((n = 1),
                                                i &&
                                                    (r =
                                                        2 & s[0]
                                                            ? i.return
                                                            : s[0]
                                                              ? i.throw ||
                                                                ((r =
                                                                    i.return) &&
                                                                    r.call(i),
                                                                0)
                                                              : i.next) &&
                                                    !(r = r.call(i, s[1])).done)
                                            )
                                                return r;
                                            switch (
                                                ((i = 0),
                                                r && (s = [2 & s[0], r.value]),
                                                s[0])
                                            ) {
                                                case 0:
                                                case 1:
                                                    r = s;
                                                    break;
                                                case 4:
                                                    return (
                                                        o.label++,
                                                        {
                                                            value: s[1],
                                                            done: !1,
                                                        }
                                                    );
                                                case 5:
                                                    o.label++,
                                                        (i = s[1]),
                                                        (s = [0]);
                                                    continue;
                                                case 7:
                                                    (s = o.ops.pop()),
                                                        o.trys.pop();
                                                    continue;
                                                default:
                                                    if (
                                                        !(
                                                            (r =
                                                                (r = o.trys)
                                                                    .length >
                                                                    0 &&
                                                                r[
                                                                    r.length - 1
                                                                ]) ||
                                                            (6 !== s[0] &&
                                                                2 !== s[0])
                                                        )
                                                    ) {
                                                        o = 0;
                                                        continue;
                                                    }
                                                    if (
                                                        3 === s[0] &&
                                                        (!r ||
                                                            (s[1] > r[0] &&
                                                                s[1] < r[3]))
                                                    ) {
                                                        o.label = s[1];
                                                        break;
                                                    }
                                                    if (
                                                        6 === s[0] &&
                                                        o.label < r[1]
                                                    ) {
                                                        (o.label = r[1]),
                                                            (r = s);
                                                        break;
                                                    }
                                                    if (r && o.label < r[2]) {
                                                        (o.label = r[2]),
                                                            o.ops.push(s);
                                                        break;
                                                    }
                                                    r[2] && o.ops.pop(),
                                                        o.trys.pop();
                                                    continue;
                                            }
                                            s = e.call(t, o);
                                        } catch (t) {
                                            (s = [6, t]), (i = 0);
                                        } finally {
                                            n = r = 0;
                                        }
                                    if (5 & s[0]) throw s[1];
                                    return {
                                        value: s[0] ? s[1] : void 0,
                                        done: !0,
                                    };
                                })([s, l]);
                            };
                        }
                    },
                    c = (function (t) {
                        function e(e, n, i) {
                            void 0 === i && (i = void 0);
                            var r,
                                a,
                                o,
                                s = this;
                            return (
                                ((s = t.call(this, e, n, i) || this).logRows =
                                    'Voxels, DataType, Modality, KernelSize, Execution Time(ms)}\n'),
                                (s.loaderSection =
                                    document.createElement('section')),
                                (s.loader = document.createElement('div')),
                                (s.isLoggingEnabled = !1),
                                null === (r = s.loaderSection) ||
                                    void 0 === r ||
                                    r.classList.add('loaderSection'),
                                null === (a = s.loader) ||
                                    void 0 === a ||
                                    a.classList.add('loader'),
                                s.loader &&
                                    (null === (o = s.loaderSection) ||
                                        void 0 === o ||
                                        o.appendChild(s.loader)),
                                s
                            );
                        }
                        return (
                            o(e, t),
                            (e.prototype.onUpdateImageDataInput = function () {
                                var t, e, n, i, r, a, o;
                                return s(this, void 0, void 0, function () {
                                    return l(this, function (s) {
                                        switch (s.label) {
                                            case 0:
                                                return this.imageDataOutputs
                                                    ? (null ===
                                                          (t =
                                                              this
                                                                  .imageDataOutputs) ||
                                                      void 0 === t
                                                          ? void 0
                                                          : t.length) <= 1
                                                        ? (this.setImageDataProperties(),
                                                          this
                                                              .imageDataOutputs[0]
                                                              .shader &&
                                                              (null ===
                                                                  (n =
                                                                      null ===
                                                                          (e =
                                                                              this
                                                                                  .imageDataInputs) ||
                                                                      void 0 ===
                                                                          e
                                                                          ? void 0
                                                                          : e[0]
                                                                                .shader) ||
                                                              void 0 === n
                                                                  ? void 0
                                                                  : n.kernels) &&
                                                              (this.imageDataOutputs[0].shader.kernels =
                                                                  null ===
                                                                      (r =
                                                                          null ===
                                                                              (i =
                                                                                  this
                                                                                      .imageDataInputs) ||
                                                                          void 0 ===
                                                                              i
                                                                              ? void 0
                                                                              : i[0]
                                                                                    .shader) ||
                                                                  void 0 === r
                                                                      ? void 0
                                                                      : r.kernels),
                                                          this
                                                              .imageDataOutputs[0]
                                                              .data
                                                              ? (
                                                                    null ===
                                                                        (o =
                                                                            null ===
                                                                                (a =
                                                                                    this
                                                                                        .imageDataInputs) ||
                                                                            void 0 ===
                                                                                a
                                                                                ? void 0
                                                                                : a[0]
                                                                                      .data) ||
                                                                    void 0 === o
                                                                        ? void 0
                                                                        : o.data
                                                                )
                                                                  ? [
                                                                        4,
                                                                        this.setFilteredOutput(),
                                                                    ]
                                                                  : [3, 2]
                                                              : [3, 3])
                                                        : [3, 4]
                                                    : [3, 5];
                                            case 1:
                                                return s.sent(), [3, 3];
                                            case 2:
                                                (this.imageDataOutputs[0].data.data =
                                                    null),
                                                    (s.label = 3);
                                            case 3:
                                                return [3, 5];
                                            case 4:
                                                throw Error(
                                                    'Filter with more than one output not possible!'
                                                );
                                            case 5:
                                                return [2];
                                        }
                                    });
                                });
                            }),
                            (e.prototype.setFilteredOutput = function () {
                                var t, e, n, i, a;
                                return s(this, void 0, void 0, function () {
                                    var o, s, c, u, h, d, p, f, m, g;
                                    return l(this, function (l) {
                                        switch (l.label) {
                                            case 0:
                                                return (null ===
                                                    (e =
                                                        null ===
                                                            (t =
                                                                this
                                                                    .imageDataInputs) ||
                                                        void 0 === t
                                                            ? void 0
                                                            : t[0].data) ||
                                                void 0 === e
                                                    ? void 0
                                                    : e.data) &&
                                                    (null ===
                                                        (n =
                                                            this
                                                                .imageDataOutputs) ||
                                                    void 0 === n
                                                        ? void 0
                                                        : n[0].data)
                                                    ? (this.loaderSection &&
                                                          document.body.appendChild(
                                                              this.loaderSection
                                                          ),
                                                      [
                                                          4,
                                                          new Promise(function (
                                                              t
                                                          ) {
                                                              return setTimeout(
                                                                  t,
                                                                  50
                                                              );
                                                          }),
                                                      ])
                                                    : [3, 2];
                                            case 1:
                                                if (
                                                    (l.sent(),
                                                    this.isLoggingEnabled)
                                                ) {
                                                    for (
                                                        o =
                                                            null ===
                                                                (i =
                                                                    this
                                                                        .kernel) ||
                                                            void 0 === i
                                                                ? void 0
                                                                : i.length,
                                                            s = 0,
                                                            c = 0;
                                                        c < 5;
                                                        c++
                                                    )
                                                        (u = new Date()),
                                                            (this.imageDataOutputs[0].data.data =
                                                                this.filterImageData()),
                                                            (h = new Date()),
                                                            (d =
                                                                h.getTime() -
                                                                u.getTime()),
                                                            (s += d);
                                                    this.logRows &&
                                                        ((p = this
                                                            .imageDataOutputs[0]
                                                            .data.data
                                                            ? this
                                                                  .imageDataOutputs[0]
                                                                  .data.data
                                                                  .length
                                                            : 0),
                                                        (f =
                                                            this
                                                                .imageDataInputs[0]
                                                                .data.dataType),
                                                        (m =
                                                            this
                                                                .imageDataInputs[0]
                                                                .data.modality),
                                                        (g = s / 5),
                                                        (this.logRows =
                                                            this.logRows +
                                                            '\n'
                                                                .concat(p, ', ')
                                                                .concat(f, ', ')
                                                                .concat(m, ', ')
                                                                .concat(o, ', ')
                                                                .concat(g)),
                                                        (0, r.T)(
                                                            this.logRows,
                                                            'filter-execution-time-'.concat(
                                                                this.moduleName
                                                            )
                                                        ));
                                                } else
                                                    this.imageDataOutputs[0].data.data =
                                                        this.filterImageData();
                                                null ===
                                                    (a = this.loaderSection) ||
                                                    void 0 === a ||
                                                    a.remove(),
                                                    (l.label = 2);
                                            case 2:
                                                return [2];
                                        }
                                    });
                                });
                            }),
                            (e.prototype.releaseFilterChild = function () {
                                delete this.logRows,
                                    delete this.loaderSection,
                                    delete this.loader,
                                    delete this.isLoggingEnabled;
                            }),
                            (e.prototype.filterImageData = function () {
                                var t, e, n;
                                if (
                                    this.imageDataOutputs &&
                                    (null ===
                                        (e =
                                            null ===
                                                (t = this.imageDataInputs) ||
                                            void 0 === t
                                                ? void 0
                                                : t[0].data) || void 0 === e
                                        ? void 0
                                        : e.data) &&
                                    this.kernel
                                ) {
                                    var i = this.imageDataInputs[0].data.data,
                                        r = Math.sqrt(this.kernel.length);
                                    if (r !== Math.floor(r) && r % 2 == 1)
                                        throw new Error('Invalid kernel');
                                    var a = Math.floor(r / 2);
                                    if (
                                        (null === (n = this.imageDataOutputs) ||
                                        void 0 === n
                                            ? void 0
                                            : n.length) <= 1
                                    ) {
                                        for (
                                            var o =
                                                    this.imageDataInputs[0].data
                                                        .width,
                                                s =
                                                    this.imageDataInputs[0].data
                                                        .height,
                                                l =
                                                    this.imageDataInputs[0].data
                                                        .depth,
                                                c = o - 2 * a,
                                                u = s - 2 * a,
                                                h = c * u * l,
                                                d =
                                                    i instanceof Uint16Array
                                                        ? new Uint16Array(h)
                                                        : new Uint8Array(h),
                                                p = 0,
                                                f = 0;
                                            f < l;
                                            f++
                                        )
                                            for (
                                                var m = f * s * o, g = a;
                                                g < s - a;
                                                g++
                                            )
                                                for (
                                                    var v = g * o, _ = a;
                                                    _ < o - a;
                                                    _++
                                                ) {
                                                    for (
                                                        var x = 0,
                                                            y = m + v + _,
                                                            M = 0,
                                                            b = -a;
                                                        b <= a;
                                                        b++
                                                    )
                                                        for (
                                                            var E = b * o,
                                                                S = -a;
                                                            S <= a;
                                                            S++
                                                        ) {
                                                            var T =
                                                                this.kernel[M];
                                                            (x +=
                                                                i[y + E + S] *
                                                                T),
                                                                (M += 1);
                                                        }
                                                    var w = x > 0 ? x : 0;
                                                    (d[p] = w), (p += 1);
                                                }
                                        return (
                                            this.imageDataOutputs[0].data &&
                                                ((this.imageDataOutputs[0].data.width =
                                                    c),
                                                (this.imageDataOutputs[0].data.height =
                                                    u)),
                                            d
                                        );
                                    }
                                    throw Error(
                                        'Filter with more than one output not possible!'
                                    );
                                }
                                return null;
                            }),
                            e
                        );
                    })(a.w);
            },
            541: (t, e, n) => {
                'use strict';
                n.d(e, { f: () => o });
                var i,
                    r = n(734),
                    a =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    o = (function (t) {
                        function e(e, n, i) {
                            return (
                                void 0 === i && (i = void 0),
                                t.call(this, e, n, i) || this
                            );
                        }
                        return (
                            a(e, t),
                            (e.prototype.onUpdateImageDataInput = function () {
                                var t, e, n, i, r, a, o, s, l, c, u;
                                return (
                                    (s = this),
                                    (l = void 0),
                                    (u = function () {
                                        var s;
                                        return (function (t, e) {
                                            var n,
                                                i,
                                                r,
                                                a,
                                                o = {
                                                    label: 0,
                                                    sent: function () {
                                                        if (1 & r[0])
                                                            throw r[1];
                                                        return r[1];
                                                    },
                                                    trys: [],
                                                    ops: [],
                                                };
                                            return (
                                                (a = {
                                                    next: s(0),
                                                    throw: s(1),
                                                    return: s(2),
                                                }),
                                                'function' == typeof Symbol &&
                                                    (a[Symbol.iterator] =
                                                        function () {
                                                            return this;
                                                        }),
                                                a
                                            );
                                            function s(s) {
                                                return function (l) {
                                                    return (function (s) {
                                                        if (n)
                                                            throw new TypeError(
                                                                'Generator is already executing.'
                                                            );
                                                        for (
                                                            ;
                                                            a &&
                                                                ((a = 0),
                                                                s[0] &&
                                                                    (o = 0)),
                                                                o;

                                                        )
                                                            try {
                                                                if (
                                                                    ((n = 1),
                                                                    i &&
                                                                        (r =
                                                                            2 &
                                                                            s[0]
                                                                                ? i.return
                                                                                : s[0]
                                                                                  ? i.throw ||
                                                                                    ((r =
                                                                                        i.return) &&
                                                                                        r.call(
                                                                                            i
                                                                                        ),
                                                                                    0)
                                                                                  : i.next) &&
                                                                        !(r =
                                                                            r.call(
                                                                                i,
                                                                                s[1]
                                                                            ))
                                                                            .done)
                                                                )
                                                                    return r;
                                                                switch (
                                                                    ((i = 0),
                                                                    r &&
                                                                        (s = [
                                                                            2 &
                                                                                s[0],
                                                                            r.value,
                                                                        ]),
                                                                    s[0])
                                                                ) {
                                                                    case 0:
                                                                    case 1:
                                                                        r = s;
                                                                        break;
                                                                    case 4:
                                                                        return (
                                                                            o.label++,
                                                                            {
                                                                                value: s[1],
                                                                                done: !1,
                                                                            }
                                                                        );
                                                                    case 5:
                                                                        o.label++,
                                                                            (i =
                                                                                s[1]),
                                                                            (s =
                                                                                [
                                                                                    0,
                                                                                ]);
                                                                        continue;
                                                                    case 7:
                                                                        (s =
                                                                            o.ops.pop()),
                                                                            o.trys.pop();
                                                                        continue;
                                                                    default:
                                                                        if (
                                                                            !(
                                                                                (r =
                                                                                    (r =
                                                                                        o.trys)
                                                                                        .length >
                                                                                        0 &&
                                                                                    r[
                                                                                        r.length -
                                                                                            1
                                                                                    ]) ||
                                                                                (6 !==
                                                                                    s[0] &&
                                                                                    2 !==
                                                                                        s[0])
                                                                            )
                                                                        ) {
                                                                            o = 0;
                                                                            continue;
                                                                        }
                                                                        if (
                                                                            3 ===
                                                                                s[0] &&
                                                                            (!r ||
                                                                                (s[1] >
                                                                                    r[0] &&
                                                                                    s[1] <
                                                                                        r[3]))
                                                                        ) {
                                                                            o.label =
                                                                                s[1];
                                                                            break;
                                                                        }
                                                                        if (
                                                                            6 ===
                                                                                s[0] &&
                                                                            o.label <
                                                                                r[1]
                                                                        ) {
                                                                            (o.label =
                                                                                r[1]),
                                                                                (r =
                                                                                    s);
                                                                            break;
                                                                        }
                                                                        if (
                                                                            r &&
                                                                            o.label <
                                                                                r[2]
                                                                        ) {
                                                                            (o.label =
                                                                                r[2]),
                                                                                o.ops.push(
                                                                                    s
                                                                                );
                                                                            break;
                                                                        }
                                                                        r[2] &&
                                                                            o.ops.pop(),
                                                                            o.trys.pop();
                                                                        continue;
                                                                }
                                                                s = e.call(
                                                                    t,
                                                                    o
                                                                );
                                                            } catch (t) {
                                                                (s = [6, t]),
                                                                    (i = 0);
                                                            } finally {
                                                                n = r = 0;
                                                            }
                                                        if (5 & s[0])
                                                            throw s[1];
                                                        return {
                                                            value: s[0]
                                                                ? s[1]
                                                                : void 0,
                                                            done: !0,
                                                        };
                                                    })([s, l]);
                                                };
                                            }
                                        })(this, function (l) {
                                            if (
                                                this.imageDataOutputs &&
                                                this.kernel
                                            ) {
                                                if (
                                                    (s = Math.sqrt(
                                                        this.kernel.length
                                                    )) !== Math.floor(s) &&
                                                    s % 2 == 1
                                                )
                                                    throw new Error(
                                                        'Invalid kernel'
                                                    );
                                                if (
                                                    !(
                                                        (null ===
                                                            (t =
                                                                this
                                                                    .imageDataOutputs) ||
                                                        void 0 === t
                                                            ? void 0
                                                            : t.length) <= 1
                                                    )
                                                )
                                                    throw Error(
                                                        'Filter with more than one output not possible!'
                                                    );
                                                this.setImageDataProperties(),
                                                    this.imageDataOutputs[0]
                                                        .data &&
                                                        this.imageDataOutputs[0]
                                                            .data &&
                                                        (((null ===
                                                            (n =
                                                                null ===
                                                                    (e =
                                                                        this
                                                                            .imageDataInputs) ||
                                                                void 0 === e
                                                                    ? void 0
                                                                    : e[0]
                                                                          .data) ||
                                                        void 0 === n
                                                            ? void 0
                                                            : n.data) ||
                                                            null ===
                                                                (null ===
                                                                    (r =
                                                                        null ===
                                                                            (i =
                                                                                this
                                                                                    .imageDataInputs) ||
                                                                        void 0 ===
                                                                            i
                                                                            ? void 0
                                                                            : i[0]
                                                                                  .data) ||
                                                                void 0 === r
                                                                    ? void 0
                                                                    : r.data)) &&
                                                            (this.imageDataOutputs[0].data.data =
                                                                null ===
                                                                    (o =
                                                                        null ===
                                                                            (a =
                                                                                this
                                                                                    .imageDataInputs) ||
                                                                        void 0 ===
                                                                            a
                                                                            ? void 0
                                                                            : a[0]
                                                                                  .data) ||
                                                                void 0 === o
                                                                    ? void 0
                                                                    : o.data),
                                                        this.setFilteredOutput());
                                            }
                                            return [2];
                                        });
                                    }),
                                    new ((c = void 0) || (c = Promise))(
                                        function (t, e) {
                                            function n(t) {
                                                try {
                                                    r(u.next(t));
                                                } catch (t) {
                                                    e(t);
                                                }
                                            }
                                            function i(t) {
                                                try {
                                                    r(u.throw(t));
                                                } catch (t) {
                                                    e(t);
                                                }
                                            }
                                            function r(e) {
                                                var r;
                                                e.done
                                                    ? t(e.value)
                                                    : ((r = e.value),
                                                      r instanceof c
                                                          ? r
                                                          : new c(function (t) {
                                                                t(r);
                                                            })).then(n, i);
                                            }
                                            r((u = u.apply(s, l || [])).next());
                                        }
                                    )
                                );
                            }),
                            (e.prototype.setFilteredOutput = function () {
                                var t, e, n, i;
                                this.imageDataOutputs &&
                                    this.kernel &&
                                    (null === (t = this.imageDataInputs) ||
                                    void 0 === t
                                        ? void 0
                                        : t[0].shader) &&
                                    this.imageDataOutputs[0].shader &&
                                    ((this.imageDataOutputs[0].shader.kernels =
                                        null === (e = this.imageDataInputs) ||
                                        void 0 === e
                                            ? void 0
                                            : e[0].shader.kernels.slice()),
                                    null ===
                                        (i =
                                            null ===
                                                (n =
                                                    this.imageDataOutputs[0]
                                                        .shader) || void 0 === n
                                                ? void 0
                                                : n.kernels) ||
                                        void 0 === i ||
                                        i.push(this.kernel));
                            }),
                            (e.prototype.releaseFilterChild = function () {}),
                            e
                        );
                    })(r.w);
            },
            734: (t, e, n) => {
                'use strict';
                n.d(e, { w: () => p });
                var i,
                    r,
                    a,
                    o = n(593),
                    s = n(299),
                    l =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    c = function (t, e, n, i) {
                        return new (n || (n = Promise))(function (r, a) {
                            function o(t) {
                                try {
                                    l(i.next(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function s(t) {
                                try {
                                    l(i.throw(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function l(t) {
                                var e;
                                t.done
                                    ? r(t.value)
                                    : ((e = t.value),
                                      e instanceof n
                                          ? e
                                          : new n(function (t) {
                                                t(e);
                                            })).then(o, s);
                            }
                            l((i = i.apply(t, e || [])).next());
                        });
                    },
                    u = function (t, e) {
                        var n,
                            i,
                            r,
                            a,
                            o = {
                                label: 0,
                                sent: function () {
                                    if (1 & r[0]) throw r[1];
                                    return r[1];
                                },
                                trys: [],
                                ops: [],
                            };
                        return (
                            (a = { next: s(0), throw: s(1), return: s(2) }),
                            'function' == typeof Symbol &&
                                (a[Symbol.iterator] = function () {
                                    return this;
                                }),
                            a
                        );
                        function s(s) {
                            return function (l) {
                                return (function (s) {
                                    if (n)
                                        throw new TypeError(
                                            'Generator is already executing.'
                                        );
                                    for (; a && ((a = 0), s[0] && (o = 0)), o; )
                                        try {
                                            if (
                                                ((n = 1),
                                                i &&
                                                    (r =
                                                        2 & s[0]
                                                            ? i.return
                                                            : s[0]
                                                              ? i.throw ||
                                                                ((r =
                                                                    i.return) &&
                                                                    r.call(i),
                                                                0)
                                                              : i.next) &&
                                                    !(r = r.call(i, s[1])).done)
                                            )
                                                return r;
                                            switch (
                                                ((i = 0),
                                                r && (s = [2 & s[0], r.value]),
                                                s[0])
                                            ) {
                                                case 0:
                                                case 1:
                                                    r = s;
                                                    break;
                                                case 4:
                                                    return (
                                                        o.label++,
                                                        {
                                                            value: s[1],
                                                            done: !1,
                                                        }
                                                    );
                                                case 5:
                                                    o.label++,
                                                        (i = s[1]),
                                                        (s = [0]);
                                                    continue;
                                                case 7:
                                                    (s = o.ops.pop()),
                                                        o.trys.pop();
                                                    continue;
                                                default:
                                                    if (
                                                        !(
                                                            (r =
                                                                (r = o.trys)
                                                                    .length >
                                                                    0 &&
                                                                r[
                                                                    r.length - 1
                                                                ]) ||
                                                            (6 !== s[0] &&
                                                                2 !== s[0])
                                                        )
                                                    ) {
                                                        o = 0;
                                                        continue;
                                                    }
                                                    if (
                                                        3 === s[0] &&
                                                        (!r ||
                                                            (s[1] > r[0] &&
                                                                s[1] < r[3]))
                                                    ) {
                                                        o.label = s[1];
                                                        break;
                                                    }
                                                    if (
                                                        6 === s[0] &&
                                                        o.label < r[1]
                                                    ) {
                                                        (o.label = r[1]),
                                                            (r = s);
                                                        break;
                                                    }
                                                    if (r && o.label < r[2]) {
                                                        (o.label = r[2]),
                                                            o.ops.push(s);
                                                        break;
                                                    }
                                                    r[2] && o.ops.pop(),
                                                        o.trys.pop();
                                                    continue;
                                            }
                                            s = e.call(t, o);
                                        } catch (t) {
                                            (s = [6, t]), (i = 0);
                                        } finally {
                                            n = r = 0;
                                        }
                                    if (5 & s[0]) throw s[1];
                                    return {
                                        value: s[0] ? s[1] : void 0,
                                        done: !0,
                                    };
                                })([s, l]);
                            };
                        }
                    },
                    h =
                        (((r = {})[s.a.ImageData] = 1),
                        (r[s.a.Scene] = 0),
                        (r[s.a.BaseObject] = 0),
                        r),
                    d =
                        (((a = {})[s.a.ImageData] = 1),
                        (a[s.a.Scene] = 0),
                        (a[s.a.BaseObject] = 0),
                        a),
                    p = (function (t) {
                        function e(e, n, i) {
                            var r = t.call(this, h, d, 'filter', e, i) || this;
                            return (r.kernel = n), r;
                        }
                        return (
                            l(e, t),
                            (e.prototype.onDialogSubmitCallback = function (t) {
                                return c(this, void 0, void 0, function () {
                                    return u(this, function (e) {
                                        switch (e.label) {
                                            case 0:
                                                return (
                                                    this.updateKernel(t),
                                                    [
                                                        4,
                                                        this.setFilteredOutput(),
                                                    ]
                                                );
                                            case 1:
                                                return (
                                                    e.sent(),
                                                    this.notifyOutputs(),
                                                    [2]
                                                );
                                        }
                                    });
                                });
                            }),
                            (e.prototype.onUpdateSceneInput = function () {
                                return c(this, void 0, void 0, function () {
                                    return u(this, function (t) {
                                        throw new Error(
                                            'Method not implemented.'
                                        );
                                    });
                                });
                            }),
                            (e.prototype.onUpdateBaseObjectInput = function () {
                                return c(this, void 0, void 0, function () {
                                    return u(this, function (t) {
                                        throw new Error(
                                            'Method not implemented.'
                                        );
                                    });
                                });
                            }),
                            (e.prototype.releaseInChild = function () {
                                delete this.kernel, this.releaseFilterChild();
                            }),
                            (e.prototype.setImageDataProperties = function () {
                                var t, e, n, i, r, a, o, s;
                                this.imageDataOutputs &&
                                    (null === (t = this.imageDataOutputs) ||
                                    void 0 === t
                                        ? void 0
                                        : t[0].data) &&
                                    (null === (e = this.imageDataInputs) ||
                                    void 0 === e
                                        ? void 0
                                        : e[0].data) &&
                                    ((this.imageDataOutputs[0].data.dataType =
                                        null === (n = this.imageDataInputs) ||
                                        void 0 === n
                                            ? void 0
                                            : n[0].data.dataType),
                                    (this.imageDataOutputs[0].data.modality =
                                        null === (i = this.imageDataInputs) ||
                                        void 0 === i
                                            ? void 0
                                            : i[0].data.modality),
                                    (this.imageDataOutputs[0].data.height =
                                        null === (r = this.imageDataInputs) ||
                                        void 0 === r
                                            ? void 0
                                            : r[0].data.height),
                                    (this.imageDataOutputs[0].data.width =
                                        null === (a = this.imageDataInputs) ||
                                        void 0 === a
                                            ? void 0
                                            : a[0].data.width),
                                    (this.imageDataOutputs[0].data.depth =
                                        null === (o = this.imageDataInputs) ||
                                        void 0 === o
                                            ? void 0
                                            : o[0].data.depth),
                                    (this.imageDataOutputs[0].data.voxelSize =
                                        null === (s = this.imageDataInputs) ||
                                        void 0 === s
                                            ? void 0
                                            : s[0].data.voxelSize));
                            }),
                            e
                        );
                    })(o.Y);
            },
            593: (t, e, n) => {
                'use strict';
                var i, r;
                n.d(e, { Y: () => L }),
                    (function (t) {
                        (t.imageData = 'imageDataConnect'),
                            (t.scene = 'sceneConnect'),
                            (t.baseObject = 'baseObjectConnect');
                    })(i || (i = {})),
                    (function (t) {
                        (t.imageData = 'image-data'),
                            (t.scene = 'scene'),
                            (t.baseObject = 'base-object');
                    })(r || (r = {}));
                var a = n(187);
                const o = (function () {
                    function t() {
                        this.event = new a.EventEmitter();
                    }
                    return (
                        (t.getInstance = function () {
                            return (
                                t.INSTANCE || (t.INSTANCE = new t()), t.INSTANCE
                            );
                        }),
                        (t.prototype.emit = function (t, e) {
                            this.event.emit(t, e);
                        }),
                        (t.prototype.listenOnce = function (t, e) {
                            this.event.once(t, e);
                        }),
                        (t.prototype.removeAllListeners = function () {
                            this.event.removeAllListeners();
                        }),
                        t
                    );
                })().getInstance();
                var s,
                    l = (function () {
                        function t(t, e, n) {
                            var i = this;
                            (this.isConnecting = !1),
                                (this.connectService = o),
                                (this.isConnected = !1),
                                (this.lines = []),
                                (this.conInputs = []),
                                (this.mouseMoveListener = function (t) {
                                    i.isConnecting && i.updateEndLine(t);
                                }),
                                (this.data = t),
                                (this.html = document.createElement('span')),
                                this.html.classList.add('input'),
                                (this.connectorSignal = n),
                                this.setCssShape(),
                                (this.conInputs = new Array()),
                                this.onConnectorSignal(),
                                this.stopConnecting(),
                                e.appendChild(this.html);
                            var r = document.getElementById('connectLines');
                            if (!(r instanceof SVGElement))
                                throw Error('no svg element in dom');
                            this.svgElement = r;
                        }
                        return (
                            (t.prototype.addConInput = function (t) {
                                var e;
                                null === (e = this.conInputs) ||
                                    void 0 === e ||
                                    e.push(t);
                            }),
                            (t.prototype.notifyConInputs = function () {
                                var t;
                                null === (t = this.conInputs) ||
                                    void 0 === t ||
                                    t.forEach(function (t) {
                                        t.update();
                                    });
                            }),
                            (t.prototype.destroy = function () {
                                this.removeAllConInputs(),
                                    this.releaseResources(),
                                    this.releaseInChild();
                            }),
                            (t.prototype.updateStartLine = function (t, e) {
                                var n;
                                null === (n = this.lines) ||
                                    void 0 === n ||
                                    n.forEach(function (n) {
                                        var i = n.getAttribute('x1'),
                                            r = n.getAttribute('y1');
                                        if (i && r) {
                                            var a = parseFloat(i) + t,
                                                o = parseFloat(r) + e;
                                            n.setAttribute('x1', a + ''),
                                                n.setAttribute('y1', o + '');
                                        }
                                    });
                            }),
                            (t.prototype.createConnectLine = function () {
                                var t, e;
                                (this.currentLine = document.createElementNS(
                                    'http://www.w3.org/2000/svg',
                                    'line'
                                )),
                                    (this.htmlPosition =
                                        null === (t = this.html) || void 0 === t
                                            ? void 0
                                            : t.getBoundingClientRect()),
                                    void 0 !== this.htmlPosition &&
                                        (this.currentLine.setAttribute(
                                            'x1',
                                            this.htmlPosition.x +
                                                this.htmlPosition.width / 2 +
                                                'px'
                                        ),
                                        this.currentLine.setAttribute(
                                            'y1',
                                            this.htmlPosition.y + 'px'
                                        ),
                                        this.currentLine.setAttribute(
                                            'x2',
                                            this.htmlPosition.x +
                                                this.htmlPosition.width / 2 +
                                                'px'
                                        ),
                                        this.currentLine.setAttribute(
                                            'y2',
                                            this.htmlPosition.y + 'px'
                                        ),
                                        this.currentLine.setAttribute(
                                            'stroke',
                                            '#555'
                                        ),
                                        this.currentLine.setAttribute(
                                            'stroke-width',
                                            '2'
                                        ),
                                        null === (e = this.svgElement) ||
                                            void 0 === e ||
                                            e.appendChild(this.currentLine));
                            }),
                            (t.prototype.listenToConnectorSignal = function () {
                                var t = this;
                                this.connectorSignal &&
                                    this.connectService.listenOnce(
                                        this.connectorSignal,
                                        function (e) {
                                            var n;
                                            if (
                                                !(null === (n = t.conInputs) ||
                                                void 0 === n
                                                    ? void 0
                                                    : n.includes(e))
                                            ) {
                                                if (
                                                    (t.addConInput(e),
                                                    e.setData(t.data),
                                                    e.setCallbackToConOutP(
                                                        function (e) {
                                                            return t.onConInputCallback(
                                                                e
                                                            );
                                                        }
                                                    ),
                                                    !t.currentLine)
                                                )
                                                    throw Error(
                                                        'can not set connect line'
                                                    );
                                                e.setConnectLine(t.currentLine),
                                                    e.onConnected(),
                                                    (t.isConnected = !0),
                                                    (t.isConnecting = !1);
                                            }
                                        }
                                    );
                            }),
                            (t.prototype.updateEndLine = function (t) {
                                var e, n;
                                null === (e = this.currentLine) ||
                                    void 0 === e ||
                                    e.setAttribute('x2', t.x.toString()),
                                    null === (n = this.currentLine) ||
                                        void 0 === n ||
                                        n.setAttribute('y2', t.y.toString());
                            }),
                            (t.prototype.onConnectorSignal = function () {
                                var t,
                                    e,
                                    n = this;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.addEventListener(
                                        'mousemove',
                                        function (t) {
                                            t.stopPropagation();
                                        }
                                    ),
                                    null === (e = this.html) ||
                                        void 0 === e ||
                                        e.addEventListener(
                                            'mousedown',
                                            function (t) {
                                                t.stopPropagation(),
                                                    1 === t.buttons &&
                                                        ((n.isConnecting = !0),
                                                        n.listenToConnectorSignal(),
                                                        n.createConnectLine(),
                                                        n.onMouseMove());
                                            }
                                        );
                            }),
                            (t.prototype.onMouseMove = function () {
                                if (!this.mouseMoveListener)
                                    throw Error('no mouseMoveListener');
                                document.addEventListener(
                                    'mousemove',
                                    this.mouseMoveListener
                                );
                            }),
                            (t.prototype.onConInputCallback = function (t) {
                                this.removeConInput(t);
                            }),
                            (t.prototype.releaseResources = function () {
                                delete this.html,
                                    delete this.isConnecting,
                                    delete this.connectService,
                                    delete this.connectorSignal,
                                    delete this.currentLine,
                                    delete this.htmlPosition,
                                    delete this.isConnected,
                                    delete this.lines,
                                    delete this.conInputs,
                                    delete this.svgElement,
                                    delete this.mouseMoveListener;
                            }),
                            (t.prototype.removeAllConInputs = function () {
                                var t, e;
                                null === (t = this.conInputs) ||
                                    void 0 === t ||
                                    t.forEach(function (t) {
                                        setTimeout(function () {
                                            t.removeConOutP();
                                        }, 100);
                                    }),
                                    null === (e = this.lines) ||
                                        void 0 === e ||
                                        e.forEach(function (t) {
                                            t.remove();
                                        });
                            }),
                            (t.prototype.removeConInput = function (t) {
                                var e,
                                    n = this;
                                null === (e = this.conInputs) ||
                                    void 0 === e ||
                                    e.forEach(function (e, i) {
                                        var r;
                                        e === t &&
                                            (null === (r = n.conInputs) ||
                                                void 0 === r ||
                                                r.splice(i, 1));
                                    });
                            }),
                            (t.prototype.stopConnecting = function () {
                                var t = this;
                                document.addEventListener(
                                    'mouseup',
                                    function (e) {
                                        var n;
                                        if (
                                            (t.isConnecting || t.isConnected) &&
                                            t.currentLine
                                        ) {
                                            if (
                                                ((t.isConnecting = !1),
                                                t.isConnected
                                                    ? null === (n = t.lines) ||
                                                      void 0 === n ||
                                                      n.push(t.currentLine)
                                                    : t.currentLine.remove(),
                                                t.stopListenConnectorSignal(),
                                                !t.mouseMoveListener)
                                            )
                                                throw Error(
                                                    'no mouseMoveListener'
                                                );
                                            document.removeEventListener(
                                                'mousemove',
                                                t.mouseMoveListener
                                            );
                                        }
                                    }
                                );
                            }),
                            (t.prototype.stopListenConnectorSignal =
                                function () {
                                    this.connectService.removeAllListeners(),
                                        (this.isConnected = !1);
                                }),
                            t
                        );
                    })(),
                    c =
                        ((s = function (t, e) {
                            return (
                                (s =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                s(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            s(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    u = (function (t) {
                        function e(e, n) {
                            return t.call(this, e, n, i.imageData) || this;
                        }
                        return (
                            c(e, t),
                            (e.prototype.releaseInChild = function () {}),
                            (e.prototype.setCssShape = function () {
                                var t;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.classList.add(r.imageData);
                            }),
                            e
                        );
                    })(l),
                    h = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })(),
                    d = (function (t) {
                        function e(e, n) {
                            return t.call(this, e, n, i.baseObject) || this;
                        }
                        return (
                            h(e, t),
                            (e.prototype.releaseInChild = function () {}),
                            (e.prototype.setCssShape = function () {
                                var t;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.classList.add(r.baseObject);
                            }),
                            e
                        );
                    })(l),
                    p = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })(),
                    f = (function (t) {
                        function e(e, n) {
                            return t.call(this, e, n, i.scene) || this;
                        }
                        return (
                            p(e, t),
                            (e.prototype.releaseInChild = function () {}),
                            (e.prototype.setCssShape = function () {
                                var t;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.classList.add(r.scene);
                            }),
                            e
                        );
                    })(l),
                    m = function () {
                        (this.data = null),
                            (this.dataType = ''),
                            (this.modality = ''),
                            (this.width = 0),
                            (this.height = 0),
                            (this.depth = 0),
                            (this.voxelSize = { x: 1, y: 1, z: 1 });
                    },
                    g = function () {
                        this.kernels = [];
                    },
                    v =
                        (n(299),
                        function () {
                            (this.data = new m()), (this.shader = new g());
                        }),
                    _ = function () {
                        this.data = void 0;
                    },
                    x = function () {
                        this.data = void 0;
                    },
                    y = (function () {
                        function t(t, e, n) {
                            var i = this;
                            (this.connectService = o),
                                (this.handleClickRemover = function () {
                                    var t;
                                    i.removeConOutP(),
                                        null === (t = i.html) ||
                                            void 0 === t ||
                                            t.classList.remove('connected');
                                }),
                                (this.updateCallbackToModule = t),
                                (this.emittedConnectorSignal = n),
                                (this.html = document.createElement('span')),
                                this.html.classList.add('input'),
                                this.setCssShape(),
                                this.onConnecting(),
                                e.appendChild(this.html);
                        }
                        return (
                            (t.prototype.setCallbackToConOutP = function (t) {
                                this.conOutputCallback = t;
                            }),
                            (t.prototype.destroy = function () {
                                this.removeConOutP(),
                                    this.releaseResources(),
                                    this.releaseInChild();
                            }),
                            (t.prototype.onConnected = function () {
                                var t, e;
                                if (!this.handleClickRemover)
                                    throw Error('no handleClickRemover');
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.classList.add('connected'),
                                    null === (e = this.html) ||
                                        void 0 === e ||
                                        e.addEventListener(
                                            'click',
                                            this.handleClickRemover
                                        );
                            }),
                            (t.prototype.removeConOutP = function () {
                                var t, e;
                                if (
                                    (this.removeData(),
                                    null === (t = this.conOutputCallback) ||
                                        void 0 === t ||
                                        t.call(this, this),
                                    (this.conOutputCallback = void 0),
                                    this.update(),
                                    this.connectLine &&
                                        (this.connectLine.remove(),
                                        (this.connectLine = void 0)),
                                    !this.handleClickRemover)
                                )
                                    throw Error('no handleClickRemover');
                                null === (e = this.html) ||
                                    void 0 === e ||
                                    e.removeEventListener(
                                        'click',
                                        this.handleClickRemover
                                    );
                            }),
                            (t.prototype.setConnectLine = function (t) {
                                this.connectLine = t;
                            }),
                            (t.prototype.update = function () {
                                var t;
                                null === (t = this.updateCallbackToModule) ||
                                    void 0 === t ||
                                    t.call(this);
                            }),
                            (t.prototype.updateEndLine = function (t, e) {
                                if (this.connectLine) {
                                    var n = this.connectLine.getAttribute('x2'),
                                        i = this.connectLine.getAttribute('y2');
                                    if (n && i) {
                                        var r = parseFloat(n) + t,
                                            a = parseFloat(i) + e;
                                        this.connectLine.setAttribute(
                                            'x2',
                                            r + ''
                                        ),
                                            this.connectLine.setAttribute(
                                                'y2',
                                                a + ''
                                            );
                                    }
                                }
                            }),
                            (t.prototype.emitConnectSignal = function () {
                                this.emittedConnectorSignal &&
                                    this.connectService.emit(
                                        this.emittedConnectorSignal,
                                        this
                                    );
                            }),
                            (t.prototype.onConnecting = function () {
                                var t,
                                    e = this;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.addEventListener(
                                        'mouseover',
                                        function (t) {
                                            var n, i;
                                            t.stopPropagation(),
                                                1 === t.buttons &&
                                                    (e.data instanceof v ||
                                                    !(null === (n = e.data) ||
                                                    void 0 === n
                                                        ? void 0
                                                        : n.data)
                                                        ? e.data instanceof v &&
                                                          (null ===
                                                              (i =
                                                                  e.data
                                                                      .data) ||
                                                          void 0 === i
                                                              ? void 0
                                                              : i.data) &&
                                                          e.removeConOutP()
                                                        : e.removeConOutP(),
                                                    e.emitConnectSignal());
                                        }
                                    );
                            }),
                            (t.prototype.releaseResources = function () {
                                delete this.emittedConnectorSignal,
                                    delete this.connectService,
                                    delete this.html,
                                    delete this.data,
                                    delete this.connectLine,
                                    delete this.updateCallbackToModule,
                                    delete this.handleClickRemover;
                            }),
                            t
                        );
                    })(),
                    M = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })(),
                    b = (function (t) {
                        function e(e, n, r) {
                            var a = t.call(this, e, r, i.imageData) || this;
                            return (a.data = n), a;
                        }
                        return (
                            M(e, t),
                            (e.prototype.setData = function (t) {
                                this.data &&
                                    ((this.data.data = t.data),
                                    (this.data.shader = t.shader),
                                    this.update());
                            }),
                            (e.prototype.releaseInChild = function () {}),
                            (e.prototype.removeData = function () {
                                this.data &&
                                    ((this.data.data = new m()),
                                    (this.data.shader = new g()));
                            }),
                            (e.prototype.setCssShape = function () {
                                var t;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.classList.add(r.imageData);
                            }),
                            e
                        );
                    })(y),
                    E = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })(),
                    S = (function (t) {
                        function e(e, n, r) {
                            var a = t.call(this, e, r, i.baseObject) || this;
                            return (a.data = n), a;
                        }
                        return (
                            E(e, t),
                            (e.prototype.setData = function (t) {
                                this.data &&
                                    ((this.data.data = t.data), this.update());
                            }),
                            (e.prototype.releaseInChild = function () {}),
                            (e.prototype.removeData = function () {
                                this.data && (this.data.data = void 0);
                            }),
                            (e.prototype.setCssShape = function () {
                                var t;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.classList.add(r.baseObject);
                            }),
                            e
                        );
                    })(y),
                    T = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })(),
                    w = (function (t) {
                        function e(e, n, r) {
                            var a = t.call(this, e, r, i.scene) || this;
                            return (a.data = n), a;
                        }
                        return (
                            T(e, t),
                            (e.prototype.setData = function (t) {
                                this.data &&
                                    ((this.data.data = t.data), this.update());
                            }),
                            (e.prototype.releaseInChild = function () {}),
                            (e.prototype.removeData = function () {
                                this.data && (this.data.data = void 0);
                            }),
                            (e.prototype.setCssShape = function () {
                                var t;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.classList.add(r.scene);
                            }),
                            e
                        );
                    })(y);
                const A = n.p + 'assets/open_dialog.svg';
                var C = function (t, e, n, i) {
                        return new (n || (n = Promise))(function (r, a) {
                            function o(t) {
                                try {
                                    l(i.next(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function s(t) {
                                try {
                                    l(i.throw(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function l(t) {
                                var e;
                                t.done
                                    ? r(t.value)
                                    : ((e = t.value),
                                      e instanceof n
                                          ? e
                                          : new n(function (t) {
                                                t(e);
                                            })).then(o, s);
                            }
                            l((i = i.apply(t, e || [])).next());
                        });
                    },
                    R = function (t, e) {
                        var n,
                            i,
                            r,
                            a,
                            o = {
                                label: 0,
                                sent: function () {
                                    if (1 & r[0]) throw r[1];
                                    return r[1];
                                },
                                trys: [],
                                ops: [],
                            };
                        return (
                            (a = { next: s(0), throw: s(1), return: s(2) }),
                            'function' == typeof Symbol &&
                                (a[Symbol.iterator] = function () {
                                    return this;
                                }),
                            a
                        );
                        function s(s) {
                            return function (l) {
                                return (function (s) {
                                    if (n)
                                        throw new TypeError(
                                            'Generator is already executing.'
                                        );
                                    for (; a && ((a = 0), s[0] && (o = 0)), o; )
                                        try {
                                            if (
                                                ((n = 1),
                                                i &&
                                                    (r =
                                                        2 & s[0]
                                                            ? i.return
                                                            : s[0]
                                                              ? i.throw ||
                                                                ((r =
                                                                    i.return) &&
                                                                    r.call(i),
                                                                0)
                                                              : i.next) &&
                                                    !(r = r.call(i, s[1])).done)
                                            )
                                                return r;
                                            switch (
                                                ((i = 0),
                                                r && (s = [2 & s[0], r.value]),
                                                s[0])
                                            ) {
                                                case 0:
                                                case 1:
                                                    r = s;
                                                    break;
                                                case 4:
                                                    return (
                                                        o.label++,
                                                        {
                                                            value: s[1],
                                                            done: !1,
                                                        }
                                                    );
                                                case 5:
                                                    o.label++,
                                                        (i = s[1]),
                                                        (s = [0]);
                                                    continue;
                                                case 7:
                                                    (s = o.ops.pop()),
                                                        o.trys.pop();
                                                    continue;
                                                default:
                                                    if (
                                                        !(
                                                            (r =
                                                                (r = o.trys)
                                                                    .length >
                                                                    0 &&
                                                                r[
                                                                    r.length - 1
                                                                ]) ||
                                                            (6 !== s[0] &&
                                                                2 !== s[0])
                                                        )
                                                    ) {
                                                        o = 0;
                                                        continue;
                                                    }
                                                    if (
                                                        3 === s[0] &&
                                                        (!r ||
                                                            (s[1] > r[0] &&
                                                                s[1] < r[3]))
                                                    ) {
                                                        o.label = s[1];
                                                        break;
                                                    }
                                                    if (
                                                        6 === s[0] &&
                                                        o.label < r[1]
                                                    ) {
                                                        (o.label = r[1]),
                                                            (r = s);
                                                        break;
                                                    }
                                                    if (r && o.label < r[2]) {
                                                        (o.label = r[2]),
                                                            o.ops.push(s);
                                                        break;
                                                    }
                                                    r[2] && o.ops.pop(),
                                                        o.trys.pop();
                                                    continue;
                                            }
                                            s = e.call(t, o);
                                        } catch (t) {
                                            (s = [6, t]), (i = 0);
                                        } finally {
                                            n = r = 0;
                                        }
                                    if (5 & s[0]) throw s[1];
                                    return {
                                        value: s[0] ? s[1] : void 0,
                                        done: !0,
                                    };
                                })([s, l]);
                            };
                        }
                    },
                    L = (function () {
                        function t(t, e, n, i, r) {
                            var a, o;
                            void 0 === r && (r = void 0),
                                (this.imageDataOutputs = []),
                                (this.sceneDataOutputs = []),
                                (this.baseObjectsOutputs = []),
                                (this.imageDataInputs = []),
                                (this.sceneDataInputs = []),
                                (this.baseObjectInputs = []),
                                (this.html = document.createElement('div')),
                                (this.inputElements = []),
                                (this.outputImageDataElements = []),
                                (this.outputSceneElements = []),
                                (this.outputBaseObjectElements = []),
                                (this.positionTop = 0),
                                (this.positionLeft = 0),
                                (this.clicked = !1),
                                (this.root = document.querySelector(':root')),
                                (this.htmlInput =
                                    document.createElement('section')),
                                (this.htmlOutput =
                                    document.createElement('section')),
                                (this.removeButton =
                                    document.createElement('button')),
                                (this.dialogIcon =
                                    document.createElement('img')),
                                null === (a = this.html) ||
                                    void 0 === a ||
                                    a.classList.add(n),
                                (this.moduleName = i),
                                (this.dialog = r),
                                this.createInput(t),
                                this.createOutput(e),
                                this.createModuleHtml(),
                                this.setInnerModule(),
                                this.onMoveModule(),
                                this.onDestroy(),
                                this.dialogIcon &&
                                    this.dialog &&
                                    ((this.dialogIcon.src = A),
                                    this.dialogIcon.classList.add('icon'),
                                    null === (o = this.innerModule) ||
                                        void 0 === o ||
                                        o.appendChild(this.dialogIcon),
                                    this.onDblClickOpenDialog());
                        }
                        return (
                            (t.prototype.notifyOutputs = function () {
                                this.notifyImageDataOutputs(),
                                    this.notifySceneOutputs(),
                                    this.notifyBaseObjectOutputs();
                            }),
                            (t.prototype.notifyImageDataOutputs = function () {
                                var t;
                                null === (t = this.outputImageDataElements) ||
                                    void 0 === t ||
                                    t.forEach(function (t) {
                                        t.notifyConInputs();
                                    });
                            }),
                            (t.prototype.notifySceneOutputs = function () {
                                var t;
                                null === (t = this.outputSceneElements) ||
                                    void 0 === t ||
                                    t.forEach(function (t) {
                                        t.notifyConInputs();
                                    });
                            }),
                            (t.prototype.notifyBaseObjectOutputs = function () {
                                var t;
                                null === (t = this.outputBaseObjectElements) ||
                                    void 0 === t ||
                                    t.forEach(function (t) {
                                        t.notifyConInputs();
                                    });
                            }),
                            (t.prototype.createInput = function (t) {
                                var e,
                                    n = this;
                                if (this.htmlInput && this.inputElements) {
                                    if (this.imageDataInputs)
                                        for (var i = 0; i < t[0]; i++) {
                                            var r = new v();
                                            this.imageDataInputs.push(r),
                                                null ===
                                                    (e = this.inputElements) ||
                                                    void 0 === e ||
                                                    e.push(
                                                        new b(
                                                            function () {
                                                                return n.onUpdateInputImageDataCallback();
                                                            },
                                                            r,
                                                            this.htmlInput
                                                        )
                                                    );
                                        }
                                    if (this.sceneDataInputs)
                                        for (i = 0; i < t[1]; i++) {
                                            var a = new _();
                                            this.sceneDataInputs.push(a),
                                                this.inputElements.push(
                                                    new w(
                                                        function () {
                                                            return n.onUpdateInputSceneCallback();
                                                        },
                                                        a,
                                                        this.htmlInput
                                                    )
                                                );
                                        }
                                    if (this.baseObjectInputs)
                                        for (i = 0; i < t[2]; i++) {
                                            var o = new x();
                                            this.baseObjectInputs.push(o),
                                                this.inputElements.push(
                                                    new S(
                                                        function () {
                                                            return n.onUpdateInputBaseObjectCallback();
                                                        },
                                                        o,
                                                        this.htmlInput
                                                    )
                                                );
                                        }
                                }
                            }),
                            (t.prototype.createOutput = function (t) {
                                if (this.htmlOutput) {
                                    if (
                                        this.imageDataOutputs &&
                                        this.outputImageDataElements
                                    )
                                        for (var e = 0; e < t[0]; e++) {
                                            var n = new v();
                                            this.imageDataOutputs.push(n),
                                                this.outputImageDataElements.push(
                                                    new u(n, this.htmlOutput)
                                                );
                                        }
                                    if (
                                        this.sceneDataOutputs &&
                                        this.outputSceneElements
                                    )
                                        for (e = 0; e < t[1]; e++) {
                                            var i = new _();
                                            this.sceneDataOutputs.push(i),
                                                this.outputSceneElements.push(
                                                    new f(i, this.htmlOutput)
                                                );
                                        }
                                    if (
                                        this.baseObjectsOutputs &&
                                        this.outputBaseObjectElements
                                    )
                                        for (e = 0; e < t[2]; e++) {
                                            var r = new x();
                                            this.baseObjectsOutputs.push(r),
                                                this.outputBaseObjectElements.push(
                                                    new d(r, this.htmlOutput)
                                                );
                                        }
                                }
                            }),
                            (t.prototype.createModuleHtml = function () {
                                var t;
                                this.html &&
                                    this.htmlOutput &&
                                    this.htmlInput &&
                                    this.removeButton &&
                                    (this.html.classList.add('module'),
                                    null ===
                                        (t =
                                            document.getElementById(
                                                'modules'
                                            )) ||
                                        void 0 === t ||
                                        t.appendChild(this.html),
                                    (this.innerModule =
                                        document.createElement('section')),
                                    (this.innerModule.innerHTML =
                                        '\n                <p>'.concat(
                                            this.moduleName,
                                            '</p>\n            '
                                        )),
                                    this.htmlInput.classList.add('input'),
                                    this.htmlOutput.classList.add('output'),
                                    this.innerModule.classList.add(
                                        'innerModule'
                                    ),
                                    this.removeButton.classList.add('remove'),
                                    (this.removeButton.innerHTML = '<p>x</p>'),
                                    this.html.appendChild(this.htmlOutput),
                                    this.html.appendChild(this.innerModule),
                                    this.html.appendChild(this.htmlInput),
                                    this.html.appendChild(this.removeButton));
                            }),
                            (t.prototype.destroy = function () {
                                var t;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.remove(),
                                    this.releaseResources(),
                                    this.releaseInChild();
                            }),
                            (t.prototype.onDestroy = function () {
                                var t,
                                    e = this;
                                null === (t = this.removeButton) ||
                                    void 0 === t ||
                                    t.addEventListener('click', function () {
                                        e.destroy();
                                    });
                            }),
                            (t.prototype.onDblClickOpenDialog = function () {
                                var t,
                                    e = this;
                                null === (t = this.dialogIcon) ||
                                    void 0 === t ||
                                    t.addEventListener('dblclick', function () {
                                        var t;
                                        null === (t = e.dialog) ||
                                            void 0 === t ||
                                            t.openDialog();
                                    });
                            }),
                            (t.prototype.onMoveModule = function () {
                                var t,
                                    e,
                                    n = this;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.addEventListener(
                                        'mousedown',
                                        function () {
                                            n.clicked = !0;
                                        }
                                    ),
                                    document.addEventListener(
                                        'mouseup',
                                        function () {
                                            n.clicked = !1;
                                        }
                                    ),
                                    null ===
                                        (e =
                                            document.getElementById(
                                                'workspace'
                                            )) ||
                                        void 0 === e ||
                                        e.addEventListener(
                                            'mousemove',
                                            function (t) {
                                                n.clicked &&
                                                    !t.ctrlKey &&
                                                    n.html &&
                                                    null != n.positionTop &&
                                                    null != n.positionLeft &&
                                                    n.root &&
                                                    n.outputImageDataElements &&
                                                    n.outputSceneElements &&
                                                    n.outputBaseObjectElements &&
                                                    n.inputElements &&
                                                    ((n.positionTop +=
                                                        t.movementY /
                                                        Number(
                                                            getComputedStyle(
                                                                n.root
                                                            ).getPropertyValue(
                                                                '--zoomFactor'
                                                            )
                                                        )),
                                                    (n.positionLeft +=
                                                        t.movementX /
                                                        Number(
                                                            getComputedStyle(
                                                                n.root
                                                            ).getPropertyValue(
                                                                '--zoomFactor'
                                                            )
                                                        )),
                                                    (n.html.style.top =
                                                        n.positionTop + 'px'),
                                                    (n.html.style.left =
                                                        n.positionLeft + 'px'),
                                                    n.outputImageDataElements.forEach(
                                                        function (e) {
                                                            e.updateStartLine(
                                                                t.movementX,
                                                                t.movementY
                                                            );
                                                        }
                                                    ),
                                                    n.outputSceneElements.forEach(
                                                        function (e) {
                                                            e.updateStartLine(
                                                                t.movementX,
                                                                t.movementY
                                                            );
                                                        }
                                                    ),
                                                    n.outputBaseObjectElements.forEach(
                                                        function (e) {
                                                            e.updateStartLine(
                                                                t.movementX,
                                                                t.movementY
                                                            );
                                                        }
                                                    ),
                                                    n.inputElements.forEach(
                                                        function (e) {
                                                            e.updateEndLine(
                                                                t.movementX,
                                                                t.movementY
                                                            );
                                                        }
                                                    ));
                                            }
                                        );
                            }),
                            (t.prototype.onUpdateInputImageDataCallback =
                                function () {
                                    return C(this, void 0, void 0, function () {
                                        return R(this, function (t) {
                                            switch (t.label) {
                                                case 0:
                                                    return [
                                                        4,
                                                        this.onUpdateImageDataInput(),
                                                    ];
                                                case 1:
                                                    return (
                                                        t.sent(),
                                                        this.notifyOutputs(),
                                                        [2]
                                                    );
                                            }
                                        });
                                    });
                                }),
                            (t.prototype.onUpdateInputSceneCallback =
                                function () {
                                    return C(this, void 0, void 0, function () {
                                        return R(this, function (t) {
                                            switch (t.label) {
                                                case 0:
                                                    return [
                                                        4,
                                                        this.onUpdateSceneInput(),
                                                    ];
                                                case 1:
                                                    return (
                                                        t.sent(),
                                                        this.notifyOutputs(),
                                                        [2]
                                                    );
                                            }
                                        });
                                    });
                                }),
                            (t.prototype.onUpdateInputBaseObjectCallback =
                                function () {
                                    return C(this, void 0, void 0, function () {
                                        return R(this, function (t) {
                                            switch (t.label) {
                                                case 0:
                                                    return [
                                                        4,
                                                        this.onUpdateBaseObjectInput(),
                                                    ];
                                                case 1:
                                                    return (
                                                        t.sent(),
                                                        this.notifyOutputs(),
                                                        [2]
                                                    );
                                            }
                                        });
                                    });
                                }),
                            (t.prototype.releaseResources = function () {
                                var t, e, n, i, r, a, o, s;
                                null === (t = this.imageDataOutputs) ||
                                    void 0 === t ||
                                    t.forEach(function (t) {
                                        t.data && (t.data.data = void 0);
                                    }),
                                    null === (e = this.sceneDataOutputs) ||
                                        void 0 === e ||
                                        e.forEach(function (t) {
                                            t.data && (t.data = void 0);
                                        }),
                                    null === (n = this.baseObjectsOutputs) ||
                                        void 0 === n ||
                                        n.forEach(function (t) {
                                            t.data && (t.data = void 0);
                                        }),
                                    null ===
                                        (i = this.outputImageDataElements) ||
                                        void 0 === i ||
                                        i.forEach(function (t) {
                                            t.destroy();
                                        }),
                                    null === (r = this.outputSceneElements) ||
                                        void 0 === r ||
                                        r.forEach(function (t) {
                                            t.destroy();
                                        }),
                                    null ===
                                        (a = this.outputBaseObjectElements) ||
                                        void 0 === a ||
                                        a.forEach(function (t) {
                                            t.destroy();
                                        }),
                                    null === (o = this.inputElements) ||
                                        void 0 === o ||
                                        o.forEach(function (t) {
                                            t.destroy();
                                        }),
                                    delete this.moduleName,
                                    delete this.imageDataInputs,
                                    delete this.sceneDataInputs,
                                    delete this.baseObjectInputs,
                                    delete this.html,
                                    delete this.innerModule,
                                    delete this.inputElements,
                                    delete this.outputImageDataElements,
                                    delete this.outputSceneElements,
                                    delete this.outputBaseObjectElements,
                                    delete this.positionTop,
                                    delete this.positionLeft,
                                    delete this.clicked,
                                    delete this.root,
                                    delete this.htmlInput,
                                    delete this.htmlOutput,
                                    delete this.removeButton,
                                    null === (s = this.dialog) ||
                                        void 0 === s ||
                                        s.destroy(),
                                    delete this.dialog,
                                    delete this.dialogIcon;
                            }),
                            t
                        );
                    })();
            },
            87: (t, e, n) => {
                'use strict';
                n.r(e), n.d(e, { default: () => y });
                var i,
                    r,
                    a,
                    o = n(593),
                    s = n(299),
                    l =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    c = function (t, e, n, i) {
                        return new (n || (n = Promise))(function (r, a) {
                            function o(t) {
                                try {
                                    l(i.next(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function s(t) {
                                try {
                                    l(i.throw(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function l(t) {
                                var e;
                                t.done
                                    ? r(t.value)
                                    : ((e = t.value),
                                      e instanceof n
                                          ? e
                                          : new n(function (t) {
                                                t(e);
                                            })).then(o, s);
                            }
                            l((i = i.apply(t, e || [])).next());
                        });
                    },
                    u = function (t, e) {
                        var n,
                            i,
                            r,
                            a,
                            o = {
                                label: 0,
                                sent: function () {
                                    if (1 & r[0]) throw r[1];
                                    return r[1];
                                },
                                trys: [],
                                ops: [],
                            };
                        return (
                            (a = { next: s(0), throw: s(1), return: s(2) }),
                            'function' == typeof Symbol &&
                                (a[Symbol.iterator] = function () {
                                    return this;
                                }),
                            a
                        );
                        function s(s) {
                            return function (l) {
                                return (function (s) {
                                    if (n)
                                        throw new TypeError(
                                            'Generator is already executing.'
                                        );
                                    for (; a && ((a = 0), s[0] && (o = 0)), o; )
                                        try {
                                            if (
                                                ((n = 1),
                                                i &&
                                                    (r =
                                                        2 & s[0]
                                                            ? i.return
                                                            : s[0]
                                                              ? i.throw ||
                                                                ((r =
                                                                    i.return) &&
                                                                    r.call(i),
                                                                0)
                                                              : i.next) &&
                                                    !(r = r.call(i, s[1])).done)
                                            )
                                                return r;
                                            switch (
                                                ((i = 0),
                                                r && (s = [2 & s[0], r.value]),
                                                s[0])
                                            ) {
                                                case 0:
                                                case 1:
                                                    r = s;
                                                    break;
                                                case 4:
                                                    return (
                                                        o.label++,
                                                        {
                                                            value: s[1],
                                                            done: !1,
                                                        }
                                                    );
                                                case 5:
                                                    o.label++,
                                                        (i = s[1]),
                                                        (s = [0]);
                                                    continue;
                                                case 7:
                                                    (s = o.ops.pop()),
                                                        o.trys.pop();
                                                    continue;
                                                default:
                                                    if (
                                                        !(
                                                            (r =
                                                                (r = o.trys)
                                                                    .length >
                                                                    0 &&
                                                                r[
                                                                    r.length - 1
                                                                ]) ||
                                                            (6 !== s[0] &&
                                                                2 !== s[0])
                                                        )
                                                    ) {
                                                        o = 0;
                                                        continue;
                                                    }
                                                    if (
                                                        3 === s[0] &&
                                                        (!r ||
                                                            (s[1] > r[0] &&
                                                                s[1] < r[3]))
                                                    ) {
                                                        o.label = s[1];
                                                        break;
                                                    }
                                                    if (
                                                        6 === s[0] &&
                                                        o.label < r[1]
                                                    ) {
                                                        (o.label = r[1]),
                                                            (r = s);
                                                        break;
                                                    }
                                                    if (r && o.label < r[2]) {
                                                        (o.label = r[2]),
                                                            o.ops.push(s);
                                                        break;
                                                    }
                                                    r[2] && o.ops.pop(),
                                                        o.trys.pop();
                                                    continue;
                                            }
                                            s = e.call(t, o);
                                        } catch (t) {
                                            (s = [6, t]), (i = 0);
                                        } finally {
                                            n = r = 0;
                                        }
                                    if (5 & s[0]) throw s[1];
                                    return {
                                        value: s[0] ? s[1] : void 0,
                                        done: !0,
                                    };
                                })([s, l]);
                            };
                        }
                    },
                    h =
                        (((r = {})[s.a.ImageData] = 0),
                        (r[s.a.Scene] = 0),
                        (r[s.a.BaseObject] = 0),
                        r),
                    d =
                        (((a = {})[s.a.ImageData] = 1),
                        (a[s.a.Scene] = 0),
                        (a[s.a.BaseObject] = 0),
                        a),
                    p = (function (t) {
                        function e(e) {
                            var n = t.call(this, h, d, 'dataLoader', e) || this;
                            return (n.index = 0), n.setImageData(), n;
                        }
                        return (
                            l(e, t),
                            (e.prototype.onDialogSubmitCallback = function (t) {
                                throw new Error('Method not implemented.');
                            }),
                            (e.prototype.onUpdateImageDataInput = function () {
                                throw Error(
                                    'DataLoader has no input. Therefore, the callback function should never be called.'
                                );
                            }),
                            (e.prototype.onUpdateSceneInput = function () {
                                return c(this, void 0, void 0, function () {
                                    return u(this, function (t) {
                                        throw Error(
                                            'DataLoader has no input. Therefore, the callback function should never be called.'
                                        );
                                    });
                                });
                            }),
                            (e.prototype.onUpdateBaseObjectInput = function () {
                                return c(this, void 0, void 0, function () {
                                    return u(this, function (t) {
                                        throw Error(
                                            'DataLoader has no input. Therefore, the callback function should never be called.'
                                        );
                                    });
                                });
                            }),
                            (e.prototype.setImageData = function () {
                                return c(this, void 0, void 0, function () {
                                    var t;
                                    return u(this, function (e) {
                                        switch (e.label) {
                                            case 0:
                                                return [4, this.loadFile()];
                                            case 1:
                                                return (
                                                    (t = e.sent()),
                                                    [
                                                        4,
                                                        this.setDataProperties(),
                                                    ]
                                                );
                                            case 2:
                                                return (
                                                    e.sent(),
                                                    [4, this.setDataElement(t)]
                                                );
                                            case 3:
                                                return (
                                                    e.sent(),
                                                    this.notifyOutputs(),
                                                    [2]
                                                );
                                        }
                                    });
                                });
                            }),
                            (e.prototype.releaseInChild = function () {
                                delete this.index,
                                    this.releaseInDataLoadChild();
                            }),
                            (e.prototype.setDataElement = function (t) {
                                var e, n, i, r;
                                return c(this, void 0, void 0, function () {
                                    var a;
                                    return u(this, function (o) {
                                        switch (o.label) {
                                            case 0:
                                                return [
                                                    4,
                                                    new Response(
                                                        t
                                                    ).arrayBuffer(),
                                                ];
                                            case 1:
                                                if (
                                                    ((a = o.sent()),
                                                    'Uint8' ===
                                                        (null ===
                                                            (n =
                                                                null ===
                                                                    (e =
                                                                        this
                                                                            .imageDataOutputs) ||
                                                                void 0 === e
                                                                    ? void 0
                                                                    : e[0]
                                                                          .data) ||
                                                        void 0 === n
                                                            ? void 0
                                                            : n.dataType))
                                                )
                                                    this.imageDataOutputs[0].data.data =
                                                        new Uint8Array(a);
                                                else {
                                                    if (
                                                        'Uint16' !==
                                                        (null ===
                                                            (r =
                                                                null ===
                                                                    (i =
                                                                        this
                                                                            .imageDataOutputs) ||
                                                                void 0 === i
                                                                    ? void 0
                                                                    : i[0]
                                                                          .data) ||
                                                        void 0 === r
                                                            ? void 0
                                                            : r.dataType)
                                                    )
                                                        throw new TypeError(
                                                            'Data type not supported'
                                                        );
                                                    this.imageDataOutputs[0].data.data =
                                                        new Uint16Array(a);
                                                }
                                                return [2];
                                        }
                                    });
                                });
                            }),
                            e
                        );
                    })(o.Y);
                const f = n.p + 'assets/cardiac_0.raw',
                    m = n.p + 'assets/mrt.raw',
                    g = n.p + 'assets/foot_256x256x256_uint8.raw';
                var v = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })(),
                    _ = [
                        {
                            name: 'Cardiac CT',
                            path: f,
                            datatype: 'Uint16',
                            modality: 'ct',
                            width: 512,
                            height: 512,
                            depth: 337,
                            voxelSize: { x: 0.390625, y: 0.390625, z: 0.4 },
                        },
                        {
                            name: 'Head MRT',
                            path: m,
                            datatype: 'Uint16',
                            modality: 'mrt',
                            width: 512,
                            height: 512,
                            depth: 144,
                            voxelSize: { x: 0.5, y: 0.5, z: 1 },
                        },
                        {
                            name: 'Foot CT',
                            path: g,
                            datatype: 'Uint8',
                            modality: 'ct',
                            width: 256,
                            height: 256,
                            depth: 256,
                            voxelSize: { x: 1, y: 1, z: 1 },
                        },
                    ],
                    x = (function (t) {
                        function e() {
                            var e = t.call(this, 'Example Data Loader') || this;
                            return (e.index = 0), e;
                        }
                        return (
                            v(e, t),
                            (e.prototype.setInnerModule = function () {
                                var t;
                                (this.select =
                                    document.createElement('select')),
                                    (this.select.innerHTML =
                                        '\n            '.concat(
                                            _.map(function (t) {
                                                return '\n            <option value="'
                                                    .concat(t.name, '">')
                                                    .concat(
                                                        t.name,
                                                        '</option>\n            '
                                                    );
                                            }).join(''),
                                            '\n        '
                                        )),
                                    null === (t = this.innerModule) ||
                                        void 0 === t ||
                                        t.appendChild(this.select),
                                    this.onSelectionChange();
                            }),
                            (e.prototype.loadFile = function () {
                                return (
                                    (t = this),
                                    (e = void 0),
                                    (i = function () {
                                        return (function (t, e) {
                                            var n,
                                                i,
                                                r,
                                                a,
                                                o = {
                                                    label: 0,
                                                    sent: function () {
                                                        if (1 & r[0])
                                                            throw r[1];
                                                        return r[1];
                                                    },
                                                    trys: [],
                                                    ops: [],
                                                };
                                            return (
                                                (a = {
                                                    next: s(0),
                                                    throw: s(1),
                                                    return: s(2),
                                                }),
                                                'function' == typeof Symbol &&
                                                    (a[Symbol.iterator] =
                                                        function () {
                                                            return this;
                                                        }),
                                                a
                                            );
                                            function s(s) {
                                                return function (l) {
                                                    return (function (s) {
                                                        if (n)
                                                            throw new TypeError(
                                                                'Generator is already executing.'
                                                            );
                                                        for (
                                                            ;
                                                            a &&
                                                                ((a = 0),
                                                                s[0] &&
                                                                    (o = 0)),
                                                                o;

                                                        )
                                                            try {
                                                                if (
                                                                    ((n = 1),
                                                                    i &&
                                                                        (r =
                                                                            2 &
                                                                            s[0]
                                                                                ? i.return
                                                                                : s[0]
                                                                                  ? i.throw ||
                                                                                    ((r =
                                                                                        i.return) &&
                                                                                        r.call(
                                                                                            i
                                                                                        ),
                                                                                    0)
                                                                                  : i.next) &&
                                                                        !(r =
                                                                            r.call(
                                                                                i,
                                                                                s[1]
                                                                            ))
                                                                            .done)
                                                                )
                                                                    return r;
                                                                switch (
                                                                    ((i = 0),
                                                                    r &&
                                                                        (s = [
                                                                            2 &
                                                                                s[0],
                                                                            r.value,
                                                                        ]),
                                                                    s[0])
                                                                ) {
                                                                    case 0:
                                                                    case 1:
                                                                        r = s;
                                                                        break;
                                                                    case 4:
                                                                        return (
                                                                            o.label++,
                                                                            {
                                                                                value: s[1],
                                                                                done: !1,
                                                                            }
                                                                        );
                                                                    case 5:
                                                                        o.label++,
                                                                            (i =
                                                                                s[1]),
                                                                            (s =
                                                                                [
                                                                                    0,
                                                                                ]);
                                                                        continue;
                                                                    case 7:
                                                                        (s =
                                                                            o.ops.pop()),
                                                                            o.trys.pop();
                                                                        continue;
                                                                    default:
                                                                        if (
                                                                            !(
                                                                                (r =
                                                                                    (r =
                                                                                        o.trys)
                                                                                        .length >
                                                                                        0 &&
                                                                                    r[
                                                                                        r.length -
                                                                                            1
                                                                                    ]) ||
                                                                                (6 !==
                                                                                    s[0] &&
                                                                                    2 !==
                                                                                        s[0])
                                                                            )
                                                                        ) {
                                                                            o = 0;
                                                                            continue;
                                                                        }
                                                                        if (
                                                                            3 ===
                                                                                s[0] &&
                                                                            (!r ||
                                                                                (s[1] >
                                                                                    r[0] &&
                                                                                    s[1] <
                                                                                        r[3]))
                                                                        ) {
                                                                            o.label =
                                                                                s[1];
                                                                            break;
                                                                        }
                                                                        if (
                                                                            6 ===
                                                                                s[0] &&
                                                                            o.label <
                                                                                r[1]
                                                                        ) {
                                                                            (o.label =
                                                                                r[1]),
                                                                                (r =
                                                                                    s);
                                                                            break;
                                                                        }
                                                                        if (
                                                                            r &&
                                                                            o.label <
                                                                                r[2]
                                                                        ) {
                                                                            (o.label =
                                                                                r[2]),
                                                                                o.ops.push(
                                                                                    s
                                                                                );
                                                                            break;
                                                                        }
                                                                        r[2] &&
                                                                            o.ops.pop(),
                                                                            o.trys.pop();
                                                                        continue;
                                                                }
                                                                s = e.call(
                                                                    t,
                                                                    o
                                                                );
                                                            } catch (t) {
                                                                (s = [6, t]),
                                                                    (i = 0);
                                                            } finally {
                                                                n = r = 0;
                                                            }
                                                        if (5 & s[0])
                                                            throw s[1];
                                                        return {
                                                            value: s[0]
                                                                ? s[1]
                                                                : void 0,
                                                            done: !0,
                                                        };
                                                    })([s, l]);
                                                };
                                            }
                                        })(this, function (t) {
                                            switch (t.label) {
                                                case 0:
                                                    return null == this.index
                                                        ? [3, 2]
                                                        : [
                                                              4,
                                                              fetch(
                                                                  _[this.index]
                                                                      .path
                                                              ).then(
                                                                  function (t) {
                                                                      return t.blob();
                                                                  }
                                                              ),
                                                          ];
                                                case 1:
                                                    return [2, t.sent()];
                                                case 2:
                                                    return [2];
                                            }
                                        });
                                    }),
                                    new ((n = void 0) || (n = Promise))(
                                        function (r, a) {
                                            function o(t) {
                                                try {
                                                    l(i.next(t));
                                                } catch (t) {
                                                    a(t);
                                                }
                                            }
                                            function s(t) {
                                                try {
                                                    l(i.throw(t));
                                                } catch (t) {
                                                    a(t);
                                                }
                                            }
                                            function l(t) {
                                                var e;
                                                t.done
                                                    ? r(t.value)
                                                    : ((e = t.value),
                                                      e instanceof n
                                                          ? e
                                                          : new n(function (t) {
                                                                t(e);
                                                            })).then(o, s);
                                            }
                                            l((i = i.apply(t, e || [])).next());
                                        }
                                    )
                                );
                                var t, e, n, i;
                            }),
                            (e.prototype.setDataProperties = function () {
                                var t;
                                (null === (t = this.imageDataOutputs) ||
                                void 0 === t
                                    ? void 0
                                    : t[0].data) &&
                                    null != this.index &&
                                    ((this.imageDataOutputs[0].data.dataType =
                                        _[this.index].datatype),
                                    (this.imageDataOutputs[0].data.modality =
                                        _[this.index].modality),
                                    (this.imageDataOutputs[0].data.width =
                                        _[this.index].width),
                                    (this.imageDataOutputs[0].data.height =
                                        _[this.index].height),
                                    (this.imageDataOutputs[0].data.depth =
                                        _[this.index].depth),
                                    (this.imageDataOutputs[0].data.voxelSize.x =
                                        _[this.index].voxelSize.x),
                                    (this.imageDataOutputs[0].data.voxelSize.y =
                                        _[this.index].voxelSize.y),
                                    (this.imageDataOutputs[0].data.voxelSize.z =
                                        _[this.index].voxelSize.z));
                            }),
                            (e.prototype.releaseInDataLoadChild = function () {
                                delete this.select;
                            }),
                            (e.prototype.onSelectionChange = function () {
                                var t,
                                    e = this;
                                null === (t = this.select) ||
                                    void 0 === t ||
                                    t.addEventListener('change', function (t) {
                                        var n = t.target.selectedIndex;
                                        (e.index = n), e.setImageData();
                                    });
                            }),
                            e
                        );
                    })(p);
                const y = x;
            },
            281: (t, e, n) => {
                'use strict';
                n.r(e), n.d(e, { default: () => l });
                var i,
                    r = n(294),
                    a = n(362),
                    o =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        });
                function s(t) {
                    for (
                        var e = [],
                            n = 2 * t,
                            i = Math.floor(n / 2),
                            r = 0,
                            a = -n;
                        a <= n;
                        a++
                    )
                        for (var o = -n; o <= n; o++) {
                            var s = a - i,
                                l = o - i,
                                c = Math.exp(-(s * s + l * l) / (2 * t * t));
                            e.push(c), (r += c);
                        }
                    for (a = 0; a < e.length; a++) e[a] /= r;
                    return e;
                }
                const l = (function (t) {
                    function e() {
                        var e =
                            t.call(
                                this,
                                'Gauss Smoothing Data',
                                s(1),
                                new r.Z(function (t) {
                                    return e.onDialogSubmitCallback(t);
                                }, 1)
                            ) || this;
                        return e;
                    }
                    return (
                        o(e, t),
                        (e.prototype.setInnerModule = function () {}),
                        (e.prototype.updateKernel = function (t) {
                            this.kernel = s(t);
                        }),
                        e
                    );
                })(a.X);
            },
            497: (t, e, n) => {
                'use strict';
                n.r(e), n.d(e, { default: () => l });
                var i,
                    r = n(541),
                    a = n(294),
                    o =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        });
                function s(t) {
                    for (
                        var e = [],
                            n = 2 * t,
                            i = Math.floor(n / 2),
                            r = 0,
                            a = -n;
                        a <= n;
                        a++
                    )
                        for (var o = -n; o <= n; o++) {
                            var s = a - i,
                                l = o - i,
                                c = Math.exp(-(s * s + l * l) / (2 * t * t));
                            e.push(c), (r += c);
                        }
                    for (a = 0; a < e.length; a++) e[a] /= r;
                    return e;
                }
                const l = (function (t) {
                    function e() {
                        var e =
                            t.call(
                                this,
                                'Gauss Smoothing Shader',
                                s(1),
                                new a.Z(function (t) {
                                    return e.onDialogSubmitCallback(t);
                                }, 1)
                            ) || this;
                        return e;
                    }
                    return (
                        o(e, t),
                        (e.prototype.setInnerModule = function () {}),
                        (e.prototype.updateKernel = function (t) {
                            this.kernel = s(t);
                        }),
                        e
                    );
                })(r.f);
            },
            750: (t, e, n) => {
                'use strict';
                n.r(e), n.d(e, { default: () => s });
                var i,
                    r = n(477),
                    a = n(720),
                    o =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        });
                const s = (function (t) {
                    function e() {
                        return (
                            t.call(
                                this,
                                'Cube',
                                new r.DvJ(0.5, 0.5, 0.5),
                                new r.nls({
                                    color: 11141120,
                                    transparent: !0,
                                    opacity: 0.5,
                                    depthTest: !0,
                                    depthWrite: !1,
                                    side: r._Li,
                                })
                            ) || this
                        );
                    }
                    return (
                        o(e, t),
                        (e.prototype.setInnerModule = function () {}),
                        e
                    );
                })(a.Q);
            },
            138: (t, e, n) => {
                'use strict';
                n.r(e), n.d(e, { default: () => s });
                var i,
                    r = n(477),
                    a = n(720),
                    o =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        });
                const s = (function (t) {
                    function e() {
                        return (
                            t.call(
                                this,
                                'Plane',
                                new r._12(1, 1),
                                new r.nls({
                                    color: 11141120,
                                    transparent: !0,
                                    opacity: 0.5,
                                    depthTest: !0,
                                    depthWrite: !1,
                                    side: r.ehD,
                                })
                            ) || this
                        );
                    }
                    return (
                        o(e, t),
                        (e.prototype.setInnerModule = function () {}),
                        e
                    );
                })(a.Q);
            },
            75: (t, e, n) => {
                'use strict';
                n.r(e), n.d(e, { default: () => s });
                var i,
                    r = n(362),
                    a =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    o = [0, -1, 0, -1, 4, -1, 0, -1, 0];
                const s = (function (t) {
                    function e() {
                        return t.call(this, 'Laplace Filter Data', o) || this;
                    }
                    return (
                        a(e, t),
                        (e.prototype.setInnerModule = function () {}),
                        (e.prototype.updateKernel = function (t) {
                            throw Error('method not implemented');
                        }),
                        e
                    );
                })(r.X);
            },
            146: (t, e, n) => {
                'use strict';
                n.r(e), n.d(e, { default: () => s });
                var i,
                    r = n(541),
                    a =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    o = [0, -1, 0, -1, 4, -1, 0, -1, 0];
                const s = (function (t) {
                    function e() {
                        return t.call(this, 'Laplace Filter Shader', o) || this;
                    }
                    return (
                        a(e, t),
                        (e.prototype.setInnerModule = function () {}),
                        (e.prototype.updateKernel = function (t) {
                            throw Error('method not implemented');
                        }),
                        e
                    );
                })(r.f);
            },
            698: (t, e, n) => {
                'use strict';
                n.r(e), n.d(e, { default: () => v });
                var i,
                    r = n(477),
                    a = n(271),
                    o =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    s = (function (t) {
                        function e(e, n) {
                            return t.call(this, e, n) || this;
                        }
                        return (
                            o(e, t),
                            (e.prototype.onMouseMove = function (t, e) {
                                this.camera &&
                                    ((this.camera.position.x -=
                                        t / ((1e3 * this.camera.zoom) / 1.9)),
                                    (this.camera.position.y +=
                                        e / ((1e3 * this.camera.zoom) / 1.9)));
                            }),
                            (e.prototype.onWheel = function (t) {
                                this.camera &&
                                    (this.camera.zoom *= t > 0 ? 0.98 : 1.02);
                            }),
                            (e.prototype.releaseInChild = function () {}),
                            e
                        );
                    })(a.j),
                    l = n(846),
                    c = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })(),
                    u = (function (t) {
                        function e(e) {
                            var n = t.call(this, e) || this;
                            if (
                                ((n.camera = new r.iKG()),
                                n.setStartCamera(),
                                !n.canvas)
                            )
                                throw Error('canvas not defined!');
                            return (
                                (n.cameraController = new s(
                                    n.canvas,
                                    n.camera
                                )),
                                n
                            );
                        }
                        return (
                            c(e, t),
                            (e.prototype.getCamera = function () {
                                if (this.camera) return this.camera;
                                throw Error('camera not defined!');
                            }),
                            (e.prototype.setStartCamera = function () {
                                var t;
                                if (!this.canvas)
                                    throw Error('canvas not defined!');
                                this.canvas.height < this.canvas.width
                                    ? ((t =
                                          this.canvas.width /
                                          this.canvas.height),
                                      (this.camera = new r.iKG(
                                          -t / 2,
                                          t / 2,
                                          0.5,
                                          -0.5,
                                          1,
                                          1e3
                                      )))
                                    : ((t =
                                          this.canvas.height /
                                          this.canvas.width),
                                      (this.camera = new r.iKG(
                                          -0.5,
                                          0.5,
                                          t / 2,
                                          -t / 2,
                                          1,
                                          1e3
                                      ))),
                                    this.camera.position.set(0, 0, 1),
                                    this.camera.lookAt(new r.Pa4(0, 0, 0));
                            }),
                            (e.prototype.updateCamera = function () {
                                if (this.camera) {
                                    var t = void 0;
                                    if (!this.canvas)
                                        throw Error('canvas not defined!');
                                    this.canvas.height < this.canvas.width
                                        ? ((t =
                                              this.canvas.clientWidth /
                                              this.canvas.clientHeight),
                                          (this.camera.left = -t / 2),
                                          (this.camera.right = t / 2),
                                          (this.camera.top = 0.5),
                                          (this.camera.bottom = -0.5))
                                        : ((t =
                                              this.canvas.clientHeight /
                                              this.canvas.clientWidth),
                                          (this.camera.left = -0.5),
                                          (this.camera.right = 0.5),
                                          (this.camera.top = t / 2),
                                          (this.camera.bottom = -t / 2)),
                                        this.camera.updateProjectionMatrix();
                                }
                            }),
                            e
                        );
                    })(l.V),
                    h = n(330),
                    d = n(520),
                    p = n(858),
                    f = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })(),
                    m = (function (t) {
                        function e(e, n, i, r) {
                            var a = t.call(this, e, n, i, r) || this;
                            return (a.slice = n.uniforms.slice.value), a;
                        }
                        return (
                            f(e, t),
                            (e.prototype.appendHtmlInfoChild = function () {
                                var t, e;
                                (this.sliceHtml = document.createElement('p')),
                                    null === (t = this.htmlInfo) ||
                                        void 0 === t ||
                                        t.appendChild(this.sliceHtml),
                                    (this.slice =
                                        null === (e = this.material) ||
                                        void 0 === e
                                            ? void 0
                                            : e.uniforms.slice.value),
                                    this.updateHtmlSlice();
                            }),
                            (e.prototype.clearHtmlInfoTextChild = function () {
                                this.sliceHtml &&
                                    (this.sliceHtml.innerText = '');
                            }),
                            (e.prototype.releaseInChild = function () {
                                delete this.slice, delete this.sliceHtml;
                            }),
                            (e.prototype.onWheel = function () {
                                var t,
                                    e = this;
                                null === (t = this.canvas) ||
                                    void 0 === t ||
                                    t.addEventListener('wheel', function (t) {
                                        t.preventDefault();
                                        var n = t.deltaY;
                                        if (null == e.slice)
                                            throw Error(
                                                'Variables that have to be set are not defined!'
                                            );
                                        e.imageDataObject &&
                                            e.imageDataObject.data &&
                                            e.imageDataObject.data.depth &&
                                            !t.ctrlKey &&
                                            (n > 0 && e.slice > 0
                                                ? (e.slice -= 1)
                                                : n < 0 &&
                                                  e.slice <
                                                      e.imageDataObject.data
                                                          .depth -
                                                          1 &&
                                                  (e.slice += 1),
                                            e.material &&
                                                (e.material.uniforms.slice.value =
                                                    e.slice),
                                            e.updateHtmlSlice());
                                    });
                            }),
                            (e.prototype.updateControllerChild = function () {
                                var t, e;
                                (this.slice =
                                    null === (t = this.material) || void 0 === t
                                        ? void 0
                                        : t.uniforms.slice.value),
                                    (null === (e = this.imageDataObject) ||
                                    void 0 === e
                                        ? void 0
                                        : e.data) && this.updateHtmlSlice();
                            }),
                            (e.prototype.updateHtmlSlice = function () {
                                if (!this.sliceHtml)
                                    throw Error(
                                        'Variables that have to be set are not defined!'
                                    );
                                this.imageDataObject &&
                                this.imageDataObject.data
                                    ? (this.sliceHtml.innerText =
                                          'Slice: ' + this.slice)
                                    : (this.sliceHtml.innerText = '');
                            }),
                            e
                        );
                    })(p.V),
                    g = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })();
                const v = (function (t) {
                    function e() {
                        return t.call(this, 'Renderer 2D') || this;
                    }
                    return (
                        g(e, t),
                        (e.prototype.animate = function () {
                            var t, e;
                            if (
                                this.material &&
                                (null === (t = this.imageDataInputs) ||
                                void 0 === t
                                    ? void 0
                                    : t[0].data)
                            ) {
                                var n =
                                        null ===
                                            (e =
                                                this.imageDataInputs[0].data) ||
                                        void 0 === e
                                            ? void 0
                                            : e.depth,
                                    i = this.material.uniforms.slice.value;
                                (i < n || i > 0) &&
                                    (0 == i && (this.sliceStep = 1),
                                    i == n && (this.sliceStep = -1)),
                                    (this.material.uniforms.slice.value +=
                                        this.sliceStep);
                            }
                        }),
                        (e.prototype.createCamera = function () {
                            this.canvas && (this.camera = new u(this.canvas));
                        }),
                        (e.prototype.createController = function () {
                            var t;
                            this.canvas &&
                                this.htmlInfo &&
                                this.material &&
                                (this.controller = new m(
                                    null === (t = this.imageDataInputs) ||
                                    void 0 === t
                                        ? void 0
                                        : t[0],
                                    this.material,
                                    this.canvas,
                                    this.htmlInfo
                                ));
                        }),
                        (e.prototype.createMaterial = function () {
                            var t, e, n, i;
                            if (
                                (null === (t = this.imageDataInputs) ||
                                void 0 === t
                                    ? void 0
                                    : t[0].data) &&
                                this.imageDataInputs[0].data.data instanceof
                                    Uint8Array
                            )
                                (n = 40 / 255), (i = 160 / 255);
                            else {
                                if (
                                    !(
                                        (null === (e = this.imageDataInputs) ||
                                        void 0 === e
                                            ? void 0
                                            : e[0].data) &&
                                        this.imageDataInputs[0].data
                                            .data instanceof Uint16Array
                                    )
                                )
                                    throw Error('data type not supported!');
                                (n = 640), (i = 2560);
                            }
                            this.material = new r.jyz({
                                uniforms: {
                                    volumeTexture: { value: this.texture },
                                    slice: { value: 0 },
                                    windowCenter: { value: n },
                                    windowWidth: { value: i },
                                    kernel: { value: [0] },
                                    kSize: { value: 0 },
                                },
                                defines: { kernelSize: 1 },
                                glslVersion: r.LSk,
                                vertexShader:
                                    'out vec2 vUv;\n\nvoid main() {\n\n\t\tvUv = uv;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        vUv.y = 1.0 - vUv.y; // flip y as origianl data is upside down\n}',
                                fragmentShader:
                                    '// idea to set slice in shader see: https://github.com/mrdoob/three.js/blob/master/examples/webgl2_materials_texture2darray.html#L26-L43, visited 20.04.23\nprecision highp float;\nprecision highp int;\nprecision highp sampler2DArray;\nprecision highp sampler2D;\n\nuniform sampler2DArray volumeTexture;\nuniform int slice;\nuniform float windowCenter;\nuniform float windowWidth;\n\nuniform float kernel[kernelSize];\n// kSize is neede, as kernel[kernelSize].length() with dynamic array is not possible\nuniform float kSize;\n\n\nin vec2 vUv;\n\n/* own variable name for fragment out, as gl_FragColor is deprecated in the used glsl version\n** https://stackoverflow.com/a/51459750, visited 20.01.23 */\nout vec4 outColor;\n\n/* window function\n** Value Of Interest(VOI) lookup table(LUT) */\nfloat voiLut(float value) {\n    float wMinValue = windowCenter - windowWidth / 2.0;\n    float wMaxValue = windowCenter + windowWidth / 2.0;\n    if (value < wMinValue) {\n        return 0.0;\n    } else if (value > wMaxValue) {\n        return 1.0;\n    } else {\n        return (value - wMinValue) / windowWidth;\n    }\n}\n// how to apply kernel see: https://webgl2fundamentals.org/webgl/lessons/webgl-image-processing.html, visited 02.04.23\nfloat applyKernel() {\n    float sum = 0.0;\n    int kernelIndex = 0;\n    // round off because the mean kernel index is needed [-mean, mean]\n    int mean = int(floor(sqrt(kSize)) / 2.0);\n\n    // apply Kernel on current pixel\n    for (int ky = -mean; ky <= mean; ky++) {\n        for (int kx = -mean; kx <= mean; kx++) {\n            // current Kernel Value\n            float kernelValue = kernel[kernelIndex];\n\n            vec2 pixelCoord = vec2(kx, ky) / vec2(textureSize(volumeTexture, 0));\n            float pixelColor = texture(volumeTexture, vec3(vUv + pixelCoord, slice)).r;\n            float pixelMultKernel = pixelColor * kernelValue;\n            sum += pixelMultKernel;\n            kernelIndex +=1;\n        }\n    }\n    /* do not allow values smaller than 0, because in data modifiy filter this is also not possible, because data type Uint is used.\n    ** so both have the same result */\n    if(sum < 0.0) {\n        return 0.0;\n    }\n    return sum;\n}\n\nvoid main() { \n    float color;\n    \n    // image convolution\n    if(kSize > 0.0) {\n        color = applyKernel();\n    } else {\n        color = texture( volumeTexture, vec3( vUv, slice )).r;\n    }\n\n    \n    float colorWindowing = voiLut(color);\n    outColor = vec4(vec3(colorWindowing), 1.0);\n}',
                                transparent: !0,
                                depthWrite: !1,
                                depthTest: !0,
                            });
                        }),
                        (e.prototype.createMesh = function () {
                            this.mesh = new r.Kj0(
                                new r._12(1, 1),
                                this.material
                            );
                        }),
                        (e.prototype.createTexture = function () {
                            var t, e;
                            if (
                                (null === (t = this.imageDataInputs) ||
                                void 0 === t
                                    ? void 0
                                    : t[0].data) &&
                                this.imageDataInputs[0].data.data instanceof
                                    Uint8Array
                            )
                                this.texture = new r.p3g(
                                    this.imageDataInputs[0].data.data,
                                    this.imageDataInputs[0].data.width,
                                    this.imageDataInputs[0].data.height,
                                    this.imageDataInputs[0].data.depth
                                );
                            else if (
                                (null === (e = this.imageDataInputs) ||
                                void 0 === e
                                    ? void 0
                                    : e[0].data) &&
                                this.imageDataInputs[0].data.data instanceof
                                    Uint16Array
                            ) {
                                for (
                                    var n = new Uint16Array(
                                            this.imageDataInputs[0].data.data.length
                                        ),
                                        i = 0;
                                    i <
                                    this.imageDataInputs[0].data.data.length;
                                    i++
                                )
                                    n[i] = (0, h.a)(
                                        this.imageDataInputs[0].data.data[i]
                                    );
                                (this.texture = new r.p3g(
                                    n,
                                    this.imageDataInputs[0].data.width,
                                    this.imageDataInputs[0].data.height,
                                    this.imageDataInputs[0].data.depth
                                )),
                                    (this.texture.type = r.cLu);
                            } else this.texture = new r.p3g();
                            (this.texture.format = r.hEm),
                                (this.texture.minFilter = r.wem),
                                (this.texture.magFilter = r.wem),
                                (this.texture.needsUpdate = !0);
                        }),
                        (e.prototype.releaseInRenderChild = function () {
                            this.sliceStep;
                        }),
                        (e.prototype.setInnerModule = function () {}),
                        e
                    );
                })(d.T);
            },
            811: (t, e, n) => {
                'use strict';
                n.r(e), n.d(e, { default: () => d });
                var i,
                    r = n(520),
                    a = n(330),
                    o = n(477),
                    s = n(858),
                    l =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    c = (function (t) {
                        function e(e, n, i, r) {
                            return t.call(this, e, n, i, r) || this;
                        }
                        return (
                            l(e, t),
                            (e.prototype.appendHtmlInfoChild = function () {}),
                            (e.prototype.clearHtmlInfoTextChild =
                                function () {}),
                            (e.prototype.releaseInChild = function () {}),
                            (e.prototype.onWheel = function () {}),
                            (e.prototype.updateControllerChild =
                                function () {}),
                            e
                        );
                    })(s.V),
                    u = n(254),
                    h = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })();
                const d = (function (t) {
                    function e() {
                        return t.call(this, 'Renderer 3D') || this;
                    }
                    return (
                        h(e, t),
                        (e.prototype.animate = function () {
                            this.mesh && (this.mesh.rotation.y += 0.01);
                        }),
                        (e.prototype.createCamera = function () {
                            this.canvas && (this.camera = new u.c(this.canvas));
                        }),
                        (e.prototype.createController = function () {
                            var t;
                            this.canvas &&
                                this.htmlInfo &&
                                this.material &&
                                ((this.controller = new c(
                                    null === (t = this.imageDataInputs) ||
                                    void 0 === t
                                        ? void 0
                                        : t[0],
                                    this.material,
                                    this.canvas,
                                    this.htmlInfo
                                )),
                                this.htmlInfo.classList.add('threeDRendering'));
                        }),
                        (e.prototype.createMaterial = function () {
                            var t, e, n, i, r, a;
                            if (
                                ((null === (t = this.imageDataInputs) ||
                                void 0 === t
                                    ? void 0
                                    : t[0].data) &&
                                    (this.voxelSizeZ = this.calculateVoxelSizeZ(
                                        this.imageDataInputs[0].data
                                    )),
                                (null === (e = this.imageDataInputs) ||
                                void 0 === e
                                    ? void 0
                                    : e[0].data) &&
                                    this.imageDataInputs[0].data.data instanceof
                                        Uint8Array)
                            )
                                (r = 40 / 255), (a = 160 / 255);
                            else {
                                if (
                                    !(
                                        (null === (n = this.imageDataInputs) ||
                                        void 0 === n
                                            ? void 0
                                            : n[0].data) &&
                                        this.imageDataInputs[0].data
                                            .data instanceof Uint16Array
                                    )
                                )
                                    throw Error('data type not supported!');
                                (r = 640), (a = 2560);
                            }
                            this.material = new o.FIo({
                                glslVersion: o.LSk,
                                uniforms: {
                                    volumeTexture: { value: this.texture },
                                    cameraPos: {
                                        value:
                                            null === (i = this.camera) ||
                                            void 0 === i
                                                ? void 0
                                                : i.getCamera().position,
                                    },
                                    stepSize: { value: 200 },
                                    windowCenter: { value: r },
                                    windowWidth: { value: a },
                                    kernel: { value: [0] },
                                    kSize: { value: 0 },
                                    voxelSizeZ: { value: this.voxelSizeZ },
                                },
                                defines: { kernelSize: 1 },
                                vertexShader:
                                    '// see: https://github.com/mrdoob/three.js/blob/master/examples/webgl2_volume_cloud.html#L117-L136, visited 10.04.23\n\nin vec3 position;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec3 cameraPos;\nout vec3 vOrigin;\nout vec3 vDirection;\nvoid main() {\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;\n    vDirection = position - vOrigin;\n    gl_Position = projectionMatrix * mvPosition;\n}',
                                fragmentShader:
                                    '// fundamental algorithms for fragment shaders see.: https://github.com/mrdoob/three.js/blob/master/examples/webgl2_volume_cloud.html#L138-L245, viseted 10.04.23\n\nprecision highp float;\nprecision highp sampler3D;\nin vec3 vOrigin;\nin vec3 vDirection;\nout vec4 color;\nuniform sampler3D volumeTexture;\nuniform float stepSize;\n\nuniform float windowCenter;\nuniform float windowWidth;\n\nuniform float kernel[kernelSize];\n// kSize is neede, as kernel[kernelSize].length() with dynamic array is not possible\nuniform float kSize;\n\nuniform float voxelSizeZ;\n\n/* window function\n** Value Of Interest(VOI) lookup table(LUT) */\nfloat voiLut(float value) {\n    float wMinValue = windowCenter - windowWidth / 2.0;\n    float wMaxValue = windowCenter + windowWidth / 2.0;\n    if (value < wMinValue) {\n        return 0.0;\n    } else if (value > wMaxValue) {\n        return 1.0;\n    } else {\n        return (value - wMinValue) / windowWidth;\n    }\n}\n\nvec2 hitBox( vec3 orig, vec3 dir ) {\n    vec3 box_min = vec3( - 0.5 );\n    vec3 box_max = vec3( 0.5 );\n    vec3 inv_dir = 1.0 / dir;\n    box_min.z = box_min.z * voxelSizeZ;\n    box_max.z = box_max.z * voxelSizeZ;\n    vec3 tmin_tmp = ( box_min - orig ) * inv_dir;\n    vec3 tmax_tmp = ( box_max - orig ) * inv_dir;\n    vec3 tmin = min( tmin_tmp, tmax_tmp );\n    vec3 tmax = max( tmin_tmp, tmax_tmp );\n    float t0 = max( tmin.x, max( tmin.y, tmin.z ) );\n    float t1 = min( tmax.x, min( tmax.y, tmax.z ) );\n    return vec2( t0, t1 );\n}\n\n// how to apply kernel see: https://webgl2fundamentals.org/webgl/lessons/webgl-image-processing.html, visited 02.04.23\nfloat applyKernel(vec3 coord) {\n    float sum = 0.0;\n    int kernelIndex = 0;\n    // round off because mean is needed [-mean, mean]\n    int mean = int(floor(sqrt(kSize) / 2.0));\n\n    // apply Kernel on current pixel\n    for (int ky = -mean; ky <= mean; ky++) {\n        for (int kx = -mean; kx <= mean; kx++) {\n            // current Kernel Value\n            float kernelValue = kernel[kernelIndex];\n\n            vec2 pixelTexturePosition = vec2(kx, ky) / vec2(textureSize(volumeTexture, 0));\n            float pixelColor = texture(volumeTexture, vec3(coord.xy + pixelTexturePosition, coord.z)).r;\n            float pixelMultKernel = pixelColor * kernelValue;\n            sum += pixelMultKernel;\n            kernelIndex +=1;\n        }\n    }\n    /* do not allow values smaller than 0, because in data modifiy filter this is also not possible, because data type Uint is used.\n    ** so both have the same result */\n    if(sum < 0.0) {\n        return 0.0;\n    }\n    return sum;\n}\n\n// voiLut here, since this value is used for shading. If 16-bit data were used, the shader would otherwise be white\n// applying voiLut also to the calculated shader and then still to the pixel value would slow down the calculation time.\nfloat sample1( vec3 coord ) {\n    if(kSize > 0.0) {\n        return voiLut(applyKernel(coord));\n    }\n    return voiLut(texture( volumeTexture, coord ).r);\n}\nfloat shading( vec3 coord ) {\n    float step = 0.01;\n    return sample1( coord + vec3( - step ) ) - sample1( coord + vec3( step ) );\n}\n\nvoid main(){\n    vec3 rayDir = normalize( vDirection );\n    vec2 bounds = hitBox( vOrigin, rayDir );\n    if ( bounds.x > bounds.y ) discard;\n    bounds.x = max( bounds.x, 0.0 );\n    vec3 coord = vOrigin + bounds.x * rayDir;\n    vec3 inc = 1.0 / abs( rayDir );\n    float delta = min( inc.x, min( inc.y, inc.z ) );\n    delta /= stepSize;\n    vec3 size = vec3( textureSize( volumeTexture, 0 ) );\n    coord += rayDir * ( 1.0 / size );\n    //\n    coord.z /= voxelSizeZ;\n    vec4 ac = vec4( vec3(0.6), 0.0 );\n    for ( float t = bounds.x; t < bounds.y; t += delta ) {\n        float d = sample1( coord + 0.5 );\n        // smoothstep not needed as voiLut is used and it is used before shading. otherwise when using 16 bit data there is no shader\n        float col = shading( coord + 0.5 );\n        ac.rgb += d * col;\n        ac.a += d;\n        // ray marching loop as soon as the accumulated opacity has reached a given threshold\n        if ( ac.a >= 0.95 ) break;\n        coord += rayDir * delta;\n    }\n\n    color = vec4(vec3(ac.r), ac.a);\n    if ( color.a == 0.0 ) {\n        discard;\n    }\n}',
                                side: o._Li,
                                transparent: !0,
                                depthWrite: !1,
                                depthTest: !0,
                            });
                        }),
                        (e.prototype.createMesh = function () {
                            var t = new o.DvJ(1, 1, this.voxelSizeZ);
                            (this.mesh = new o.Kj0(t, this.material)),
                                (this.mesh.rotation.x = Math.PI);
                        }),
                        (e.prototype.createTexture = function () {
                            var t, e;
                            if (
                                (null === (t = this.imageDataInputs) ||
                                void 0 === t
                                    ? void 0
                                    : t[0].data) &&
                                this.imageDataInputs[0].data.data instanceof
                                    Uint8Array
                            )
                                this.texture = new o.JUT(
                                    this.imageDataInputs[0].data.data,
                                    this.imageDataInputs[0].data.width,
                                    this.imageDataInputs[0].data.height,
                                    this.imageDataInputs[0].data.depth
                                );
                            else if (
                                (null === (e = this.imageDataInputs) ||
                                void 0 === e
                                    ? void 0
                                    : e[0].data) &&
                                this.imageDataInputs[0].data.data instanceof
                                    Uint16Array
                            ) {
                                for (
                                    var n = new Uint16Array(
                                            this.imageDataInputs[0].data.data.length
                                        ),
                                        i = 0;
                                    i <
                                    this.imageDataInputs[0].data.data.length;
                                    i++
                                )
                                    n[i] = (0, a.a)(
                                        this.imageDataInputs[0].data.data[i]
                                    );
                                (this.texture = new o.JUT(
                                    n,
                                    this.imageDataInputs[0].data.width,
                                    this.imageDataInputs[0].data.height,
                                    this.imageDataInputs[0].data.depth
                                )),
                                    (this.texture.type = o.cLu);
                            } else
                                this.texture = new o.JUT(
                                    new Float32Array(),
                                    0,
                                    0,
                                    0
                                );
                            (this.texture.format = o.hEm),
                                (this.texture.minFilter = o.wem),
                                (this.texture.magFilter = o.wem),
                                (this.texture.needsUpdate = !0);
                        }),
                        (e.prototype.releaseInRenderChild = function () {
                            delete this.voxelSizeZ;
                        }),
                        (e.prototype.setInnerModule = function () {}),
                        (e.prototype.calculateVoxelSizeZ = function (t) {
                            if (t.voxelSize.x != t.voxelSize.y)
                                throw Error(
                                    'data with different x and y voxel size is currently not supported'
                                );
                            var e = t.voxelSize;
                            return (t.depth * e.z) / (t.width * e.x);
                        }),
                        e
                    );
                })(r.T);
            },
            846: (t, e, n) => {
                'use strict';
                n.d(e, { V: () => r });
                var i = n(187),
                    r = (function () {
                        function t(t) {
                            (this.canvas = t),
                                (this.cameraUpdatedEvent =
                                    new i.EventEmitter()),
                                this.onCanvasResize();
                        }
                        return (
                            (t.prototype.destroy = function () {
                                var t;
                                delete this.camera,
                                    null === (t = this.cameraController) ||
                                        void 0 === t ||
                                        t.destroy(),
                                    delete this.cameraController,
                                    delete this.canvas,
                                    delete this.cameraUpdatedEvent;
                            }),
                            (t.prototype.onCanvasResize = function () {
                                var t = this;
                                if (!this.canvas)
                                    throw Error('canvas not defined!');
                                new ResizeObserver(function () {
                                    var e;
                                    t.updateCamera(),
                                        null === (e = t.cameraUpdatedEvent) ||
                                            void 0 === e ||
                                            e.emit('cameraUpdated');
                                }).observe(this.canvas);
                            }),
                            t
                        );
                    })();
            },
            271: (t, e, n) => {
                'use strict';
                n.d(e, { j: () => r });
                var i = n(477),
                    r = (function () {
                        function t(t, e) {
                            (this.mouseDown = !1),
                                (this.canvas = t),
                                (this.camera = e),
                                (this.startMouseX = 0),
                                (this.startMouseY = 0),
                                this.onMouse();
                        }
                        return (
                            (t.prototype.destroy = function () {
                                this.releaseResources(), this.releaseInChild();
                            }),
                            (t.prototype.onMouse = function () {
                                var t,
                                    e,
                                    n,
                                    r,
                                    a,
                                    o,
                                    s = this;
                                null === (t = this.canvas) ||
                                    void 0 === t ||
                                    t.addEventListener('wheel', function (t) {
                                        if (
                                            s.camera &&
                                            (t.preventDefault(),
                                            (s.camera instanceof i.iKG &&
                                                t.ctrlKey) ||
                                                (s.camera instanceof i.cPb &&
                                                    !t.ctrlKey))
                                        ) {
                                            var e = t.deltaY;
                                            s.onWheel(e),
                                                s.camera.updateProjectionMatrix();
                                        }
                                    }),
                                    null === (e = this.canvas) ||
                                        void 0 === e ||
                                        e.addEventListener(
                                            'mousedown',
                                            function (t) {
                                                ((s.camera instanceof i.iKG &&
                                                    2 === t.button &&
                                                    t.ctrlKey) ||
                                                    (s.camera instanceof
                                                        i.cPb &&
                                                        0 === t.button)) &&
                                                    ((s.mouseDown = !0),
                                                    (s.startMouseX = t.offsetX),
                                                    (s.startMouseY =
                                                        t.offsetY));
                                            }
                                        ),
                                    null === (n = this.canvas) ||
                                        void 0 === n ||
                                        n.addEventListener(
                                            'mousemove',
                                            function (t) {
                                                if (
                                                    s.camera &&
                                                    s.startMouseX &&
                                                    s.startMouseY &&
                                                    ((s.camera instanceof
                                                        i.iKG &&
                                                        s.mouseDown &&
                                                        t.ctrlKey) ||
                                                        (s.mouseDown &&
                                                            s.camera instanceof
                                                                i.cPb))
                                                ) {
                                                    var e =
                                                            t.offsetX -
                                                            s.startMouseX,
                                                        n =
                                                            t.offsetY -
                                                            s.startMouseY;
                                                    (s.startMouseX = t.offsetX),
                                                        (s.startMouseY =
                                                            t.offsetY),
                                                        s.onMouseMove(e, n),
                                                        s.camera.updateProjectionMatrix();
                                                }
                                            }
                                        ),
                                    null === (r = this.canvas) ||
                                        void 0 === r ||
                                        r.addEventListener(
                                            'mouseup',
                                            function () {
                                                s.mouseDown = !1;
                                            }
                                        ),
                                    null === (a = this.canvas) ||
                                        void 0 === a ||
                                        a.addEventListener(
                                            'mouseleave',
                                            function () {
                                                s.mouseDown = !1;
                                            }
                                        ),
                                    null === (o = this.canvas) ||
                                        void 0 === o ||
                                        o.addEventListener(
                                            'mouseenter',
                                            function (t) {
                                                ((s.camera instanceof i.iKG &&
                                                    2 === t.buttons) ||
                                                    (s.camera instanceof
                                                        i.cPb &&
                                                        1 === t.buttons)) &&
                                                    (s.mouseDown = !0);
                                            }
                                        );
                            }),
                            (t.prototype.releaseResources = function () {
                                delete this.camera,
                                    delete this.canvas,
                                    delete this.mouseDown,
                                    delete this.startMouseX,
                                    delete this.startMouseY;
                            }),
                            t
                        );
                    })();
            },
            254: (t, e, n) => {
                'use strict';
                n.d(e, { c: () => f });
                var i = n(477),
                    r = n(846),
                    a = n(271);
                const o = { type: 'change' },
                    s = { type: 'start' },
                    l = { type: 'end' };
                class c extends i.pBf {
                    constructor(t, e) {
                        super(),
                            (this.object = t),
                            (this.domElement = e),
                            (this.domElement.style.touchAction = 'none'),
                            (this.enabled = !0),
                            (this.target = new i.Pa4()),
                            (this.minDistance = 0),
                            (this.maxDistance = 1 / 0),
                            (this.minZoom = 0),
                            (this.maxZoom = 1 / 0),
                            (this.minPolarAngle = 0),
                            (this.maxPolarAngle = Math.PI),
                            (this.minAzimuthAngle = -1 / 0),
                            (this.maxAzimuthAngle = 1 / 0),
                            (this.enableDamping = !1),
                            (this.dampingFactor = 0.05),
                            (this.enableZoom = !0),
                            (this.zoomSpeed = 1),
                            (this.enableRotate = !0),
                            (this.rotateSpeed = 1),
                            (this.enablePan = !0),
                            (this.panSpeed = 1),
                            (this.screenSpacePanning = !0),
                            (this.keyPanSpeed = 7),
                            (this.autoRotate = !1),
                            (this.autoRotateSpeed = 2),
                            (this.keys = {
                                LEFT: 'ArrowLeft',
                                UP: 'ArrowUp',
                                RIGHT: 'ArrowRight',
                                BOTTOM: 'ArrowDown',
                            }),
                            (this.mouseButtons = {
                                LEFT: i.RsA.ROTATE,
                                MIDDLE: i.RsA.DOLLY,
                                RIGHT: i.RsA.PAN,
                            }),
                            (this.touches = {
                                ONE: i.QmN.ROTATE,
                                TWO: i.QmN.DOLLY_PAN,
                            }),
                            (this.target0 = this.target.clone()),
                            (this.position0 = this.object.position.clone()),
                            (this.zoom0 = this.object.zoom),
                            (this._domElementKeyEvents = null),
                            (this.getPolarAngle = function () {
                                return u.phi;
                            }),
                            (this.getAzimuthalAngle = function () {
                                return u.theta;
                            }),
                            (this.getDistance = function () {
                                return this.object.position.distanceTo(
                                    this.target
                                );
                            }),
                            (this.listenToKeyEvents = function (t) {
                                t.addEventListener('keydown', X),
                                    (this._domElementKeyEvents = t);
                            }),
                            (this.stopListenToKeyEvents = function () {
                                this._domElementKeyEvents.removeEventListener(
                                    'keydown',
                                    X
                                ),
                                    (this._domElementKeyEvents = null);
                            }),
                            (this.saveState = function () {
                                n.target0.copy(n.target),
                                    n.position0.copy(n.object.position),
                                    (n.zoom0 = n.object.zoom);
                            }),
                            (this.reset = function () {
                                n.target.copy(n.target0),
                                    n.object.position.copy(n.position0),
                                    (n.object.zoom = n.zoom0),
                                    n.object.updateProjectionMatrix(),
                                    n.dispatchEvent(o),
                                    n.update(),
                                    (a = r.NONE);
                            }),
                            (this.update = (function () {
                                const e = new i.Pa4(),
                                    s = new i._fP().setFromUnitVectors(
                                        t.up,
                                        new i.Pa4(0, 1, 0)
                                    ),
                                    l = s.clone().invert(),
                                    m = new i.Pa4(),
                                    g = new i._fP(),
                                    v = 2 * Math.PI;
                                return function () {
                                    const t = n.object.position;
                                    e.copy(t).sub(n.target),
                                        e.applyQuaternion(s),
                                        u.setFromVector3(e),
                                        n.autoRotate &&
                                            a === r.NONE &&
                                            A(
                                                ((2 * Math.PI) / 60 / 60) *
                                                    n.autoRotateSpeed
                                            ),
                                        n.enableDamping
                                            ? ((u.theta +=
                                                  h.theta * n.dampingFactor),
                                              (u.phi +=
                                                  h.phi * n.dampingFactor))
                                            : ((u.theta += h.theta),
                                              (u.phi += h.phi));
                                    let i = n.minAzimuthAngle,
                                        _ = n.maxAzimuthAngle;
                                    return (
                                        isFinite(i) &&
                                            isFinite(_) &&
                                            (i < -Math.PI
                                                ? (i += v)
                                                : i > Math.PI && (i -= v),
                                            _ < -Math.PI
                                                ? (_ += v)
                                                : _ > Math.PI && (_ -= v),
                                            (u.theta =
                                                i <= _
                                                    ? Math.max(
                                                          i,
                                                          Math.min(_, u.theta)
                                                      )
                                                    : u.theta > (i + _) / 2
                                                      ? Math.max(i, u.theta)
                                                      : Math.min(_, u.theta))),
                                        (u.phi = Math.max(
                                            n.minPolarAngle,
                                            Math.min(n.maxPolarAngle, u.phi)
                                        )),
                                        u.makeSafe(),
                                        (u.radius *= d),
                                        (u.radius = Math.max(
                                            n.minDistance,
                                            Math.min(n.maxDistance, u.radius)
                                        )),
                                        !0 === n.enableDamping
                                            ? n.target.addScaledVector(
                                                  p,
                                                  n.dampingFactor
                                              )
                                            : n.target.add(p),
                                        e.setFromSpherical(u),
                                        e.applyQuaternion(l),
                                        t.copy(n.target).add(e),
                                        n.object.lookAt(n.target),
                                        !0 === n.enableDamping
                                            ? ((h.theta *= 1 - n.dampingFactor),
                                              (h.phi *= 1 - n.dampingFactor),
                                              p.multiplyScalar(
                                                  1 - n.dampingFactor
                                              ))
                                            : (h.set(0, 0, 0), p.set(0, 0, 0)),
                                        (d = 1),
                                        !!(
                                            f ||
                                            m.distanceToSquared(
                                                n.object.position
                                            ) > c ||
                                            8 *
                                                (1 -
                                                    g.dot(
                                                        n.object.quaternion
                                                    )) >
                                                c
                                        ) &&
                                            (n.dispatchEvent(o),
                                            m.copy(n.object.position),
                                            g.copy(n.object.quaternion),
                                            (f = !1),
                                            !0)
                                    );
                                };
                            })()),
                            (this.dispose = function () {
                                n.domElement.removeEventListener(
                                    'contextmenu',
                                    Y
                                ),
                                    n.domElement.removeEventListener(
                                        'pointerdown',
                                        G
                                    ),
                                    n.domElement.removeEventListener(
                                        'pointercancel',
                                        W
                                    ),
                                    n.domElement.removeEventListener(
                                        'wheel',
                                        j
                                    ),
                                    n.domElement.removeEventListener(
                                        'pointermove',
                                        V
                                    ),
                                    n.domElement.removeEventListener(
                                        'pointerup',
                                        W
                                    ),
                                    null !== n._domElementKeyEvents &&
                                        (n._domElementKeyEvents.removeEventListener(
                                            'keydown',
                                            X
                                        ),
                                        (n._domElementKeyEvents = null));
                            });
                        const n = this,
                            r = {
                                NONE: -1,
                                ROTATE: 0,
                                DOLLY: 1,
                                PAN: 2,
                                TOUCH_ROTATE: 3,
                                TOUCH_PAN: 4,
                                TOUCH_DOLLY_PAN: 5,
                                TOUCH_DOLLY_ROTATE: 6,
                            };
                        let a = r.NONE;
                        const c = 1e-6,
                            u = new i.$V(),
                            h = new i.$V();
                        let d = 1;
                        const p = new i.Pa4();
                        let f = !1;
                        const m = new i.FM8(),
                            g = new i.FM8(),
                            v = new i.FM8(),
                            _ = new i.FM8(),
                            x = new i.FM8(),
                            y = new i.FM8(),
                            M = new i.FM8(),
                            b = new i.FM8(),
                            E = new i.FM8(),
                            S = [],
                            T = {};
                        function w() {
                            return Math.pow(0.95, n.zoomSpeed);
                        }
                        function A(t) {
                            h.theta -= t;
                        }
                        function C(t) {
                            h.phi -= t;
                        }
                        const R = (function () {
                                const t = new i.Pa4();
                                return function (e, n) {
                                    t.setFromMatrixColumn(n, 0),
                                        t.multiplyScalar(-e),
                                        p.add(t);
                                };
                            })(),
                            L = (function () {
                                const t = new i.Pa4();
                                return function (e, i) {
                                    !0 === n.screenSpacePanning
                                        ? t.setFromMatrixColumn(i, 1)
                                        : (t.setFromMatrixColumn(i, 0),
                                          t.crossVectors(n.object.up, t)),
                                        t.multiplyScalar(e),
                                        p.add(t);
                                };
                            })(),
                            P = (function () {
                                const t = new i.Pa4();
                                return function (e, i) {
                                    const r = n.domElement;
                                    if (n.object.isPerspectiveCamera) {
                                        const a = n.object.position;
                                        t.copy(a).sub(n.target);
                                        let o = t.length();
                                        (o *= Math.tan(
                                            ((n.object.fov / 2) * Math.PI) / 180
                                        )),
                                            R(
                                                (2 * e * o) / r.clientHeight,
                                                n.object.matrix
                                            ),
                                            L(
                                                (2 * i * o) / r.clientHeight,
                                                n.object.matrix
                                            );
                                    } else
                                        n.object.isOrthographicCamera
                                            ? (R(
                                                  (e *
                                                      (n.object.right -
                                                          n.object.left)) /
                                                      n.object.zoom /
                                                      r.clientWidth,
                                                  n.object.matrix
                                              ),
                                              L(
                                                  (i *
                                                      (n.object.top -
                                                          n.object.bottom)) /
                                                      n.object.zoom /
                                                      r.clientHeight,
                                                  n.object.matrix
                                              ))
                                            : (console.warn(
                                                  'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.'
                                              ),
                                              (n.enablePan = !1));
                                };
                            })();
                        function D(t) {
                            n.object.isPerspectiveCamera
                                ? (d /= t)
                                : n.object.isOrthographicCamera
                                  ? ((n.object.zoom = Math.max(
                                        n.minZoom,
                                        Math.min(n.maxZoom, n.object.zoom * t)
                                    )),
                                    n.object.updateProjectionMatrix(),
                                    (f = !0))
                                  : (console.warn(
                                        'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
                                    ),
                                    (n.enableZoom = !1));
                        }
                        function I(t) {
                            n.object.isPerspectiveCamera
                                ? (d *= t)
                                : n.object.isOrthographicCamera
                                  ? ((n.object.zoom = Math.max(
                                        n.minZoom,
                                        Math.min(n.maxZoom, n.object.zoom / t)
                                    )),
                                    n.object.updateProjectionMatrix(),
                                    (f = !0))
                                  : (console.warn(
                                        'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
                                    ),
                                    (n.enableZoom = !1));
                        }
                        function U(t) {
                            m.set(t.clientX, t.clientY);
                        }
                        function O(t) {
                            _.set(t.clientX, t.clientY);
                        }
                        function N() {
                            if (1 === S.length) m.set(S[0].pageX, S[0].pageY);
                            else {
                                const t = 0.5 * (S[0].pageX + S[1].pageX),
                                    e = 0.5 * (S[0].pageY + S[1].pageY);
                                m.set(t, e);
                            }
                        }
                        function F() {
                            if (1 === S.length) _.set(S[0].pageX, S[0].pageY);
                            else {
                                const t = 0.5 * (S[0].pageX + S[1].pageX),
                                    e = 0.5 * (S[0].pageY + S[1].pageY);
                                _.set(t, e);
                            }
                        }
                        function z() {
                            const t = S[0].pageX - S[1].pageX,
                                e = S[0].pageY - S[1].pageY,
                                n = Math.sqrt(t * t + e * e);
                            M.set(0, n);
                        }
                        function B(t) {
                            if (1 == S.length) g.set(t.pageX, t.pageY);
                            else {
                                const e = K(t),
                                    n = 0.5 * (t.pageX + e.x),
                                    i = 0.5 * (t.pageY + e.y);
                                g.set(n, i);
                            }
                            v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
                            const e = n.domElement;
                            A((2 * Math.PI * v.x) / e.clientHeight),
                                C((2 * Math.PI * v.y) / e.clientHeight),
                                m.copy(g);
                        }
                        function k(t) {
                            if (1 === S.length) x.set(t.pageX, t.pageY);
                            else {
                                const e = K(t),
                                    n = 0.5 * (t.pageX + e.x),
                                    i = 0.5 * (t.pageY + e.y);
                                x.set(n, i);
                            }
                            y.subVectors(x, _).multiplyScalar(n.panSpeed),
                                P(y.x, y.y),
                                _.copy(x);
                        }
                        function H(t) {
                            const e = K(t),
                                i = t.pageX - e.x,
                                r = t.pageY - e.y,
                                a = Math.sqrt(i * i + r * r);
                            b.set(0, a),
                                E.set(0, Math.pow(b.y / M.y, n.zoomSpeed)),
                                D(E.y),
                                M.copy(b);
                        }
                        function G(t) {
                            !1 !== n.enabled &&
                                (0 === S.length &&
                                    (n.domElement.setPointerCapture(
                                        t.pointerId
                                    ),
                                    n.domElement.addEventListener(
                                        'pointermove',
                                        V
                                    ),
                                    n.domElement.addEventListener(
                                        'pointerup',
                                        W
                                    )),
                                (function (t) {
                                    S.push(t);
                                })(t),
                                'touch' === t.pointerType
                                    ? (function (t) {
                                          switch ((q(t), S.length)) {
                                              case 1:
                                                  switch (n.touches.ONE) {
                                                      case i.QmN.ROTATE:
                                                          if (
                                                              !1 ===
                                                              n.enableRotate
                                                          )
                                                              return;
                                                          N(),
                                                              (a =
                                                                  r.TOUCH_ROTATE);
                                                          break;
                                                      case i.QmN.PAN:
                                                          if (
                                                              !1 === n.enablePan
                                                          )
                                                              return;
                                                          F(),
                                                              (a = r.TOUCH_PAN);
                                                          break;
                                                      default:
                                                          a = r.NONE;
                                                  }
                                                  break;
                                              case 2:
                                                  switch (n.touches.TWO) {
                                                      case i.QmN.DOLLY_PAN:
                                                          if (
                                                              !1 ===
                                                                  n.enableZoom &&
                                                              !1 === n.enablePan
                                                          )
                                                              return;
                                                          n.enableZoom && z(),
                                                              n.enablePan &&
                                                                  F(),
                                                              (a =
                                                                  r.TOUCH_DOLLY_PAN);
                                                          break;
                                                      case i.QmN.DOLLY_ROTATE:
                                                          if (
                                                              !1 ===
                                                                  n.enableZoom &&
                                                              !1 ===
                                                                  n.enableRotate
                                                          )
                                                              return;
                                                          n.enableZoom && z(),
                                                              n.enableRotate &&
                                                                  N(),
                                                              (a =
                                                                  r.TOUCH_DOLLY_ROTATE);
                                                          break;
                                                      default:
                                                          a = r.NONE;
                                                  }
                                                  break;
                                              default:
                                                  a = r.NONE;
                                          }
                                          a !== r.NONE && n.dispatchEvent(s);
                                      })(t)
                                    : (function (t) {
                                          let e;
                                          switch (t.button) {
                                              case 0:
                                                  e = n.mouseButtons.LEFT;
                                                  break;
                                              case 1:
                                                  e = n.mouseButtons.MIDDLE;
                                                  break;
                                              case 2:
                                                  e = n.mouseButtons.RIGHT;
                                                  break;
                                              default:
                                                  e = -1;
                                          }
                                          switch (e) {
                                              case i.RsA.DOLLY:
                                                  if (!1 === n.enableZoom)
                                                      return;
                                                  !(function (t) {
                                                      M.set(
                                                          t.clientX,
                                                          t.clientY
                                                      );
                                                  })(t),
                                                      (a = r.DOLLY);
                                                  break;
                                              case i.RsA.ROTATE:
                                                  if (
                                                      t.ctrlKey ||
                                                      t.metaKey ||
                                                      t.shiftKey
                                                  ) {
                                                      if (!1 === n.enablePan)
                                                          return;
                                                      O(t), (a = r.PAN);
                                                  } else {
                                                      if (!1 === n.enableRotate)
                                                          return;
                                                      U(t), (a = r.ROTATE);
                                                  }
                                                  break;
                                              case i.RsA.PAN:
                                                  if (
                                                      t.ctrlKey ||
                                                      t.metaKey ||
                                                      t.shiftKey
                                                  ) {
                                                      if (!1 === n.enableRotate)
                                                          return;
                                                      U(t), (a = r.ROTATE);
                                                  } else {
                                                      if (!1 === n.enablePan)
                                                          return;
                                                      O(t), (a = r.PAN);
                                                  }
                                                  break;
                                              default:
                                                  a = r.NONE;
                                          }
                                          a !== r.NONE && n.dispatchEvent(s);
                                      })(t));
                        }
                        function V(t) {
                            !1 !== n.enabled &&
                                ('touch' === t.pointerType
                                    ? (function (t) {
                                          switch ((q(t), a)) {
                                              case r.TOUCH_ROTATE:
                                                  if (!1 === n.enableRotate)
                                                      return;
                                                  B(t), n.update();
                                                  break;
                                              case r.TOUCH_PAN:
                                                  if (!1 === n.enablePan)
                                                      return;
                                                  k(t), n.update();
                                                  break;
                                              case r.TOUCH_DOLLY_PAN:
                                                  if (
                                                      !1 === n.enableZoom &&
                                                      !1 === n.enablePan
                                                  )
                                                      return;
                                                  !(function (t) {
                                                      n.enableZoom && H(t),
                                                          n.enablePan && k(t);
                                                  })(t),
                                                      n.update();
                                                  break;
                                              case r.TOUCH_DOLLY_ROTATE:
                                                  if (
                                                      !1 === n.enableZoom &&
                                                      !1 === n.enableRotate
                                                  )
                                                      return;
                                                  !(function (t) {
                                                      n.enableZoom && H(t),
                                                          n.enableRotate &&
                                                              B(t);
                                                  })(t),
                                                      n.update();
                                                  break;
                                              default:
                                                  a = r.NONE;
                                          }
                                      })(t)
                                    : (function (t) {
                                          switch (a) {
                                              case r.ROTATE:
                                                  if (!1 === n.enableRotate)
                                                      return;
                                                  !(function (t) {
                                                      g.set(
                                                          t.clientX,
                                                          t.clientY
                                                      ),
                                                          v
                                                              .subVectors(g, m)
                                                              .multiplyScalar(
                                                                  n.rotateSpeed
                                                              );
                                                      const e = n.domElement;
                                                      A(
                                                          (2 * Math.PI * v.x) /
                                                              e.clientHeight
                                                      ),
                                                          C(
                                                              (2 *
                                                                  Math.PI *
                                                                  v.y) /
                                                                  e.clientHeight
                                                          ),
                                                          m.copy(g),
                                                          n.update();
                                                  })(t);
                                                  break;
                                              case r.DOLLY:
                                                  if (!1 === n.enableZoom)
                                                      return;
                                                  !(function (t) {
                                                      b.set(
                                                          t.clientX,
                                                          t.clientY
                                                      ),
                                                          E.subVectors(b, M),
                                                          E.y > 0
                                                              ? D(w())
                                                              : E.y < 0 &&
                                                                I(w()),
                                                          M.copy(b),
                                                          n.update();
                                                  })(t);
                                                  break;
                                              case r.PAN:
                                                  if (!1 === n.enablePan)
                                                      return;
                                                  !(function (t) {
                                                      x.set(
                                                          t.clientX,
                                                          t.clientY
                                                      ),
                                                          y
                                                              .subVectors(x, _)
                                                              .multiplyScalar(
                                                                  n.panSpeed
                                                              ),
                                                          P(y.x, y.y),
                                                          _.copy(x),
                                                          n.update();
                                                  })(t);
                                          }
                                      })(t));
                        }
                        function W(t) {
                            !(function (t) {
                                delete T[t.pointerId];
                                for (let e = 0; e < S.length; e++)
                                    if (S[e].pointerId == t.pointerId)
                                        return void S.splice(e, 1);
                            })(t),
                                0 === S.length &&
                                    (n.domElement.releasePointerCapture(
                                        t.pointerId
                                    ),
                                    n.domElement.removeEventListener(
                                        'pointermove',
                                        V
                                    ),
                                    n.domElement.removeEventListener(
                                        'pointerup',
                                        W
                                    )),
                                n.dispatchEvent(l),
                                (a = r.NONE);
                        }
                        function j(t) {
                            !1 !== n.enabled &&
                                !1 !== n.enableZoom &&
                                a === r.NONE &&
                                (t.preventDefault(),
                                n.dispatchEvent(s),
                                (function (t) {
                                    t.deltaY < 0
                                        ? I(w())
                                        : t.deltaY > 0 && D(w()),
                                        n.update();
                                })(t),
                                n.dispatchEvent(l));
                        }
                        function X(t) {
                            !1 !== n.enabled &&
                                !1 !== n.enablePan &&
                                (function (t) {
                                    let e = !1;
                                    switch (t.code) {
                                        case n.keys.UP:
                                            t.ctrlKey || t.metaKey || t.shiftKey
                                                ? C(
                                                      (2 *
                                                          Math.PI *
                                                          n.rotateSpeed) /
                                                          n.domElement
                                                              .clientHeight
                                                  )
                                                : P(0, n.keyPanSpeed),
                                                (e = !0);
                                            break;
                                        case n.keys.BOTTOM:
                                            t.ctrlKey || t.metaKey || t.shiftKey
                                                ? C(
                                                      (-2 *
                                                          Math.PI *
                                                          n.rotateSpeed) /
                                                          n.domElement
                                                              .clientHeight
                                                  )
                                                : P(0, -n.keyPanSpeed),
                                                (e = !0);
                                            break;
                                        case n.keys.LEFT:
                                            t.ctrlKey || t.metaKey || t.shiftKey
                                                ? A(
                                                      (2 *
                                                          Math.PI *
                                                          n.rotateSpeed) /
                                                          n.domElement
                                                              .clientHeight
                                                  )
                                                : P(n.keyPanSpeed, 0),
                                                (e = !0);
                                            break;
                                        case n.keys.RIGHT:
                                            t.ctrlKey || t.metaKey || t.shiftKey
                                                ? A(
                                                      (-2 *
                                                          Math.PI *
                                                          n.rotateSpeed) /
                                                          n.domElement
                                                              .clientHeight
                                                  )
                                                : P(-n.keyPanSpeed, 0),
                                                (e = !0);
                                    }
                                    e && (t.preventDefault(), n.update());
                                })(t);
                        }
                        function Y(t) {
                            !1 !== n.enabled && t.preventDefault();
                        }
                        function q(t) {
                            let e = T[t.pointerId];
                            void 0 === e &&
                                ((e = new i.FM8()), (T[t.pointerId] = e)),
                                e.set(t.pageX, t.pageY);
                        }
                        function K(t) {
                            const e =
                                t.pointerId === S[0].pointerId ? S[1] : S[0];
                            return T[e.pointerId];
                        }
                        n.domElement.addEventListener('contextmenu', Y),
                            n.domElement.addEventListener('pointerdown', G),
                            n.domElement.addEventListener('pointercancel', W),
                            n.domElement.addEventListener('wheel', j, {
                                passive: !1,
                            }),
                            this.update();
                    }
                }
                var u,
                    h =
                        ((u = function (t, e) {
                            return (
                                (u =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                u(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            u(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    d = (function (t) {
                        function e(e, n) {
                            var r = t.call(this, e, n) || this;
                            return (
                                r.camera &&
                                    ((r.controller = new c(r.camera, r.canvas)),
                                    r.controller &&
                                        ((r.controller.enableZoom = !1),
                                        (r.controller.mouseButtons = {
                                            LEFT: i.RsA.ROTATE,
                                        }))),
                                r
                            );
                        }
                        return (
                            h(e, t),
                            (e.prototype.onMouseMove = function (t, e) {}),
                            (e.prototype.onWheel = function (t) {
                                this.camera &&
                                    (this.camera.zoom *= t > 0 ? 0.98 : 1.02);
                            }),
                            (e.prototype.releaseInChild = function () {
                                delete this.controller;
                            }),
                            e
                        );
                    })(a.j),
                    p = (function () {
                        var t = function (e, n) {
                            return (
                                (t =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                t(e, n)
                            );
                        };
                        return function (e, n) {
                            if ('function' != typeof n && null !== n)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(n) +
                                        ' is not a constructor or null'
                                );
                            function i() {
                                this.constructor = e;
                            }
                            t(e, n),
                                (e.prototype =
                                    null === n
                                        ? Object.create(n)
                                        : ((i.prototype = n.prototype),
                                          new i()));
                        };
                    })(),
                    f = (function (t) {
                        function e(e) {
                            var n = t.call(this, e) || this;
                            if (
                                ((n.camera = new i.cPb()),
                                n.setStartCamera(),
                                !n.canvas)
                            )
                                throw Error('canvas not defined!');
                            return (
                                (n.cameraController = new d(
                                    n.canvas,
                                    n.camera
                                )),
                                n
                            );
                        }
                        return (
                            p(e, t),
                            (e.prototype.getCamera = function () {
                                if (this.camera) return this.camera;
                                throw Error('camera not defined!');
                            }),
                            (e.prototype.setStartCamera = function () {
                                if (!this.canvas)
                                    throw Error('canvas not defined!');
                                var t = this.canvas.width / this.canvas.height;
                                (this.camera = new i.cPb(60, t, 0.1, 100)),
                                    (this.camera.aspect = t),
                                    this.camera.position.set(0, 0, 1.5),
                                    this.camera.updateProjectionMatrix();
                            }),
                            (e.prototype.updateCamera = function () {
                                if (this.camera) {
                                    if (!this.canvas)
                                        throw Error('canvas not defined!');
                                    var t;
                                    (t =
                                        this.canvas.clientWidth /
                                        this.canvas.clientHeight),
                                        (this.camera.aspect = t),
                                        this.camera.updateProjectionMatrix();
                                }
                            }),
                            e
                        );
                    })(r.V);
            },
            858: (t, e, n) => {
                'use strict';
                n.d(e, { V: () => i });
                var i = (function () {
                    function t(t, e, n, i) {
                        var r, a;
                        (this.canvas = n),
                            (this.htmlInfo = i),
                            (this.imageDataObject = t),
                            (this.material = e),
                            (this.center = e.uniforms.windowCenter.value),
                            (this.width = e.uniforms.windowWidth.value),
                            (r = this.getMinMaxData()),
                            (this.minCenter = r[0]),
                            (this.maxCenter = r[1]),
                            (a = this.getMinMaxData()),
                            (this.minWidth = a[0]),
                            (this.maxWidth = a[1]),
                            (this.multiplier = 4),
                            this.setMaterialMaxValue(),
                            this.updateMultiplier(),
                            this.imageDataObject &&
                                (this.appendHtmlInfo(),
                                this.onMouseMove(),
                                this.onWheel());
                    }
                    return (
                        (t.prototype.updateController = function (t) {
                            var e, n, i;
                            (this.material = t),
                                (this.center =
                                    this.material.uniforms.windowCenter.value),
                                (this.width =
                                    this.material.uniforms.windowWidth.value),
                                (e = this.getMinMaxData()),
                                (this.minCenter = e[0]),
                                (this.maxCenter = e[1]),
                                (n = this.getMinMaxData()),
                                (this.minWidth = n[0]),
                                (this.maxWidth = n[1]),
                                this.setMaterialMaxValue(),
                                (null === (i = this.imageDataObject) ||
                                void 0 === i
                                    ? void 0
                                    : i.data) && this.updateHtmlLut(),
                                this.updateMultiplier(),
                                this.updateControllerChild();
                        }),
                        (t.prototype.clearHtmlInfoText = function () {
                            this.lutHtml && (this.lutHtml.innerText = ''),
                                this.clearHtmlInfoTextChild();
                        }),
                        (t.prototype.destroy = function () {
                            this.releaseResources(), this.releaseInChild();
                        }),
                        (t.prototype.appendHtmlInfo = function () {
                            var t;
                            (this.lutHtml = document.createElement('p')),
                                null === (t = this.htmlInfo) ||
                                    void 0 === t ||
                                    t.appendChild(this.lutHtml),
                                this.updateHtmlLut(),
                                this.appendHtmlInfoChild();
                        }),
                        (t.prototype.releaseResources = function () {
                            delete this.canvas,
                                delete this.htmlInfo,
                                delete this.lutHtml,
                                delete this.minCenter,
                                delete this.maxCenter,
                                delete this.minWidth,
                                delete this.maxWidth,
                                delete this.multiplier,
                                delete this.center,
                                delete this.width,
                                delete this.imageDataObject,
                                delete this.material;
                        }),
                        (t.prototype.getMinMaxData = function () {
                            var t,
                                e,
                                n = 0,
                                i = 0;
                            if (
                                this.imageDataObject &&
                                this.imageDataObject.data &&
                                this.imageDataObject.data.data
                            ) {
                                (n = this.imageDataObject.data.data[0]),
                                    (i = this.imageDataObject.data.data[0]);
                                for (
                                    var r = 1;
                                    r < this.imageDataObject.data.data.length;
                                    r++
                                )
                                    this.imageDataObject.data.data[r] < n &&
                                        (n = this.imageDataObject.data.data[r]),
                                        this.imageDataObject.data.data[r] > i &&
                                            (i =
                                                this.imageDataObject.data.data[
                                                    r
                                                ]);
                            }
                            return (null ===
                                (e =
                                    null === (t = this.imageDataObject) ||
                                    void 0 === t
                                        ? void 0
                                        : t.data) || void 0 === e
                                ? void 0
                                : e.data) instanceof Uint8Array
                                ? [n / 255, i / 255]
                                : [n, i];
                        }),
                        (t.prototype.onMouseMove = function () {
                            var t,
                                e = this;
                            null === (t = this.canvas) ||
                                void 0 === t ||
                                t.addEventListener('mousemove', function (t) {
                                    var n;
                                    if (2 & t.buttons && !t.ctrlKey) {
                                        var i = 0,
                                            r = 0;
                                        if (
                                            (e.multiplier &&
                                                ((i =
                                                    t.movementX * e.multiplier),
                                                (r =
                                                    t.movementY *
                                                    e.multiplier)),
                                            !e.material ||
                                                null == e.minCenter ||
                                                null == e.minWidth ||
                                                null == e.maxCenter ||
                                                null == e.maxWidth)
                                        )
                                            throw Error(
                                                'Variables that have to be set are not defined!'
                                            );
                                        (e.center = Math.min(
                                            Math.max(
                                                (null === (n = e.material) ||
                                                void 0 === n
                                                    ? void 0
                                                    : n.uniforms.windowCenter
                                                          .value) + r,
                                                e.minCenter
                                            ),
                                            e.maxCenter
                                        )),
                                            (e.material.uniforms.windowCenter.value =
                                                e.center),
                                            (e.width = Math.min(
                                                Math.max(
                                                    e.material.uniforms
                                                        .windowWidth.value + i,
                                                    e.minWidth
                                                ),
                                                e.maxWidth
                                            )),
                                            (e.material.uniforms.windowWidth.value =
                                                e.width),
                                            e.updateHtmlLut();
                                    }
                                });
                        }),
                        (t.prototype.updateHtmlLut = function () {
                            if (!this.lutHtml || null == this.center)
                                throw Error(
                                    'Variables that have to be set are not defined!'
                                );
                            this.imageDataObject &&
                            this.imageDataObject.data &&
                            null != this.width
                                ? 'ct' == this.imageDataObject.data.modality &&
                                  this.imageDataObject.data.data instanceof
                                      Uint16Array
                                    ? (this.lutHtml.innerText =
                                          'LUT C/W: ' +
                                          (this.center - 1024) +
                                          ' / ' +
                                          this.width)
                                    : this.imageDataObject.data.data instanceof
                                        Uint8Array
                                      ? (this.lutHtml.innerText =
                                            'LUT C/W: ' +
                                            Math.round(255 * this.center) +
                                            ' / ' +
                                            Math.round(255 * this.width))
                                      : (this.lutHtml.innerText =
                                            'LUT C/W: ' +
                                            this.center +
                                            ' / ' +
                                            this.width)
                                : (this.lutHtml.innerText = '');
                        }),
                        (t.prototype.updateMultiplier = function () {
                            var t;
                            this.imageDataObject &&
                            (null === (t = this.imageDataObject.data) ||
                            void 0 === t
                                ? void 0
                                : t.data) instanceof Uint8Array
                                ? (this.multiplier = 1 / 255)
                                : (this.multiplier = 4);
                        }),
                        (t.prototype.setMaterialMaxValue = function () {
                            this.center &&
                                this.maxCenter &&
                                this.center > this.maxCenter &&
                                this.material &&
                                ((this.center = this.maxCenter),
                                (this.material.uniforms.windowCenter.value =
                                    this.center)),
                                this.width &&
                                    this.maxWidth &&
                                    this.width > this.maxWidth &&
                                    this.material &&
                                    ((this.width = this.maxWidth),
                                    (this.material.uniforms.windowWidth.value =
                                        this.width));
                        }),
                        t
                    );
                })();
            },
            520: (t, e, n) => {
                'use strict';
                n.d(e, { T: () => g });
                var i,
                    r,
                    a,
                    o = n(477),
                    s = n(593),
                    l = n(299),
                    c = n(254),
                    u = n(423),
                    h =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    d = function (t, e, n, i) {
                        return new (n || (n = Promise))(function (r, a) {
                            function o(t) {
                                try {
                                    l(i.next(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function s(t) {
                                try {
                                    l(i.throw(t));
                                } catch (t) {
                                    a(t);
                                }
                            }
                            function l(t) {
                                var e;
                                t.done
                                    ? r(t.value)
                                    : ((e = t.value),
                                      e instanceof n
                                          ? e
                                          : new n(function (t) {
                                                t(e);
                                            })).then(o, s);
                            }
                            l((i = i.apply(t, e || [])).next());
                        });
                    },
                    p = function (t, e) {
                        var n,
                            i,
                            r,
                            a,
                            o = {
                                label: 0,
                                sent: function () {
                                    if (1 & r[0]) throw r[1];
                                    return r[1];
                                },
                                trys: [],
                                ops: [],
                            };
                        return (
                            (a = { next: s(0), throw: s(1), return: s(2) }),
                            'function' == typeof Symbol &&
                                (a[Symbol.iterator] = function () {
                                    return this;
                                }),
                            a
                        );
                        function s(s) {
                            return function (l) {
                                return (function (s) {
                                    if (n)
                                        throw new TypeError(
                                            'Generator is already executing.'
                                        );
                                    for (; a && ((a = 0), s[0] && (o = 0)), o; )
                                        try {
                                            if (
                                                ((n = 1),
                                                i &&
                                                    (r =
                                                        2 & s[0]
                                                            ? i.return
                                                            : s[0]
                                                              ? i.throw ||
                                                                ((r =
                                                                    i.return) &&
                                                                    r.call(i),
                                                                0)
                                                              : i.next) &&
                                                    !(r = r.call(i, s[1])).done)
                                            )
                                                return r;
                                            switch (
                                                ((i = 0),
                                                r && (s = [2 & s[0], r.value]),
                                                s[0])
                                            ) {
                                                case 0:
                                                case 1:
                                                    r = s;
                                                    break;
                                                case 4:
                                                    return (
                                                        o.label++,
                                                        {
                                                            value: s[1],
                                                            done: !1,
                                                        }
                                                    );
                                                case 5:
                                                    o.label++,
                                                        (i = s[1]),
                                                        (s = [0]);
                                                    continue;
                                                case 7:
                                                    (s = o.ops.pop()),
                                                        o.trys.pop();
                                                    continue;
                                                default:
                                                    if (
                                                        !(
                                                            (r =
                                                                (r = o.trys)
                                                                    .length >
                                                                    0 &&
                                                                r[
                                                                    r.length - 1
                                                                ]) ||
                                                            (6 !== s[0] &&
                                                                2 !== s[0])
                                                        )
                                                    ) {
                                                        o = 0;
                                                        continue;
                                                    }
                                                    if (
                                                        3 === s[0] &&
                                                        (!r ||
                                                            (s[1] > r[0] &&
                                                                s[1] < r[3]))
                                                    ) {
                                                        o.label = s[1];
                                                        break;
                                                    }
                                                    if (
                                                        6 === s[0] &&
                                                        o.label < r[1]
                                                    ) {
                                                        (o.label = r[1]),
                                                            (r = s);
                                                        break;
                                                    }
                                                    if (r && o.label < r[2]) {
                                                        (o.label = r[2]),
                                                            o.ops.push(s);
                                                        break;
                                                    }
                                                    r[2] && o.ops.pop(),
                                                        o.trys.pop();
                                                    continue;
                                            }
                                            s = e.call(t, o);
                                        } catch (t) {
                                            (s = [6, t]), (i = 0);
                                        } finally {
                                            n = r = 0;
                                        }
                                    if (5 & s[0]) throw s[1];
                                    return {
                                        value: s[0] ? s[1] : void 0,
                                        done: !0,
                                    };
                                })([s, l]);
                            };
                        }
                    },
                    f =
                        (((r = {})[l.a.ImageData] = 1),
                        (r[l.a.Scene] = 3),
                        (r[l.a.BaseObject] = 0),
                        r),
                    m =
                        (((a = {})[l.a.ImageData] = 0),
                        (a[l.a.Scene] = 0),
                        (a[l.a.BaseObject] = 0),
                        a),
                    g = (function (t) {
                        function e(e) {
                            var n,
                                i = this;
                            return (
                                ((i =
                                    t.call(this, f, m, 'renderer', e) ||
                                    this).mesh = new o.Kj0()),
                                (i.activeDot = document.createElement('span')),
                                (i.endDate = new Date()),
                                (i.frames = 0),
                                (i.showAndLogFpsEnabled = !1),
                                (i.elapsedTime = 0),
                                (i.timeUntilLogging = 3e4),
                                (i.totalTimeElapsed = 0),
                                (i.totalFrames = 0),
                                (i.cvsProvided = !1),
                                (i.csvLog =
                                    'Voxels, DataType, Modality, Centre, Width, FPS\n'),
                                (i.scene = new o.xsS()),
                                i.activeDot &&
                                    (i.activeDot.classList.add('activeDot'),
                                    null === (n = i.html) ||
                                        void 0 === n ||
                                        n.appendChild(i.activeDot)),
                                (i.isCanvasActive = !1),
                                i.initRenderer(),
                                i.onDblClickModule(),
                                (i.fsShaderFiltering =
                                    'precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nuniform sampler2D bufferTexture;\n\nuniform float kernel[kernelSize];\n// size is neede, as kernel[kernelSize].length() with dynamic array is not possible\nuniform float kSize;\n\nin vec2 vUv;\n\n/* own variable name for fragment out, as gl_FragColor is deprecated in the used glsl version\n** https://stackoverflow.com/a/51459750, visited 20.01.23 */\nout vec4 outColor;\n\n\n// how to apply kernel see: https://webgl2fundamentals.org/webgl/lessons/webgl-image-processing.html, visited 02.04.23\nfloat applyKernel() {\n    float sum = 0.0;\n    int kernelIndex = 0;\n    // round off because mean is needed [-mean, mean]\n    int mean = int(floor(sqrt(kSize) / 2.0));\n\n    // apply Kernel on current pixel\n    for (int ky = -mean; ky <= mean; ky++) {\n        for (int kx = -mean; kx <= mean; kx++) {\n            // current Kernel Value\n            float kernelValue = kernel[kernelIndex];\n\n            vec2 pixelCoord = vec2(kx, ky) / vec2(textureSize(bufferTexture, 0));\n            float pixelColor = texture(bufferTexture, vec2(vUv + pixelCoord)).r;\n            float pixelMultKernel = pixelColor * kernelValue;\n            sum += pixelMultKernel;\n            kernelIndex +=1;\n        }\n    }\n    /* do not allow values smaller than 0, because in data modifiy filter this is also not possible, because data type Uint is used.\n    ** so both have the same result */\n    if(sum < 0.0) {\n        return 0.0;\n    }\n    return sum;\n}\n\n// apply Kernel see: https://webgl2fundamentals.org/webgl/lessons/webgl-image-processing.html, visited 02.04.23\nvoid main() { \n    float color;\n\n    // image convolution\n    if(kSize > 0.0) {\n        color = applyKernel();\n    } else {\n        color = texture( bufferTexture, vec2( vUv )).r;\n    }\n    \n    outColor = vec4(vec3(color), 1.0);\n}'),
                                (i.vsShaderFiltering =
                                    'out vec2 vUv;\n\nvoid main() {\n\n\t\tvUv = uv;\n\t\tgl_Position = vec4( position, 0.5 );\n}'),
                                (i.postprocessingBufferA = new o.dd2(
                                    window.innerWidth,
                                    window.innerHeight,
                                    { minFilter: o.wem, magFilter: o.wem }
                                )),
                                (i.postprocessingBufferB = new o.dd2(
                                    window.innerWidth,
                                    window.innerHeight,
                                    { minFilter: o.wem, magFilter: o.wem }
                                )),
                                (i.finalMaterial = new o.jyz({
                                    uniforms: {
                                        bufferTexture: { value: null },
                                        kernel: { value: [0] },
                                        kSize: { value: 0 },
                                        size: { value: new o.FM8(1, 2) },
                                    },
                                    defines: { kernelSize: 1 },
                                    glslVersion: o.LSk,
                                    vertexShader: i.vsShaderFiltering,
                                    fragmentShader: i.fsShaderFiltering,
                                })),
                                (i.bufferMaterial = new o.jyz({
                                    uniforms: {
                                        bufferTexture: { value: null },
                                        kernel: { value: [0] },
                                        kSize: { value: 0 },
                                        size: { value: new o.FM8(1, 2) },
                                    },
                                    defines: { kernelSize: 1 },
                                    glslVersion: o.LSk,
                                    vertexShader: i.vsShaderFiltering,
                                    fragmentShader: i.fsShaderFiltering,
                                })),
                                i
                            );
                        }
                        return (
                            h(e, t),
                            (e.prototype.onDialogSubmitCallback = function (t) {
                                throw new Error('Method not implemented.');
                            }),
                            (e.prototype.onUpdateImageDataInput = function () {
                                var t, e;
                                return d(this, void 0, void 0, function () {
                                    return p(this, function (n) {
                                        if (
                                            ((this.elapsedTime = 0),
                                            (this.frames = 0),
                                            (this.endDate = new Date()),
                                            (this.startDate = void 0),
                                            (this.totalTimeElapsed = 0),
                                            (this.totalFrames = 0),
                                            (this.cvsProvided = !1),
                                            this.clearRendering(),
                                            void 0 !==
                                                (null ===
                                                    (t =
                                                        this.imageDataInputs) ||
                                                void 0 === t
                                                    ? void 0
                                                    : t[0].data) &&
                                                null !=
                                                    (null ===
                                                        (e =
                                                            this
                                                                .imageDataInputs) ||
                                                    void 0 === e
                                                        ? void 0
                                                        : e[0].data.data) &&
                                                this.canvas &&
                                                this.scene)
                                        ) {
                                            if (
                                                ((this.canvas.style.pointerEvents =
                                                    'all'),
                                                this.createTexture(),
                                                this.createMaterial(),
                                                this.createMesh(),
                                                this.addMeshToScene(),
                                                this.addSceneInputToScene(),
                                                this.controller)
                                            ) {
                                                if (!this.material)
                                                    throw Error(
                                                        'no material defined!'
                                                    );
                                                this.controller.updateController(
                                                    this.material
                                                );
                                            } else this.createController();
                                            this.htmlInfo &&
                                                document.body.contains(
                                                    this.canvas
                                                ) &&
                                                document.body.appendChild(
                                                    this.htmlInfo
                                                );
                                        } else this.addSceneInputToScene();
                                        return [2];
                                    });
                                });
                            }),
                            (e.prototype.onUpdateSceneInput = function () {
                                var t;
                                return d(this, void 0, void 0, function () {
                                    return p(this, function (e) {
                                        return (
                                            null === (t = this.scene) ||
                                                void 0 === t ||
                                                t.clear(),
                                            this.addMeshToScene(),
                                            this.addSceneInputToScene(),
                                            [2]
                                        );
                                    });
                                });
                            }),
                            (e.prototype.onUpdateBaseObjectInput = function () {
                                return d(this, void 0, void 0, function () {
                                    return p(this, function (t) {
                                        throw Error('Method not implemented');
                                    });
                                });
                            }),
                            (e.prototype.releaseInChild = function () {
                                var t, e, n, i;
                                (this.isCanvasActive = !1),
                                    this.releaseGpuResources(),
                                    null === (t = this.htmlFps) ||
                                        void 0 === t ||
                                        t.remove(),
                                    null === (e = this.htmlInfo) ||
                                        void 0 === e ||
                                        e.remove(),
                                    null === (n = this.canvas) ||
                                        void 0 === n ||
                                        n.remove(),
                                    delete this.material,
                                    delete this.bufferMaterial,
                                    delete this.finalMaterial,
                                    delete this.camera,
                                    delete this.canvas,
                                    null === (i = this.controller) ||
                                        void 0 === i ||
                                        i.destroy(),
                                    delete this.controller,
                                    delete this.htmlInfo,
                                    delete this.mesh,
                                    delete this.texture,
                                    delete this.renderer,
                                    delete this.scene,
                                    delete this.isCanvasActive,
                                    delete this.activeDot,
                                    delete this.htmlFps,
                                    delete this.fsShaderFiltering,
                                    delete this.vsShaderFiltering,
                                    delete this.postprocessingBufferA,
                                    delete this.postprocessingBufferB,
                                    delete this.showAndLogFpsEnabled,
                                    delete this.elapsedTime,
                                    delete this.startDate,
                                    delete this.endDate,
                                    delete this.frames,
                                    delete this.timeUntilLogging,
                                    delete this.totalTimeElapsed,
                                    delete this.totalFrames,
                                    delete this.cvsProvided,
                                    delete this.csvLog,
                                    this.releaseInRenderChild();
                            }),
                            (e.prototype.initRenderer = function () {
                                var t, e;
                                if (
                                    (null !==
                                        (e =
                                            null ===
                                                (t = this.imageDataInputs) ||
                                            void 0 === t
                                                ? void 0
                                                : t.length) && void 0 !== e
                                        ? e
                                        : 0) > 1 ||
                                    f[0] > 1
                                )
                                    throw Error(
                                        'importing more than one image data element is not yet supported in the render module'
                                    );
                                this.createCanvas(),
                                    this.createCamera(),
                                    this.createRenderInfo(),
                                    this.canvas &&
                                        ((this.renderer = new o.CP7({
                                            canvas: this.canvas,
                                            antialias: !0,
                                        })),
                                        this.renderer.setPixelRatio(
                                            window.devicePixelRatio
                                        ),
                                        this.renderer.setSize(
                                            this.canvas.width,
                                            this.canvas.height
                                        ),
                                        this.onMouseMove(),
                                        this.onWheel(),
                                        this.onCameraChanged());
                            }),
                            (e.prototype.render = function () {
                                var t, e;
                                if (
                                    this.scene &&
                                    this.camera &&
                                    this.mesh &&
                                    this.renderer &&
                                    this.isCanvasActive
                                ) {
                                    if (
                                        this.material &&
                                        this.material instanceof o.jyz &&
                                        this.bufferMaterial &&
                                        (this.material.uniforms.cameraPos &&
                                            (this.material.uniforms.cameraPos.value =
                                                this.camera.getCamera().position),
                                        (this.material.uniforms.kernel.value = [
                                            0,
                                        ]),
                                        (this.material.uniforms.kSize.value = 0),
                                        (this.material.defines.kernelSize = 1),
                                        (this.mesh.material = this.material),
                                        (null ===
                                            (e =
                                                null ===
                                                    (t =
                                                        this.imageDataInputs) ||
                                                void 0 === t
                                                    ? void 0
                                                    : t[0]) || void 0 === e
                                            ? void 0
                                            : e.shader) &&
                                            this.imageDataInputs[0].shader
                                                .kernels.length > 0)
                                    ) {
                                        var n =
                                            this.imageDataInputs[0].shader
                                                .kernels;
                                        if (
                                            ((this.material.uniforms.kernel.value =
                                                n[0]),
                                            (this.material.uniforms.kSize.value =
                                                n[0].length),
                                            (this.material.defines.kernelSize =
                                                n[0].length),
                                            n.length > 1 &&
                                                this.postprocessingBufferA &&
                                                this.postprocessingBufferB)
                                        ) {
                                            this.renderer.setRenderTarget(
                                                this.postprocessingBufferB
                                            ),
                                                this.renderer.render(
                                                    this.scene,
                                                    this.camera.getCamera()
                                                ),
                                                (this.bufferMaterial.uniforms.kernel.value =
                                                    n[1]),
                                                (this.bufferMaterial.uniforms.kSize.value =
                                                    n[1].length),
                                                (this.bufferMaterial.defines.kernelSize =
                                                    n[1].length),
                                                (this.mesh.material =
                                                    this.bufferMaterial);
                                            for (var i = 1; i < n.length; i++) {
                                                var r =
                                                    this.postprocessingBufferA;
                                                (this.postprocessingBufferA =
                                                    this.postprocessingBufferB),
                                                    (this.postprocessingBufferB =
                                                        r);
                                                var a = n[i];
                                                (this.bufferMaterial.uniforms.bufferTexture.value =
                                                    this.postprocessingBufferA.texture),
                                                    (this.bufferMaterial.uniforms.kernel.value =
                                                        a),
                                                    (this.bufferMaterial.uniforms.kSize.value =
                                                        a.length),
                                                    (this.bufferMaterial.defines.kernelSize =
                                                        a.length),
                                                    this.renderer.setRenderTarget(
                                                        this
                                                            .postprocessingBufferB
                                                    ),
                                                    this.renderer.render(
                                                        this.scene,
                                                        this.camera.getCamera()
                                                    );
                                            }
                                            this.finalMaterial &&
                                                (this.finalMaterial.uniforms.bufferTexture.value =
                                                    this.postprocessingBufferB.texture),
                                                this.renderer.setRenderTarget(
                                                    null
                                                ),
                                                this.finalMaterial &&
                                                    (this.mesh.material =
                                                        this.finalMaterial);
                                        }
                                    }
                                    this.renderer.render(
                                        this.scene,
                                        this.camera.getCamera()
                                    );
                                }
                            }),
                            (e.prototype.addMeshToScene = function () {
                                var t, e, n;
                                void 0 !==
                                    (null === (t = this.imageDataInputs) ||
                                    void 0 === t
                                        ? void 0
                                        : t[0].data) &&
                                    null !=
                                        (null === (e = this.imageDataInputs) ||
                                        void 0 === e
                                            ? void 0
                                            : e[0].data.data) &&
                                    this.mesh &&
                                    (null === (n = this.scene) ||
                                        void 0 === n ||
                                        n.add(this.mesh));
                            }),
                            (e.prototype.addSceneInputToScene = function () {
                                var t,
                                    e,
                                    n,
                                    i = this,
                                    r = !1;
                                null === (t = this.sceneDataInputs) ||
                                    void 0 === t ||
                                    t.forEach(function (t) {
                                        var e, n;
                                        t.data &&
                                            (null === (e = i.scene) ||
                                                void 0 === e ||
                                                e.add(
                                                    null === (n = t.data) ||
                                                        void 0 === n
                                                        ? void 0
                                                        : n.clone()
                                                ),
                                            (r = !0));
                                    }),
                                    r && this.canvas
                                        ? (this.canvas.style.pointerEvents =
                                              'all')
                                        : this.canvas &&
                                          null ==
                                              (null ===
                                                  (n =
                                                      null ===
                                                          (e =
                                                              this
                                                                  .imageDataInputs) ||
                                                      void 0 === e
                                                          ? void 0
                                                          : e[0].data) ||
                                              void 0 === n
                                                  ? void 0
                                                  : n.data) &&
                                          (this.canvas.style.pointerEvents =
                                              'none'),
                                    this.showAndLogFpsEnabled || this.render();
                            }),
                            (e.prototype.releaseGpuResources = function () {
                                var t, e, n, i, r, a, o;
                                null === (t = this.renderer) ||
                                    void 0 === t ||
                                    t.dispose(),
                                    null === (e = this.material) ||
                                        void 0 === e ||
                                        e.dispose(),
                                    null === (n = this.bufferMaterial) ||
                                        void 0 === n ||
                                        n.dispose(),
                                    null === (i = this.finalMaterial) ||
                                        void 0 === i ||
                                        i.dispose(),
                                    null === (r = this.postprocessingBufferA) ||
                                        void 0 === r ||
                                        r.dispose(),
                                    null === (a = this.postprocessingBufferB) ||
                                        void 0 === a ||
                                        a.dispose(),
                                    null === (o = this.scene) ||
                                        void 0 === o ||
                                        o.clear();
                            }),
                            (e.prototype.clearRendering = function () {
                                var t, e;
                                null === (t = this.htmlInfo) ||
                                    void 0 === t ||
                                    t.remove(),
                                    this.htmlFps &&
                                        (this.htmlFps.innerText = ''),
                                    null === (e = this.controller) ||
                                        void 0 === e ||
                                        e.clearHtmlInfoText(),
                                    this.releaseGpuResources(),
                                    this.clearScene();
                            }),
                            (e.prototype.createCanvas = function () {
                                (this.canvas =
                                    document.createElement('canvas')),
                                    (this.canvas.id = 'renderCanvas'),
                                    this.canvas.addEventListener(
                                        'contextmenu',
                                        function (t) {
                                            t.preventDefault();
                                        }
                                    ),
                                    this.canvas.addEventListener(
                                        'mousemove',
                                        function (t) {
                                            t.stopPropagation();
                                        }
                                    );
                            }),
                            (e.prototype.createRenderInfo = function () {
                                (this.htmlInfo =
                                    document.createElement('section')),
                                    (this.htmlInfo.id = 'infoRendering'),
                                    (this.htmlFps =
                                        document.createElement('p')),
                                    (this.htmlFps.id = 'fps'),
                                    this.htmlInfo.appendChild(this.htmlFps);
                            }),
                            (e.prototype.clearScene = function () {
                                this.canvas &&
                                    this.scene &&
                                    ((this.canvas.style.pointerEvents = 'none'),
                                    this.scene.clear(),
                                    this.showAndLogFpsEnabled || this.render());
                            }),
                            (e.prototype.calcFps = function () {
                                var t, e, n, i, r;
                                if (
                                    this.canvas &&
                                    document.contains(this.canvas) &&
                                    null != this.frames
                                ) {
                                    if (
                                        null === (t = this.imageDataInputs) ||
                                        void 0 === t
                                            ? void 0
                                            : t[0].data
                                    ) {
                                        if (
                                            ((this.endDate = new Date()),
                                            this.startDate ||
                                                (this.startDate = new Date(
                                                    this.endDate.getTime()
                                                )),
                                            this.frames++,
                                            (this.elapsedTime =
                                                this.endDate.getTime() -
                                                this.startDate.getTime()),
                                            this.elapsedTime > 1e3)
                                        ) {
                                            var a = Math.round(
                                                (1e3 * this.frames) /
                                                    this.elapsedTime
                                            );
                                            this.htmlFps &&
                                                (this.htmlFps.innerText =
                                                    'FPS: '.concat(a)),
                                                null != this.totalTimeElapsed &&
                                                    (this.totalTimeElapsed +=
                                                        this.elapsedTime),
                                                (this.startDate = new Date(
                                                    this.endDate.getTime()
                                                )),
                                                null != this.totalFrames &&
                                                    (this.totalFrames +=
                                                        this.frames),
                                                (this.frames = 0);
                                        }
                                        if (
                                            (this.cvsProvided || this.animate(),
                                            this.totalTimeElapsed &&
                                                this.timeUntilLogging &&
                                                this.totalTimeElapsed >=
                                                    this.timeUntilLogging &&
                                                !this.cvsProvided &&
                                                (null ===
                                                    (n =
                                                        null ===
                                                            (e =
                                                                this
                                                                    .imageDataInputs) ||
                                                        void 0 === e
                                                            ? void 0
                                                            : e[0].data) ||
                                                void 0 === n
                                                    ? void 0
                                                    : n.data) &&
                                                null != this.totalFrames)
                                        ) {
                                            var o =
                                                    this.imageDataInputs[0].data
                                                        .data.length,
                                                s =
                                                    this.imageDataInputs[0].data
                                                        .dataType,
                                                l =
                                                    this.imageDataInputs[0].data
                                                        .modality,
                                                c = Math.round(
                                                    (1e3 * this.totalFrames) /
                                                        this.totalTimeElapsed
                                                );
                                            (this.csvLog =
                                                this.csvLog +
                                                '\n'
                                                    .concat(o, ', ')
                                                    .concat(s, ', ')
                                                    .concat(l, ', ')
                                                    .concat(
                                                        null ===
                                                            (i =
                                                                this
                                                                    .material) ||
                                                            void 0 === i
                                                            ? void 0
                                                            : i.uniforms
                                                                  .windowCenter
                                                                  .value,
                                                        ', '
                                                    )
                                                    .concat(
                                                        null ===
                                                            (r =
                                                                this
                                                                    .material) ||
                                                            void 0 === r
                                                            ? void 0
                                                            : r.uniforms
                                                                  .windowWidth
                                                                  .value,
                                                        ', '
                                                    )
                                                    .concat(c)),
                                                (0, u.T)(
                                                    this.csvLog,
                                                    'average-fps-'.concat(
                                                        this.moduleName
                                                    )
                                                ),
                                                (this.cvsProvided = !0);
                                        }
                                        this.render();
                                    }
                                    requestAnimationFrame(
                                        this.calcFps.bind(this)
                                    );
                                }
                            }),
                            (e.prototype.onCameraChanged = function () {
                                var t,
                                    e,
                                    n = this;
                                null ===
                                    (e =
                                        null === (t = this.camera) ||
                                        void 0 === t
                                            ? void 0
                                            : t.cameraUpdatedEvent) ||
                                    void 0 === e ||
                                    e.on('cameraUpdated', function () {
                                        var t, e;
                                        n.isCanvasActive &&
                                            n.canvas &&
                                            ((n.canvas.height =
                                                n.canvas.clientHeight),
                                            (n.canvas.width =
                                                n.canvas.clientWidth),
                                            null === (t = n.renderer) ||
                                                void 0 === t ||
                                                t.setSize(
                                                    n.canvas.width,
                                                    n.canvas.height
                                                ),
                                            (n.canvas.height =
                                                n.canvas.clientHeight),
                                            (n.canvas.width =
                                                n.canvas.clientWidth),
                                            null === (e = n.renderer) ||
                                                void 0 === e ||
                                                e.setSize(
                                                    n.canvas.width,
                                                    n.canvas.height
                                                ),
                                            n.render());
                                    });
                            }),
                            (e.prototype.onDblClickModule = function () {
                                var t,
                                    e = this;
                                null === (t = this.html) ||
                                    void 0 === t ||
                                    t.addEventListener('dblclick', function () {
                                        var t, n, i, r, a, o, s, l;
                                        e.canvas &&
                                            (e.isCanvasActive &&
                                            document.getElementById(
                                                'renderCanvas'
                                            ) === e.canvas
                                                ? (e.canvas.remove(),
                                                  null === (t = e.htmlInfo) ||
                                                      void 0 === t ||
                                                      t.remove(),
                                                  null === (n = e.html) ||
                                                      void 0 === n ||
                                                      n.removeAttribute('id'),
                                                  (e.isCanvasActive = !1))
                                                : (null !==
                                                      document.getElementById(
                                                          'renderCanvas'
                                                      ) &&
                                                      (null ===
                                                          (i =
                                                              document.getElementById(
                                                                  'renderCanvas'
                                                              )) ||
                                                          void 0 === i ||
                                                          i.remove(),
                                                      null ===
                                                          (r =
                                                              document.getElementById(
                                                                  'activeRenderer'
                                                              )) ||
                                                          void 0 === r ||
                                                          r.removeAttribute(
                                                              'id'
                                                          )),
                                                  document.body.appendChild(
                                                      e.canvas
                                                  ),
                                                  (e.canvas.height =
                                                      e.canvas.clientHeight),
                                                  (e.canvas.width =
                                                      e.canvas.clientWidth),
                                                  null === (a = e.renderer) ||
                                                      void 0 === a ||
                                                      a.setSize(
                                                          e.canvas.width,
                                                          e.canvas.height
                                                      ),
                                                  null === (o = e.html) ||
                                                      void 0 === o ||
                                                      o.setAttribute(
                                                          'id',
                                                          'activeRenderer'
                                                      ),
                                                  null !==
                                                      document.getElementById(
                                                          'infoRendering'
                                                      ) &&
                                                      (null ===
                                                          (s =
                                                              document.getElementById(
                                                                  'infoRendering'
                                                              )) ||
                                                          void 0 === s ||
                                                          s.remove()),
                                                  e.htmlInfo &&
                                                      (null ===
                                                          (l =
                                                              e.imageDataInputs) ||
                                                      void 0 === l
                                                          ? void 0
                                                          : l[0].data) &&
                                                      document.body.appendChild(
                                                          e.htmlInfo
                                                      ),
                                                  (e.isCanvasActive = !0),
                                                  e.showAndLogFpsEnabled &&
                                                      e.calcFps()));
                                    });
                            }),
                            (e.prototype.onMouseMove = function () {
                                var t,
                                    e = this;
                                this.showAndLogFpsEnabled ||
                                    null === (t = this.canvas) ||
                                    void 0 === t ||
                                    t.addEventListener(
                                        'mousemove',
                                        function (t) {
                                            var n;
                                            (null === (n = e.imageDataInputs) ||
                                            void 0 === n
                                                ? void 0
                                                : n[0].data) &&
                                                (2 == t.buttons ||
                                                    (e.camera instanceof c.c &&
                                                        1 == t.buttons)) &&
                                                e.render();
                                        }
                                    );
                            }),
                            (e.prototype.onWheel = function () {
                                var t,
                                    e = this;
                                this.showAndLogFpsEnabled ||
                                    null === (t = this.canvas) ||
                                    void 0 === t ||
                                    t.addEventListener('wheel', function () {
                                        var t;
                                        (null === (t = e.imageDataInputs) ||
                                        void 0 === t
                                            ? void 0
                                            : t[0].data) && e.render();
                                    });
                            }),
                            e
                        );
                    })(s.Y);
            },
            720: (t, e, n) => {
                'use strict';
                n.d(e, { Q: () => d });
                var i,
                    r,
                    a,
                    o = n(477),
                    s = n(593),
                    l = n(299),
                    c =
                        ((i = function (t, e) {
                            return (
                                (i =
                                    Object.setPrototypeOf ||
                                    ({ __proto__: [] } instanceof Array &&
                                        function (t, e) {
                                            t.__proto__ = e;
                                        }) ||
                                    function (t, e) {
                                        for (var n in e)
                                            Object.prototype.hasOwnProperty.call(
                                                e,
                                                n
                                            ) && (t[n] = e[n]);
                                    }),
                                i(t, e)
                            );
                        }),
                        function (t, e) {
                            if ('function' != typeof e && null !== e)
                                throw new TypeError(
                                    'Class extends value ' +
                                        String(e) +
                                        ' is not a constructor or null'
                                );
                            function n() {
                                this.constructor = t;
                            }
                            i(t, e),
                                (t.prototype =
                                    null === e
                                        ? Object.create(e)
                                        : ((n.prototype = e.prototype),
                                          new n()));
                        }),
                    u =
                        (((r = {})[l.a.ImageData] = 0),
                        (r[l.a.Scene] = 0),
                        (r[l.a.BaseObject] = 0),
                        r),
                    h =
                        (((a = {})[l.a.ImageData] = 0),
                        (a[l.a.Scene] = 1),
                        (a[l.a.BaseObject] = 0),
                        a),
                    d = (function (t) {
                        function e(e, n, i) {
                            var r =
                                t.call(this, u, h, 'sceneGeometry', e) || this;
                            return (
                                (r.geometry = n),
                                (r.material = i),
                                (r.mesh = new o.Kj0(r.geometry, r.material)),
                                r.sceneDataOutputs &&
                                    (r.sceneDataOutputs[0].data = r.mesh),
                                r
                            );
                        }
                        return (
                            c(e, t),
                            (e.prototype.onUpdateImageDataInput = function () {
                                throw new Error('Method not implemented.');
                            }),
                            (e.prototype.onUpdateSceneInput = function () {
                                throw new Error('Method not implemented.');
                            }),
                            (e.prototype.onUpdateBaseObjectInput = function () {
                                throw new Error('Method not implemented.');
                            }),
                            (e.prototype.onDialogSubmitCallback = function (t) {
                                throw new Error('Method not implemented.');
                            }),
                            (e.prototype.releaseInChild = function () {
                                var t, e;
                                null === (t = this.material) ||
                                    void 0 === t ||
                                    t.dispose(),
                                    null === (e = this.geometry) ||
                                        void 0 === e ||
                                        e.dispose(),
                                    delete this.material,
                                    delete this.geometry,
                                    delete this.mesh;
                            }),
                            e
                        );
                    })(s.Y);
            },
            423: (t, e, n) => {
                'use strict';
                function i(t, e) {
                    var n = new Blob([t], { type: 'text/csv' }),
                        i = URL.createObjectURL(n),
                        r = document.createElement('a');
                    r.setAttribute('href', i),
                        r.setAttribute('download', ''.concat(e, '.csv')),
                        r.click(),
                        URL.revokeObjectURL(i);
                }
                n.d(e, { T: () => i });
            },
            299: (t, e, n) => {
                'use strict';
                var i;
                n.d(e, { a: () => i }),
                    (function (t) {
                        (t[(t.ImageData = 0)] = 'ImageData'),
                            (t[(t.Scene = 1)] = 'Scene'),
                            (t[(t.BaseObject = 2)] = 'BaseObject');
                    })(i || (i = {}));
            },
            330: (t, e, n) => {
                'use strict';
                n.d(e, { a: () => a });
                var i = new Float32Array(1),
                    r = new Int32Array(i.buffer);
                function a(t) {
                    i[0] = t;
                    var e = r[0],
                        n = (e >> 16) & 32768,
                        a = (e >> 12) & 2047,
                        o = (e >> 23) & 255;
                    return o < 103
                        ? n
                        : o > 142
                          ? ((n |= 31744),
                            (n |= (255 == o ? 0 : 1) && 8388607 & e))
                          : o < 113
                            ? (n |=
                                  ((a |= 2048) >> (114 - o)) +
                                  ((a >> (113 - o)) & 1))
                            : ((n |= ((o - 112) << 10) | (a >> 1)),
                              (n += 1 & a));
                }
            },
            856: (t, e, n) => {
                var i = {
                    './example-data.ts': 87,
                    './gauss-smoothing-data.ts': 281,
                    './gauss-smoothing-shader.ts': 497,
                    './geometry-cube.ts': 750,
                    './geometry-plane.ts': 138,
                    './laplace-filter-data.ts': 75,
                    './laplace-filter-shader.ts': 146,
                    './renderer-2d.ts': 698,
                    './renderer-3d.ts': 811,
                };
                function r(t) {
                    return Promise.resolve().then(() => {
                        if (!n.o(i, t)) {
                            var e = new Error("Cannot find module '" + t + "'");
                            throw ((e.code = 'MODULE_NOT_FOUND'), e);
                        }
                        return n(i[t]);
                    });
                }
                (r.keys = () => Object.keys(i)), (r.id = 856), (t.exports = r);
            },
            836: (t, e, n) => {
                var i = {
                    './example-data.ts': 87,
                    './gauss-smoothing-data.ts': 281,
                    './gauss-smoothing-shader.ts': 497,
                    './geometry-cube.ts': 750,
                    './geometry-plane.ts': 138,
                    './laplace-filter-data.ts': 75,
                    './laplace-filter-shader.ts': 146,
                    './renderer-2d.ts': 698,
                    './renderer-3d.ts': 811,
                    'module/modules/example-data.ts': 87,
                    'module/modules/gauss-smoothing-data.ts': 281,
                    'module/modules/gauss-smoothing-shader.ts': 497,
                    'module/modules/geometry-cube.ts': 750,
                    'module/modules/geometry-plane.ts': 138,
                    'module/modules/laplace-filter-data.ts': 75,
                    'module/modules/laplace-filter-shader.ts': 146,
                    'module/modules/renderer-2d.ts': 698,
                    'module/modules/renderer-3d.ts': 811,
                };
                function r(t) {
                    var e = a(t);
                    return n(e);
                }
                function a(t) {
                    if (!n.o(i, t)) {
                        var e = new Error("Cannot find module '" + t + "'");
                        throw ((e.code = 'MODULE_NOT_FOUND'), e);
                    }
                    return i[t];
                }
                (r.keys = function () {
                    return Object.keys(i);
                }),
                    (r.resolve = a),
                    (t.exports = r),
                    (r.id = 836);
            },
            131: (t, e, n) => {
                'use strict';
                t.exports = n.p + '553516f06afe96e66f8f.ico';
            },
            477: (t, e, n) => {
                'use strict';
                n.d(e, {
                    $V: () => qa,
                    CP7: () => Sa,
                    DvJ: () => Cn,
                    FIo: () => Aa,
                    FM8: () => tt,
                    JUT: () => Et,
                    Kj0: () => wn,
                    LSk: () => H,
                    Pa4: () => Tt,
                    QmN: () => a,
                    RsA: () => r,
                    _12: () => Kn,
                    _Li: () => o,
                    _fP: () => St,
                    cLu: () => b,
                    cPb: () => On,
                    dd2: () => Mt,
                    ehD: () => s,
                    hEm: () => A,
                    iKG: () => oi,
                    jyz: () => In,
                    nls: () => wa,
                    p3g: () => bt,
                    pBf: () => V,
                    wem: () => v,
                    xsS: () => Ta,
                });
                const i = '152',
                    r = {
                        LEFT: 0,
                        MIDDLE: 1,
                        RIGHT: 2,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2,
                    },
                    a = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
                    o = 1,
                    s = 2,
                    l = 100,
                    c = 301,
                    u = 302,
                    h = 306,
                    d = 1e3,
                    p = 1001,
                    f = 1002,
                    m = 1003,
                    g = 1005,
                    v = 1006,
                    _ = 1008,
                    x = 1009,
                    y = 1014,
                    M = 1015,
                    b = 1016,
                    E = 1020,
                    S = 1023,
                    T = 1026,
                    w = 1027,
                    A = 1028,
                    C = 33776,
                    R = 33777,
                    L = 33778,
                    P = 33779,
                    D = 36492,
                    I = 2300,
                    U = 2301,
                    O = 2302,
                    N = 3001,
                    F = 'srgb',
                    z = 'srgb-linear',
                    B = 'display-p3',
                    k = 7680,
                    H = '300 es',
                    G = 1035;
                class V {
                    addEventListener(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        const n = this._listeners;
                        void 0 === n[t] && (n[t] = []),
                            -1 === n[t].indexOf(e) && n[t].push(e);
                    }
                    hasEventListener(t, e) {
                        if (void 0 === this._listeners) return !1;
                        const n = this._listeners;
                        return void 0 !== n[t] && -1 !== n[t].indexOf(e);
                    }
                    removeEventListener(t, e) {
                        if (void 0 === this._listeners) return;
                        const n = this._listeners[t];
                        if (void 0 !== n) {
                            const t = n.indexOf(e);
                            -1 !== t && n.splice(t, 1);
                        }
                    }
                    dispatchEvent(t) {
                        if (void 0 === this._listeners) return;
                        const e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            const n = e.slice(0);
                            for (let e = 0, i = n.length; e < i; e++)
                                n[e].call(this, t);
                            t.target = null;
                        }
                    }
                }
                const W = [
                        '00',
                        '01',
                        '02',
                        '03',
                        '04',
                        '05',
                        '06',
                        '07',
                        '08',
                        '09',
                        '0a',
                        '0b',
                        '0c',
                        '0d',
                        '0e',
                        '0f',
                        '10',
                        '11',
                        '12',
                        '13',
                        '14',
                        '15',
                        '16',
                        '17',
                        '18',
                        '19',
                        '1a',
                        '1b',
                        '1c',
                        '1d',
                        '1e',
                        '1f',
                        '20',
                        '21',
                        '22',
                        '23',
                        '24',
                        '25',
                        '26',
                        '27',
                        '28',
                        '29',
                        '2a',
                        '2b',
                        '2c',
                        '2d',
                        '2e',
                        '2f',
                        '30',
                        '31',
                        '32',
                        '33',
                        '34',
                        '35',
                        '36',
                        '37',
                        '38',
                        '39',
                        '3a',
                        '3b',
                        '3c',
                        '3d',
                        '3e',
                        '3f',
                        '40',
                        '41',
                        '42',
                        '43',
                        '44',
                        '45',
                        '46',
                        '47',
                        '48',
                        '49',
                        '4a',
                        '4b',
                        '4c',
                        '4d',
                        '4e',
                        '4f',
                        '50',
                        '51',
                        '52',
                        '53',
                        '54',
                        '55',
                        '56',
                        '57',
                        '58',
                        '59',
                        '5a',
                        '5b',
                        '5c',
                        '5d',
                        '5e',
                        '5f',
                        '60',
                        '61',
                        '62',
                        '63',
                        '64',
                        '65',
                        '66',
                        '67',
                        '68',
                        '69',
                        '6a',
                        '6b',
                        '6c',
                        '6d',
                        '6e',
                        '6f',
                        '70',
                        '71',
                        '72',
                        '73',
                        '74',
                        '75',
                        '76',
                        '77',
                        '78',
                        '79',
                        '7a',
                        '7b',
                        '7c',
                        '7d',
                        '7e',
                        '7f',
                        '80',
                        '81',
                        '82',
                        '83',
                        '84',
                        '85',
                        '86',
                        '87',
                        '88',
                        '89',
                        '8a',
                        '8b',
                        '8c',
                        '8d',
                        '8e',
                        '8f',
                        '90',
                        '91',
                        '92',
                        '93',
                        '94',
                        '95',
                        '96',
                        '97',
                        '98',
                        '99',
                        '9a',
                        '9b',
                        '9c',
                        '9d',
                        '9e',
                        '9f',
                        'a0',
                        'a1',
                        'a2',
                        'a3',
                        'a4',
                        'a5',
                        'a6',
                        'a7',
                        'a8',
                        'a9',
                        'aa',
                        'ab',
                        'ac',
                        'ad',
                        'ae',
                        'af',
                        'b0',
                        'b1',
                        'b2',
                        'b3',
                        'b4',
                        'b5',
                        'b6',
                        'b7',
                        'b8',
                        'b9',
                        'ba',
                        'bb',
                        'bc',
                        'bd',
                        'be',
                        'bf',
                        'c0',
                        'c1',
                        'c2',
                        'c3',
                        'c4',
                        'c5',
                        'c6',
                        'c7',
                        'c8',
                        'c9',
                        'ca',
                        'cb',
                        'cc',
                        'cd',
                        'ce',
                        'cf',
                        'd0',
                        'd1',
                        'd2',
                        'd3',
                        'd4',
                        'd5',
                        'd6',
                        'd7',
                        'd8',
                        'd9',
                        'da',
                        'db',
                        'dc',
                        'dd',
                        'de',
                        'df',
                        'e0',
                        'e1',
                        'e2',
                        'e3',
                        'e4',
                        'e5',
                        'e6',
                        'e7',
                        'e8',
                        'e9',
                        'ea',
                        'eb',
                        'ec',
                        'ed',
                        'ee',
                        'ef',
                        'f0',
                        'f1',
                        'f2',
                        'f3',
                        'f4',
                        'f5',
                        'f6',
                        'f7',
                        'f8',
                        'f9',
                        'fa',
                        'fb',
                        'fc',
                        'fd',
                        'fe',
                        'ff',
                    ],
                    j = Math.PI / 180,
                    X = 180 / Math.PI;
                function Y() {
                    const t = (4294967295 * Math.random()) | 0,
                        e = (4294967295 * Math.random()) | 0,
                        n = (4294967295 * Math.random()) | 0,
                        i = (4294967295 * Math.random()) | 0;
                    return (
                        W[255 & t] +
                        W[(t >> 8) & 255] +
                        W[(t >> 16) & 255] +
                        W[(t >> 24) & 255] +
                        '-' +
                        W[255 & e] +
                        W[(e >> 8) & 255] +
                        '-' +
                        W[((e >> 16) & 15) | 64] +
                        W[(e >> 24) & 255] +
                        '-' +
                        W[(63 & n) | 128] +
                        W[(n >> 8) & 255] +
                        '-' +
                        W[(n >> 16) & 255] +
                        W[(n >> 24) & 255] +
                        W[255 & i] +
                        W[(i >> 8) & 255] +
                        W[(i >> 16) & 255] +
                        W[(i >> 24) & 255]
                    ).toLowerCase();
                }
                function q(t, e, n) {
                    return Math.max(e, Math.min(n, t));
                }
                function K(t, e, n) {
                    return (1 - n) * t + n * e;
                }
                function Z(t) {
                    return 0 == (t & (t - 1)) && 0 !== t;
                }
                function J(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
                }
                function Q(t, e) {
                    switch (e.constructor) {
                        case Float32Array:
                            return t;
                        case Uint16Array:
                            return t / 65535;
                        case Uint8Array:
                            return t / 255;
                        case Int16Array:
                            return Math.max(t / 32767, -1);
                        case Int8Array:
                            return Math.max(t / 127, -1);
                        default:
                            throw new Error('Invalid component type.');
                    }
                }
                function $(t, e) {
                    switch (e.constructor) {
                        case Float32Array:
                            return t;
                        case Uint16Array:
                            return Math.round(65535 * t);
                        case Uint8Array:
                            return Math.round(255 * t);
                        case Int16Array:
                            return Math.round(32767 * t);
                        case Int8Array:
                            return Math.round(127 * t);
                        default:
                            throw new Error('Invalid component type.');
                    }
                }
                class tt {
                    constructor(t = 0, e = 0) {
                        (tt.prototype.isVector2 = !0),
                            (this.x = t),
                            (this.y = e);
                    }
                    get width() {
                        return this.x;
                    }
                    set width(t) {
                        this.x = t;
                    }
                    get height() {
                        return this.y;
                    }
                    set height(t) {
                        this.y = t;
                    }
                    set(t, e) {
                        return (this.x = t), (this.y = e), this;
                    }
                    setScalar(t) {
                        return (this.x = t), (this.y = t), this;
                    }
                    setX(t) {
                        return (this.x = t), this;
                    }
                    setY(t) {
                        return (this.y = t), this;
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            default:
                                throw new Error('index is out of range: ' + t);
                        }
                        return this;
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error('index is out of range: ' + t);
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y);
                    }
                    copy(t) {
                        return (this.x = t.x), (this.y = t.y), this;
                    }
                    add(t) {
                        return (this.x += t.x), (this.y += t.y), this;
                    }
                    addScalar(t) {
                        return (this.x += t), (this.y += t), this;
                    }
                    addVectors(t, e) {
                        return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
                    }
                    addScaledVector(t, e) {
                        return (this.x += t.x * e), (this.y += t.y * e), this;
                    }
                    sub(t) {
                        return (this.x -= t.x), (this.y -= t.y), this;
                    }
                    subScalar(t) {
                        return (this.x -= t), (this.y -= t), this;
                    }
                    subVectors(t, e) {
                        return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
                    }
                    multiply(t) {
                        return (this.x *= t.x), (this.y *= t.y), this;
                    }
                    multiplyScalar(t) {
                        return (this.x *= t), (this.y *= t), this;
                    }
                    divide(t) {
                        return (this.x /= t.x), (this.y /= t.y), this;
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t);
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = t.elements;
                        return (
                            (this.x = i[0] * e + i[3] * n + i[6]),
                            (this.y = i[1] * e + i[4] * n + i[7]),
                            this
                        );
                    }
                    min(t) {
                        return (
                            (this.x = Math.min(this.x, t.x)),
                            (this.y = Math.min(this.y, t.y)),
                            this
                        );
                    }
                    max(t) {
                        return (
                            (this.x = Math.max(this.x, t.x)),
                            (this.y = Math.max(this.y, t.y)),
                            this
                        );
                    }
                    clamp(t, e) {
                        return (
                            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                            this
                        );
                    }
                    clampScalar(t, e) {
                        return (
                            (this.x = Math.max(t, Math.min(e, this.x))),
                            (this.y = Math.max(t, Math.min(e, this.y))),
                            this
                        );
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(
                            Math.max(t, Math.min(e, n))
                        );
                    }
                    floor() {
                        return (
                            (this.x = Math.floor(this.x)),
                            (this.y = Math.floor(this.y)),
                            this
                        );
                    }
                    ceil() {
                        return (
                            (this.x = Math.ceil(this.x)),
                            (this.y = Math.ceil(this.y)),
                            this
                        );
                    }
                    round() {
                        return (
                            (this.x = Math.round(this.x)),
                            (this.y = Math.round(this.y)),
                            this
                        );
                    }
                    roundToZero() {
                        return (
                            (this.x =
                                this.x < 0
                                    ? Math.ceil(this.x)
                                    : Math.floor(this.x)),
                            (this.y =
                                this.y < 0
                                    ? Math.ceil(this.y)
                                    : Math.floor(this.y)),
                            this
                        );
                    }
                    negate() {
                        return (this.x = -this.x), (this.y = -this.y), this;
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y;
                    }
                    cross(t) {
                        return this.x * t.y - this.y * t.x;
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y;
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y);
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y);
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1);
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI;
                    }
                    angleTo(t) {
                        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (0 === e) return Math.PI / 2;
                        const n = this.dot(t) / e;
                        return Math.acos(q(n, -1, 1));
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t));
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y;
                        return e * e + n * n;
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t);
                    }
                    lerp(t, e) {
                        return (
                            (this.x += (t.x - this.x) * e),
                            (this.y += (t.y - this.y) * e),
                            this
                        );
                    }
                    lerpVectors(t, e, n) {
                        return (
                            (this.x = t.x + (e.x - t.x) * n),
                            (this.y = t.y + (e.y - t.y) * n),
                            this
                        );
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y;
                    }
                    fromArray(t, e = 0) {
                        return (this.x = t[e]), (this.y = t[e + 1]), this;
                    }
                    toArray(t = [], e = 0) {
                        return (t[e] = this.x), (t[e + 1] = this.y), t;
                    }
                    fromBufferAttribute(t, e) {
                        return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
                    }
                    rotateAround(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = this.x - t.x,
                            a = this.y - t.y;
                        return (
                            (this.x = r * n - a * i + t.x),
                            (this.y = r * i + a * n + t.y),
                            this
                        );
                    }
                    random() {
                        return (
                            (this.x = Math.random()),
                            (this.y = Math.random()),
                            this
                        );
                    }
                    *[Symbol.iterator]() {
                        yield this.x, yield this.y;
                    }
                }
                class et {
                    constructor() {
                        (et.prototype.isMatrix3 = !0),
                            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
                    }
                    set(t, e, n, i, r, a, o, s, l) {
                        const c = this.elements;
                        return (
                            (c[0] = t),
                            (c[1] = i),
                            (c[2] = o),
                            (c[3] = e),
                            (c[4] = r),
                            (c[5] = s),
                            (c[6] = n),
                            (c[7] = a),
                            (c[8] = l),
                            this
                        );
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return (
                            (e[0] = n[0]),
                            (e[1] = n[1]),
                            (e[2] = n[2]),
                            (e[3] = n[3]),
                            (e[4] = n[4]),
                            (e[5] = n[5]),
                            (e[6] = n[6]),
                            (e[7] = n[7]),
                            (e[8] = n[8]),
                            this
                        );
                    }
                    extractBasis(t, e, n) {
                        return (
                            t.setFromMatrix3Column(this, 0),
                            e.setFromMatrix3Column(this, 1),
                            n.setFromMatrix3Column(this, 2),
                            this
                        );
                    }
                    setFromMatrix4(t) {
                        const e = t.elements;
                        return (
                            this.set(
                                e[0],
                                e[4],
                                e[8],
                                e[1],
                                e[5],
                                e[9],
                                e[2],
                                e[6],
                                e[10]
                            ),
                            this
                        );
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t);
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this);
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            a = n[0],
                            o = n[3],
                            s = n[6],
                            l = n[1],
                            c = n[4],
                            u = n[7],
                            h = n[2],
                            d = n[5],
                            p = n[8],
                            f = i[0],
                            m = i[3],
                            g = i[6],
                            v = i[1],
                            _ = i[4],
                            x = i[7],
                            y = i[2],
                            M = i[5],
                            b = i[8];
                        return (
                            (r[0] = a * f + o * v + s * y),
                            (r[3] = a * m + o * _ + s * M),
                            (r[6] = a * g + o * x + s * b),
                            (r[1] = l * f + c * v + u * y),
                            (r[4] = l * m + c * _ + u * M),
                            (r[7] = l * g + c * x + u * b),
                            (r[2] = h * f + d * v + p * y),
                            (r[5] = h * m + d * _ + p * M),
                            (r[8] = h * g + d * x + p * b),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return (
                            (e[0] *= t),
                            (e[3] *= t),
                            (e[6] *= t),
                            (e[1] *= t),
                            (e[4] *= t),
                            (e[7] *= t),
                            (e[2] *= t),
                            (e[5] *= t),
                            (e[8] *= t),
                            this
                        );
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            a = t[4],
                            o = t[5],
                            s = t[6],
                            l = t[7],
                            c = t[8];
                        return (
                            e * a * c -
                            e * o * l -
                            n * r * c +
                            n * o * s +
                            i * r * l -
                            i * a * s
                        );
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            a = t[4],
                            o = t[5],
                            s = t[6],
                            l = t[7],
                            c = t[8],
                            u = c * a - o * l,
                            h = o * s - c * r,
                            d = l * r - a * s,
                            p = e * u + n * h + i * d;
                        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const f = 1 / p;
                        return (
                            (t[0] = u * f),
                            (t[1] = (i * l - c * n) * f),
                            (t[2] = (o * n - i * a) * f),
                            (t[3] = h * f),
                            (t[4] = (c * e - i * s) * f),
                            (t[5] = (i * r - o * e) * f),
                            (t[6] = d * f),
                            (t[7] = (n * s - l * e) * f),
                            (t[8] = (a * e - n * r) * f),
                            this
                        );
                    }
                    transpose() {
                        let t;
                        const e = this.elements;
                        return (
                            (t = e[1]),
                            (e[1] = e[3]),
                            (e[3] = t),
                            (t = e[2]),
                            (e[2] = e[6]),
                            (e[6] = t),
                            (t = e[5]),
                            (e[5] = e[7]),
                            (e[7] = t),
                            this
                        );
                    }
                    getNormalMatrix(t) {
                        return this.setFromMatrix4(t).invert().transpose();
                    }
                    transposeIntoArray(t) {
                        const e = this.elements;
                        return (
                            (t[0] = e[0]),
                            (t[1] = e[3]),
                            (t[2] = e[6]),
                            (t[3] = e[1]),
                            (t[4] = e[4]),
                            (t[5] = e[7]),
                            (t[6] = e[2]),
                            (t[7] = e[5]),
                            (t[8] = e[8]),
                            this
                        );
                    }
                    setUvTransform(t, e, n, i, r, a, o) {
                        const s = Math.cos(r),
                            l = Math.sin(r);
                        return (
                            this.set(
                                n * s,
                                n * l,
                                -n * (s * a + l * o) + a + t,
                                -i * l,
                                i * s,
                                -i * (-l * a + s * o) + o + e,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    scale(t, e) {
                        return this.premultiply(nt.makeScale(t, e)), this;
                    }
                    rotate(t) {
                        return this.premultiply(nt.makeRotation(-t)), this;
                    }
                    translate(t, e) {
                        return this.premultiply(nt.makeTranslation(t, e)), this;
                    }
                    makeTranslation(t, e) {
                        return this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
                    }
                    makeRotation(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
                    }
                    makeScale(t, e) {
                        return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 9; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0;
                    }
                    fromArray(t, e = 0) {
                        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                        return this;
                    }
                    toArray(t = [], e = 0) {
                        const n = this.elements;
                        return (
                            (t[e] = n[0]),
                            (t[e + 1] = n[1]),
                            (t[e + 2] = n[2]),
                            (t[e + 3] = n[3]),
                            (t[e + 4] = n[4]),
                            (t[e + 5] = n[5]),
                            (t[e + 6] = n[6]),
                            (t[e + 7] = n[7]),
                            (t[e + 8] = n[8]),
                            t
                        );
                    }
                    clone() {
                        return new this.constructor().fromArray(this.elements);
                    }
                }
                const nt = new et();
                function it(t) {
                    for (let e = t.length - 1; e >= 0; --e)
                        if (t[e] >= 65535) return !0;
                    return !1;
                }
                function rt(t) {
                    return document.createElementNS(
                        'http://www.w3.org/1999/xhtml',
                        t
                    );
                }
                Int8Array,
                    Uint8Array,
                    Uint8ClampedArray,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array;
                const at = {};
                function ot(t) {
                    t in at || ((at[t] = !0), console.warn(t));
                }
                function st(t) {
                    return t < 0.04045
                        ? 0.0773993808 * t
                        : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
                }
                function lt(t) {
                    return t < 0.0031308
                        ? 12.92 * t
                        : 1.055 * Math.pow(t, 0.41666) - 0.055;
                }
                const ct = new et().fromArray([
                        0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058,
                        0.0723974, -1e-7, 1e-7, 0.9105199,
                    ]),
                    ut = new et().fromArray([
                        1.2249401, -0.0420569, -0.0196376, -0.2249404,
                        1.0420571, -0.0786361, 1e-7, 0, 1.0982735,
                    ]),
                    ht = {
                        [z]: (t) => t,
                        [F]: (t) => t.convertSRGBToLinear(),
                        [B]: function (t) {
                            return t.convertSRGBToLinear().applyMatrix3(ut);
                        },
                    },
                    dt = {
                        [z]: (t) => t,
                        [F]: (t) => t.convertLinearToSRGB(),
                        [B]: function (t) {
                            return t.applyMatrix3(ct).convertLinearToSRGB();
                        },
                    },
                    pt = {
                        enabled: !0,
                        get legacyMode() {
                            return (
                                console.warn(
                                    'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.'
                                ),
                                !this.enabled
                            );
                        },
                        set legacyMode(t) {
                            console.warn(
                                'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.'
                            ),
                                (this.enabled = !t);
                        },
                        get workingColorSpace() {
                            return z;
                        },
                        set workingColorSpace(t) {
                            console.warn(
                                'THREE.ColorManagement: .workingColorSpace is readonly.'
                            );
                        },
                        convert: function (t, e, n) {
                            if (!1 === this.enabled || e === n || !e || !n)
                                return t;
                            const i = ht[e],
                                r = dt[n];
                            if (void 0 === i || void 0 === r)
                                throw new Error(
                                    `Unsupported color space conversion, "${e}" to "${n}".`
                                );
                            return r(i(t));
                        },
                        fromWorkingColorSpace: function (t, e) {
                            return this.convert(t, this.workingColorSpace, e);
                        },
                        toWorkingColorSpace: function (t, e) {
                            return this.convert(t, e, this.workingColorSpace);
                        },
                    };
                let ft;
                class mt {
                    static getDataURL(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if ('undefined' == typeof HTMLCanvasElement)
                            return t.src;
                        let e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === ft && (ft = rt('canvas')),
                                (ft.width = t.width),
                                (ft.height = t.height);
                            const n = ft.getContext('2d');
                            t instanceof ImageData
                                ? n.putImageData(t, 0, 0)
                                : n.drawImage(t, 0, 0, t.width, t.height),
                                (e = ft);
                        }
                        return e.width > 2048 || e.height > 2048
                            ? (console.warn(
                                  'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
                                  t
                              ),
                              e.toDataURL('image/jpeg', 0.6))
                            : e.toDataURL('image/png');
                    }
                    static sRGBToLinear(t) {
                        if (
                            ('undefined' != typeof HTMLImageElement &&
                                t instanceof HTMLImageElement) ||
                            ('undefined' != typeof HTMLCanvasElement &&
                                t instanceof HTMLCanvasElement) ||
                            ('undefined' != typeof ImageBitmap &&
                                t instanceof ImageBitmap)
                        ) {
                            const e = rt('canvas');
                            (e.width = t.width), (e.height = t.height);
                            const n = e.getContext('2d');
                            n.drawImage(t, 0, 0, t.width, t.height);
                            const i = n.getImageData(0, 0, t.width, t.height),
                                r = i.data;
                            for (let t = 0; t < r.length; t++)
                                r[t] = 255 * st(r[t] / 255);
                            return n.putImageData(i, 0, 0), e;
                        }
                        if (t.data) {
                            const e = t.data.slice(0);
                            for (let t = 0; t < e.length; t++)
                                e instanceof Uint8Array ||
                                e instanceof Uint8ClampedArray
                                    ? (e[t] = Math.floor(255 * st(e[t] / 255)))
                                    : (e[t] = st(e[t]));
                            return {
                                data: e,
                                width: t.width,
                                height: t.height,
                            };
                        }
                        return (
                            console.warn(
                                'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
                            ),
                            t
                        );
                    }
                }
                class gt {
                    constructor(t = null) {
                        (this.isSource = !0),
                            (this.uuid = Y()),
                            (this.data = t),
                            (this.version = 0);
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++;
                    }
                    toJSON(t) {
                        const e = void 0 === t || 'string' == typeof t;
                        if (!e && void 0 !== t.images[this.uuid])
                            return t.images[this.uuid];
                        const n = { uuid: this.uuid, url: '' },
                            i = this.data;
                        if (null !== i) {
                            let t;
                            if (Array.isArray(i)) {
                                t = [];
                                for (let e = 0, n = i.length; e < n; e++)
                                    i[e].isDataTexture
                                        ? t.push(vt(i[e].image))
                                        : t.push(vt(i[e]));
                            } else t = vt(i);
                            n.url = t;
                        }
                        return e || (t.images[this.uuid] = n), n;
                    }
                }
                function vt(t) {
                    return ('undefined' != typeof HTMLImageElement &&
                        t instanceof HTMLImageElement) ||
                        ('undefined' != typeof HTMLCanvasElement &&
                            t instanceof HTMLCanvasElement) ||
                        ('undefined' != typeof ImageBitmap &&
                            t instanceof ImageBitmap)
                        ? mt.getDataURL(t)
                        : t.data
                          ? {
                                data: Array.from(t.data),
                                width: t.width,
                                height: t.height,
                                type: t.data.constructor.name,
                            }
                          : (console.warn(
                                'THREE.Texture: Unable to serialize Texture.'
                            ),
                            {});
                }
                let _t = 0;
                class xt extends V {
                    constructor(
                        t = xt.DEFAULT_IMAGE,
                        e = xt.DEFAULT_MAPPING,
                        n = 1001,
                        i = 1001,
                        r = v,
                        a = 1008,
                        o = 1023,
                        s = 1009,
                        l = xt.DEFAULT_ANISOTROPY,
                        c = ''
                    ) {
                        super(),
                            (this.isTexture = !0),
                            Object.defineProperty(this, 'id', { value: _t++ }),
                            (this.uuid = Y()),
                            (this.name = ''),
                            (this.source = new gt(t)),
                            (this.mipmaps = []),
                            (this.mapping = e),
                            (this.channel = 0),
                            (this.wrapS = n),
                            (this.wrapT = i),
                            (this.magFilter = r),
                            (this.minFilter = a),
                            (this.anisotropy = l),
                            (this.format = o),
                            (this.internalFormat = null),
                            (this.type = s),
                            (this.offset = new tt(0, 0)),
                            (this.repeat = new tt(1, 1)),
                            (this.center = new tt(0, 0)),
                            (this.rotation = 0),
                            (this.matrixAutoUpdate = !0),
                            (this.matrix = new et()),
                            (this.generateMipmaps = !0),
                            (this.premultiplyAlpha = !1),
                            (this.flipY = !0),
                            (this.unpackAlignment = 4),
                            'string' == typeof c
                                ? (this.colorSpace = c)
                                : (ot(
                                      'THREE.Texture: Property .encoding has been replaced by .colorSpace.'
                                  ),
                                  (this.colorSpace = c === N ? F : '')),
                            (this.userData = {}),
                            (this.version = 0),
                            (this.onUpdate = null),
                            (this.isRenderTargetTexture = !1),
                            (this.needsPMREMUpdate = !1);
                    }
                    get image() {
                        return this.source.data;
                    }
                    set image(t = null) {
                        this.source.data = t;
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(
                            this.offset.x,
                            this.offset.y,
                            this.repeat.x,
                            this.repeat.y,
                            this.rotation,
                            this.center.x,
                            this.center.y
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        return (
                            (this.name = t.name),
                            (this.source = t.source),
                            (this.mipmaps = t.mipmaps.slice(0)),
                            (this.mapping = t.mapping),
                            (this.channel = t.channel),
                            (this.wrapS = t.wrapS),
                            (this.wrapT = t.wrapT),
                            (this.magFilter = t.magFilter),
                            (this.minFilter = t.minFilter),
                            (this.anisotropy = t.anisotropy),
                            (this.format = t.format),
                            (this.internalFormat = t.internalFormat),
                            (this.type = t.type),
                            this.offset.copy(t.offset),
                            this.repeat.copy(t.repeat),
                            this.center.copy(t.center),
                            (this.rotation = t.rotation),
                            (this.matrixAutoUpdate = t.matrixAutoUpdate),
                            this.matrix.copy(t.matrix),
                            (this.generateMipmaps = t.generateMipmaps),
                            (this.premultiplyAlpha = t.premultiplyAlpha),
                            (this.flipY = t.flipY),
                            (this.unpackAlignment = t.unpackAlignment),
                            (this.colorSpace = t.colorSpace),
                            (this.userData = JSON.parse(
                                JSON.stringify(t.userData)
                            )),
                            (this.needsUpdate = !0),
                            this
                        );
                    }
                    toJSON(t) {
                        const e = void 0 === t || 'string' == typeof t;
                        if (!e && void 0 !== t.textures[this.uuid])
                            return t.textures[this.uuid];
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: 'Texture',
                                generator: 'Texture.toJSON',
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(t).uuid,
                            mapping: this.mapping,
                            channel: this.channel,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            internalFormat: this.internalFormat,
                            type: this.type,
                            colorSpace: this.colorSpace,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            generateMipmaps: this.generateMipmaps,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment,
                        };
                        return (
                            Object.keys(this.userData).length > 0 &&
                                (n.userData = this.userData),
                            e || (t.textures[this.uuid] = n),
                            n
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: 'dispose' });
                    }
                    transformUv(t) {
                        if (300 !== this.mapping) return t;
                        if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
                            switch (this.wrapS) {
                                case d:
                                    t.x = t.x - Math.floor(t.x);
                                    break;
                                case p:
                                    t.x = t.x < 0 ? 0 : 1;
                                    break;
                                case f:
                                    1 === Math.abs(Math.floor(t.x) % 2)
                                        ? (t.x = Math.ceil(t.x) - t.x)
                                        : (t.x = t.x - Math.floor(t.x));
                            }
                        if (t.y < 0 || t.y > 1)
                            switch (this.wrapT) {
                                case d:
                                    t.y = t.y - Math.floor(t.y);
                                    break;
                                case p:
                                    t.y = t.y < 0 ? 0 : 1;
                                    break;
                                case f:
                                    1 === Math.abs(Math.floor(t.y) % 2)
                                        ? (t.y = Math.ceil(t.y) - t.y)
                                        : (t.y = t.y - Math.floor(t.y));
                            }
                        return this.flipY && (t.y = 1 - t.y), t;
                    }
                    set needsUpdate(t) {
                        !0 === t &&
                            (this.version++, (this.source.needsUpdate = !0));
                    }
                    get encoding() {
                        return (
                            ot(
                                'THREE.Texture: Property .encoding has been replaced by .colorSpace.'
                            ),
                            this.colorSpace === F ? N : 3e3
                        );
                    }
                    set encoding(t) {
                        ot(
                            'THREE.Texture: Property .encoding has been replaced by .colorSpace.'
                        ),
                            (this.colorSpace = t === N ? F : '');
                    }
                }
                (xt.DEFAULT_IMAGE = null),
                    (xt.DEFAULT_MAPPING = 300),
                    (xt.DEFAULT_ANISOTROPY = 1);
                class yt {
                    constructor(t = 0, e = 0, n = 0, i = 1) {
                        (yt.prototype.isVector4 = !0),
                            (this.x = t),
                            (this.y = e),
                            (this.z = n),
                            (this.w = i);
                    }
                    get width() {
                        return this.z;
                    }
                    set width(t) {
                        this.z = t;
                    }
                    get height() {
                        return this.w;
                    }
                    set height(t) {
                        this.w = t;
                    }
                    set(t, e, n, i) {
                        return (
                            (this.x = t),
                            (this.y = e),
                            (this.z = n),
                            (this.w = i),
                            this
                        );
                    }
                    setScalar(t) {
                        return (
                            (this.x = t),
                            (this.y = t),
                            (this.z = t),
                            (this.w = t),
                            this
                        );
                    }
                    setX(t) {
                        return (this.x = t), this;
                    }
                    setY(t) {
                        return (this.y = t), this;
                    }
                    setZ(t) {
                        return (this.z = t), this;
                    }
                    setW(t) {
                        return (this.w = t), this;
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e;
                                break;
                            default:
                                throw new Error('index is out of range: ' + t);
                        }
                        return this;
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error('index is out of range: ' + t);
                        }
                    }
                    clone() {
                        return new this.constructor(
                            this.x,
                            this.y,
                            this.z,
                            this.w
                        );
                    }
                    copy(t) {
                        return (
                            (this.x = t.x),
                            (this.y = t.y),
                            (this.z = t.z),
                            (this.w = void 0 !== t.w ? t.w : 1),
                            this
                        );
                    }
                    add(t) {
                        return (
                            (this.x += t.x),
                            (this.y += t.y),
                            (this.z += t.z),
                            (this.w += t.w),
                            this
                        );
                    }
                    addScalar(t) {
                        return (
                            (this.x += t),
                            (this.y += t),
                            (this.z += t),
                            (this.w += t),
                            this
                        );
                    }
                    addVectors(t, e) {
                        return (
                            (this.x = t.x + e.x),
                            (this.y = t.y + e.y),
                            (this.z = t.z + e.z),
                            (this.w = t.w + e.w),
                            this
                        );
                    }
                    addScaledVector(t, e) {
                        return (
                            (this.x += t.x * e),
                            (this.y += t.y * e),
                            (this.z += t.z * e),
                            (this.w += t.w * e),
                            this
                        );
                    }
                    sub(t) {
                        return (
                            (this.x -= t.x),
                            (this.y -= t.y),
                            (this.z -= t.z),
                            (this.w -= t.w),
                            this
                        );
                    }
                    subScalar(t) {
                        return (
                            (this.x -= t),
                            (this.y -= t),
                            (this.z -= t),
                            (this.w -= t),
                            this
                        );
                    }
                    subVectors(t, e) {
                        return (
                            (this.x = t.x - e.x),
                            (this.y = t.y - e.y),
                            (this.z = t.z - e.z),
                            (this.w = t.w - e.w),
                            this
                        );
                    }
                    multiply(t) {
                        return (
                            (this.x *= t.x),
                            (this.y *= t.y),
                            (this.z *= t.z),
                            (this.w *= t.w),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        return (
                            (this.x *= t),
                            (this.y *= t),
                            (this.z *= t),
                            (this.w *= t),
                            this
                        );
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = this.w,
                            a = t.elements;
                        return (
                            (this.x =
                                a[0] * e + a[4] * n + a[8] * i + a[12] * r),
                            (this.y =
                                a[1] * e + a[5] * n + a[9] * i + a[13] * r),
                            (this.z =
                                a[2] * e + a[6] * n + a[10] * i + a[14] * r),
                            (this.w =
                                a[3] * e + a[7] * n + a[11] * i + a[15] * r),
                            this
                        );
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t);
                    }
                    setAxisAngleFromQuaternion(t) {
                        this.w = 2 * Math.acos(t.w);
                        const e = Math.sqrt(1 - t.w * t.w);
                        return (
                            e < 1e-4
                                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                                : ((this.x = t.x / e),
                                  (this.y = t.y / e),
                                  (this.z = t.z / e)),
                            this
                        );
                    }
                    setAxisAngleFromRotationMatrix(t) {
                        let e, n, i, r;
                        const a = 0.01,
                            o = 0.1,
                            s = t.elements,
                            l = s[0],
                            c = s[4],
                            u = s[8],
                            h = s[1],
                            d = s[5],
                            p = s[9],
                            f = s[2],
                            m = s[6],
                            g = s[10];
                        if (
                            Math.abs(c - h) < a &&
                            Math.abs(u - f) < a &&
                            Math.abs(p - m) < a
                        ) {
                            if (
                                Math.abs(c + h) < o &&
                                Math.abs(u + f) < o &&
                                Math.abs(p + m) < o &&
                                Math.abs(l + d + g - 3) < o
                            )
                                return this.set(1, 0, 0, 0), this;
                            e = Math.PI;
                            const t = (l + 1) / 2,
                                s = (d + 1) / 2,
                                v = (g + 1) / 2,
                                _ = (c + h) / 4,
                                x = (u + f) / 4,
                                y = (p + m) / 4;
                            return (
                                t > s && t > v
                                    ? t < a
                                        ? ((n = 0),
                                          (i = 0.707106781),
                                          (r = 0.707106781))
                                        : ((n = Math.sqrt(t)),
                                          (i = _ / n),
                                          (r = x / n))
                                    : s > v
                                      ? s < a
                                          ? ((n = 0.707106781),
                                            (i = 0),
                                            (r = 0.707106781))
                                          : ((i = Math.sqrt(s)),
                                            (n = _ / i),
                                            (r = y / i))
                                      : v < a
                                        ? ((n = 0.707106781),
                                          (i = 0.707106781),
                                          (r = 0))
                                        : ((r = Math.sqrt(v)),
                                          (n = x / r),
                                          (i = y / r)),
                                this.set(n, i, r, e),
                                this
                            );
                        }
                        let v = Math.sqrt(
                            (m - p) * (m - p) +
                                (u - f) * (u - f) +
                                (h - c) * (h - c)
                        );
                        return (
                            Math.abs(v) < 0.001 && (v = 1),
                            (this.x = (m - p) / v),
                            (this.y = (u - f) / v),
                            (this.z = (h - c) / v),
                            (this.w = Math.acos((l + d + g - 1) / 2)),
                            this
                        );
                    }
                    min(t) {
                        return (
                            (this.x = Math.min(this.x, t.x)),
                            (this.y = Math.min(this.y, t.y)),
                            (this.z = Math.min(this.z, t.z)),
                            (this.w = Math.min(this.w, t.w)),
                            this
                        );
                    }
                    max(t) {
                        return (
                            (this.x = Math.max(this.x, t.x)),
                            (this.y = Math.max(this.y, t.y)),
                            (this.z = Math.max(this.z, t.z)),
                            (this.w = Math.max(this.w, t.w)),
                            this
                        );
                    }
                    clamp(t, e) {
                        return (
                            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
                            this
                        );
                    }
                    clampScalar(t, e) {
                        return (
                            (this.x = Math.max(t, Math.min(e, this.x))),
                            (this.y = Math.max(t, Math.min(e, this.y))),
                            (this.z = Math.max(t, Math.min(e, this.z))),
                            (this.w = Math.max(t, Math.min(e, this.w))),
                            this
                        );
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(
                            Math.max(t, Math.min(e, n))
                        );
                    }
                    floor() {
                        return (
                            (this.x = Math.floor(this.x)),
                            (this.y = Math.floor(this.y)),
                            (this.z = Math.floor(this.z)),
                            (this.w = Math.floor(this.w)),
                            this
                        );
                    }
                    ceil() {
                        return (
                            (this.x = Math.ceil(this.x)),
                            (this.y = Math.ceil(this.y)),
                            (this.z = Math.ceil(this.z)),
                            (this.w = Math.ceil(this.w)),
                            this
                        );
                    }
                    round() {
                        return (
                            (this.x = Math.round(this.x)),
                            (this.y = Math.round(this.y)),
                            (this.z = Math.round(this.z)),
                            (this.w = Math.round(this.w)),
                            this
                        );
                    }
                    roundToZero() {
                        return (
                            (this.x =
                                this.x < 0
                                    ? Math.ceil(this.x)
                                    : Math.floor(this.x)),
                            (this.y =
                                this.y < 0
                                    ? Math.ceil(this.y)
                                    : Math.floor(this.y)),
                            (this.z =
                                this.z < 0
                                    ? Math.ceil(this.z)
                                    : Math.floor(this.z)),
                            (this.w =
                                this.w < 0
                                    ? Math.ceil(this.w)
                                    : Math.floor(this.w)),
                            this
                        );
                    }
                    negate() {
                        return (
                            (this.x = -this.x),
                            (this.y = -this.y),
                            (this.z = -this.z),
                            (this.w = -this.w),
                            this
                        );
                    }
                    dot(t) {
                        return (
                            this.x * t.x +
                            this.y * t.y +
                            this.z * t.z +
                            this.w * t.w
                        );
                    }
                    lengthSq() {
                        return (
                            this.x * this.x +
                            this.y * this.y +
                            this.z * this.z +
                            this.w * this.w
                        );
                    }
                    length() {
                        return Math.sqrt(
                            this.x * this.x +
                                this.y * this.y +
                                this.z * this.z +
                                this.w * this.w
                        );
                    }
                    manhattanLength() {
                        return (
                            Math.abs(this.x) +
                            Math.abs(this.y) +
                            Math.abs(this.z) +
                            Math.abs(this.w)
                        );
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1);
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t);
                    }
                    lerp(t, e) {
                        return (
                            (this.x += (t.x - this.x) * e),
                            (this.y += (t.y - this.y) * e),
                            (this.z += (t.z - this.z) * e),
                            (this.w += (t.w - this.w) * e),
                            this
                        );
                    }
                    lerpVectors(t, e, n) {
                        return (
                            (this.x = t.x + (e.x - t.x) * n),
                            (this.y = t.y + (e.y - t.y) * n),
                            (this.z = t.z + (e.z - t.z) * n),
                            (this.w = t.w + (e.w - t.w) * n),
                            this
                        );
                    }
                    equals(t) {
                        return (
                            t.x === this.x &&
                            t.y === this.y &&
                            t.z === this.z &&
                            t.w === this.w
                        );
                    }
                    fromArray(t, e = 0) {
                        return (
                            (this.x = t[e]),
                            (this.y = t[e + 1]),
                            (this.z = t[e + 2]),
                            (this.w = t[e + 3]),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this.x),
                            (t[e + 1] = this.y),
                            (t[e + 2] = this.z),
                            (t[e + 3] = this.w),
                            t
                        );
                    }
                    fromBufferAttribute(t, e) {
                        return (
                            (this.x = t.getX(e)),
                            (this.y = t.getY(e)),
                            (this.z = t.getZ(e)),
                            (this.w = t.getW(e)),
                            this
                        );
                    }
                    random() {
                        return (
                            (this.x = Math.random()),
                            (this.y = Math.random()),
                            (this.z = Math.random()),
                            (this.w = Math.random()),
                            this
                        );
                    }
                    *[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z, yield this.w;
                    }
                }
                class Mt extends V {
                    constructor(t = 1, e = 1, n = {}) {
                        super(),
                            (this.isWebGLRenderTarget = !0),
                            (this.width = t),
                            (this.height = e),
                            (this.depth = 1),
                            (this.scissor = new yt(0, 0, t, e)),
                            (this.scissorTest = !1),
                            (this.viewport = new yt(0, 0, t, e));
                        const i = { width: t, height: e, depth: 1 };
                        void 0 !== n.encoding &&
                            (ot(
                                'THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.'
                            ),
                            (n.colorSpace = n.encoding === N ? F : '')),
                            (this.texture = new xt(
                                i,
                                n.mapping,
                                n.wrapS,
                                n.wrapT,
                                n.magFilter,
                                n.minFilter,
                                n.format,
                                n.type,
                                n.anisotropy,
                                n.colorSpace
                            )),
                            (this.texture.isRenderTargetTexture = !0),
                            (this.texture.flipY = !1),
                            (this.texture.generateMipmaps =
                                void 0 !== n.generateMipmaps &&
                                n.generateMipmaps),
                            (this.texture.internalFormat =
                                void 0 !== n.internalFormat
                                    ? n.internalFormat
                                    : null),
                            (this.texture.minFilter =
                                void 0 !== n.minFilter ? n.minFilter : v),
                            (this.depthBuffer =
                                void 0 === n.depthBuffer || n.depthBuffer),
                            (this.stencilBuffer =
                                void 0 !== n.stencilBuffer && n.stencilBuffer),
                            (this.depthTexture =
                                void 0 !== n.depthTexture
                                    ? n.depthTexture
                                    : null),
                            (this.samples =
                                void 0 !== n.samples ? n.samples : 0);
                    }
                    setSize(t, e, n = 1) {
                        (this.width === t &&
                            this.height === e &&
                            this.depth === n) ||
                            ((this.width = t),
                            (this.height = e),
                            (this.depth = n),
                            (this.texture.image.width = t),
                            (this.texture.image.height = e),
                            (this.texture.image.depth = n),
                            this.dispose()),
                            this.viewport.set(0, 0, t, e),
                            this.scissor.set(0, 0, t, e);
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        (this.width = t.width),
                            (this.height = t.height),
                            (this.depth = t.depth),
                            this.scissor.copy(t.scissor),
                            (this.scissorTest = t.scissorTest),
                            this.viewport.copy(t.viewport),
                            (this.texture = t.texture.clone()),
                            (this.texture.isRenderTargetTexture = !0);
                        const e = Object.assign({}, t.texture.image);
                        return (
                            (this.texture.source = new gt(e)),
                            (this.depthBuffer = t.depthBuffer),
                            (this.stencilBuffer = t.stencilBuffer),
                            null !== t.depthTexture &&
                                (this.depthTexture = t.depthTexture.clone()),
                            (this.samples = t.samples),
                            this
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: 'dispose' });
                    }
                }
                class bt extends xt {
                    constructor(t = null, e = 1, n = 1, i = 1) {
                        super(null),
                            (this.isDataArrayTexture = !0),
                            (this.image = {
                                data: t,
                                width: e,
                                height: n,
                                depth: i,
                            }),
                            (this.magFilter = m),
                            (this.minFilter = m),
                            (this.wrapR = p),
                            (this.generateMipmaps = !1),
                            (this.flipY = !1),
                            (this.unpackAlignment = 1);
                    }
                }
                class Et extends xt {
                    constructor(t = null, e = 1, n = 1, i = 1) {
                        super(null),
                            (this.isData3DTexture = !0),
                            (this.image = {
                                data: t,
                                width: e,
                                height: n,
                                depth: i,
                            }),
                            (this.magFilter = m),
                            (this.minFilter = m),
                            (this.wrapR = p),
                            (this.generateMipmaps = !1),
                            (this.flipY = !1),
                            (this.unpackAlignment = 1);
                    }
                }
                class St {
                    constructor(t = 0, e = 0, n = 0, i = 1) {
                        (this.isQuaternion = !0),
                            (this._x = t),
                            (this._y = e),
                            (this._z = n),
                            (this._w = i);
                    }
                    static slerpFlat(t, e, n, i, r, a, o) {
                        let s = n[i + 0],
                            l = n[i + 1],
                            c = n[i + 2],
                            u = n[i + 3];
                        const h = r[a + 0],
                            d = r[a + 1],
                            p = r[a + 2],
                            f = r[a + 3];
                        if (0 === o)
                            return (
                                (t[e + 0] = s),
                                (t[e + 1] = l),
                                (t[e + 2] = c),
                                void (t[e + 3] = u)
                            );
                        if (1 === o)
                            return (
                                (t[e + 0] = h),
                                (t[e + 1] = d),
                                (t[e + 2] = p),
                                void (t[e + 3] = f)
                            );
                        if (u !== f || s !== h || l !== d || c !== p) {
                            let t = 1 - o;
                            const e = s * h + l * d + c * p + u * f,
                                n = e >= 0 ? 1 : -1,
                                i = 1 - e * e;
                            if (i > Number.EPSILON) {
                                const r = Math.sqrt(i),
                                    a = Math.atan2(r, e * n);
                                (t = Math.sin(t * a) / r),
                                    (o = Math.sin(o * a) / r);
                            }
                            const r = o * n;
                            if (
                                ((s = s * t + h * r),
                                (l = l * t + d * r),
                                (c = c * t + p * r),
                                (u = u * t + f * r),
                                t === 1 - o)
                            ) {
                                const t =
                                    1 /
                                    Math.sqrt(s * s + l * l + c * c + u * u);
                                (s *= t), (l *= t), (c *= t), (u *= t);
                            }
                        }
                        (t[e] = s),
                            (t[e + 1] = l),
                            (t[e + 2] = c),
                            (t[e + 3] = u);
                    }
                    static multiplyQuaternionsFlat(t, e, n, i, r, a) {
                        const o = n[i],
                            s = n[i + 1],
                            l = n[i + 2],
                            c = n[i + 3],
                            u = r[a],
                            h = r[a + 1],
                            d = r[a + 2],
                            p = r[a + 3];
                        return (
                            (t[e] = o * p + c * u + s * d - l * h),
                            (t[e + 1] = s * p + c * h + l * u - o * d),
                            (t[e + 2] = l * p + c * d + o * h - s * u),
                            (t[e + 3] = c * p - o * u - s * h - l * d),
                            t
                        );
                    }
                    get x() {
                        return this._x;
                    }
                    set x(t) {
                        (this._x = t), this._onChangeCallback();
                    }
                    get y() {
                        return this._y;
                    }
                    set y(t) {
                        (this._y = t), this._onChangeCallback();
                    }
                    get z() {
                        return this._z;
                    }
                    set z(t) {
                        (this._z = t), this._onChangeCallback();
                    }
                    get w() {
                        return this._w;
                    }
                    set w(t) {
                        (this._w = t), this._onChangeCallback();
                    }
                    set(t, e, n, i) {
                        return (
                            (this._x = t),
                            (this._y = e),
                            (this._z = n),
                            (this._w = i),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor(
                            this._x,
                            this._y,
                            this._z,
                            this._w
                        );
                    }
                    copy(t) {
                        return (
                            (this._x = t.x),
                            (this._y = t.y),
                            (this._z = t.z),
                            (this._w = t.w),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    setFromEuler(t, e) {
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            a = t._order,
                            o = Math.cos,
                            s = Math.sin,
                            l = o(n / 2),
                            c = o(i / 2),
                            u = o(r / 2),
                            h = s(n / 2),
                            d = s(i / 2),
                            p = s(r / 2);
                        switch (a) {
                            case 'XYZ':
                                (this._x = h * c * u + l * d * p),
                                    (this._y = l * d * u - h * c * p),
                                    (this._z = l * c * p + h * d * u),
                                    (this._w = l * c * u - h * d * p);
                                break;
                            case 'YXZ':
                                (this._x = h * c * u + l * d * p),
                                    (this._y = l * d * u - h * c * p),
                                    (this._z = l * c * p - h * d * u),
                                    (this._w = l * c * u + h * d * p);
                                break;
                            case 'ZXY':
                                (this._x = h * c * u - l * d * p),
                                    (this._y = l * d * u + h * c * p),
                                    (this._z = l * c * p + h * d * u),
                                    (this._w = l * c * u - h * d * p);
                                break;
                            case 'ZYX':
                                (this._x = h * c * u - l * d * p),
                                    (this._y = l * d * u + h * c * p),
                                    (this._z = l * c * p - h * d * u),
                                    (this._w = l * c * u + h * d * p);
                                break;
                            case 'YZX':
                                (this._x = h * c * u + l * d * p),
                                    (this._y = l * d * u + h * c * p),
                                    (this._z = l * c * p - h * d * u),
                                    (this._w = l * c * u - h * d * p);
                                break;
                            case 'XZY':
                                (this._x = h * c * u - l * d * p),
                                    (this._y = l * d * u - h * c * p),
                                    (this._z = l * c * p + h * d * u),
                                    (this._w = l * c * u + h * d * p);
                                break;
                            default:
                                console.warn(
                                    'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
                                        a
                                );
                        }
                        return !1 !== e && this._onChangeCallback(), this;
                    }
                    setFromAxisAngle(t, e) {
                        const n = e / 2,
                            i = Math.sin(n);
                        return (
                            (this._x = t.x * i),
                            (this._y = t.y * i),
                            (this._z = t.z * i),
                            (this._w = Math.cos(n)),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    setFromRotationMatrix(t) {
                        const e = t.elements,
                            n = e[0],
                            i = e[4],
                            r = e[8],
                            a = e[1],
                            o = e[5],
                            s = e[9],
                            l = e[2],
                            c = e[6],
                            u = e[10],
                            h = n + o + u;
                        if (h > 0) {
                            const t = 0.5 / Math.sqrt(h + 1);
                            (this._w = 0.25 / t),
                                (this._x = (c - s) * t),
                                (this._y = (r - l) * t),
                                (this._z = (a - i) * t);
                        } else if (n > o && n > u) {
                            const t = 2 * Math.sqrt(1 + n - o - u);
                            (this._w = (c - s) / t),
                                (this._x = 0.25 * t),
                                (this._y = (i + a) / t),
                                (this._z = (r + l) / t);
                        } else if (o > u) {
                            const t = 2 * Math.sqrt(1 + o - n - u);
                            (this._w = (r - l) / t),
                                (this._x = (i + a) / t),
                                (this._y = 0.25 * t),
                                (this._z = (s + c) / t);
                        } else {
                            const t = 2 * Math.sqrt(1 + u - n - o);
                            (this._w = (a - i) / t),
                                (this._x = (r + l) / t),
                                (this._y = (s + c) / t),
                                (this._z = 0.25 * t);
                        }
                        return this._onChangeCallback(), this;
                    }
                    setFromUnitVectors(t, e) {
                        let n = t.dot(e) + 1;
                        return (
                            n < Number.EPSILON
                                ? ((n = 0),
                                  Math.abs(t.x) > Math.abs(t.z)
                                      ? ((this._x = -t.y),
                                        (this._y = t.x),
                                        (this._z = 0),
                                        (this._w = n))
                                      : ((this._x = 0),
                                        (this._y = -t.z),
                                        (this._z = t.y),
                                        (this._w = n)))
                                : ((this._x = t.y * e.z - t.z * e.y),
                                  (this._y = t.z * e.x - t.x * e.z),
                                  (this._z = t.x * e.y - t.y * e.x),
                                  (this._w = n)),
                            this.normalize()
                        );
                    }
                    angleTo(t) {
                        return 2 * Math.acos(Math.abs(q(this.dot(t), -1, 1)));
                    }
                    rotateTowards(t, e) {
                        const n = this.angleTo(t);
                        if (0 === n) return this;
                        const i = Math.min(1, e / n);
                        return this.slerp(t, i), this;
                    }
                    identity() {
                        return this.set(0, 0, 0, 1);
                    }
                    invert() {
                        return this.conjugate();
                    }
                    conjugate() {
                        return (
                            (this._x *= -1),
                            (this._y *= -1),
                            (this._z *= -1),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    dot(t) {
                        return (
                            this._x * t._x +
                            this._y * t._y +
                            this._z * t._z +
                            this._w * t._w
                        );
                    }
                    lengthSq() {
                        return (
                            this._x * this._x +
                            this._y * this._y +
                            this._z * this._z +
                            this._w * this._w
                        );
                    }
                    length() {
                        return Math.sqrt(
                            this._x * this._x +
                                this._y * this._y +
                                this._z * this._z +
                                this._w * this._w
                        );
                    }
                    normalize() {
                        let t = this.length();
                        return (
                            0 === t
                                ? ((this._x = 0),
                                  (this._y = 0),
                                  (this._z = 0),
                                  (this._w = 1))
                                : ((t = 1 / t),
                                  (this._x = this._x * t),
                                  (this._y = this._y * t),
                                  (this._z = this._z * t),
                                  (this._w = this._w * t)),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    multiply(t) {
                        return this.multiplyQuaternions(this, t);
                    }
                    premultiply(t) {
                        return this.multiplyQuaternions(t, this);
                    }
                    multiplyQuaternions(t, e) {
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            a = t._w,
                            o = e._x,
                            s = e._y,
                            l = e._z,
                            c = e._w;
                        return (
                            (this._x = n * c + a * o + i * l - r * s),
                            (this._y = i * c + a * s + r * o - n * l),
                            (this._z = r * c + a * l + n * s - i * o),
                            (this._w = a * c - n * o - i * s - r * l),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    slerp(t, e) {
                        if (0 === e) return this;
                        if (1 === e) return this.copy(t);
                        const n = this._x,
                            i = this._y,
                            r = this._z,
                            a = this._w;
                        let o = a * t._w + n * t._x + i * t._y + r * t._z;
                        if (
                            (o < 0
                                ? ((this._w = -t._w),
                                  (this._x = -t._x),
                                  (this._y = -t._y),
                                  (this._z = -t._z),
                                  (o = -o))
                                : this.copy(t),
                            o >= 1)
                        )
                            return (
                                (this._w = a),
                                (this._x = n),
                                (this._y = i),
                                (this._z = r),
                                this
                            );
                        const s = 1 - o * o;
                        if (s <= Number.EPSILON) {
                            const t = 1 - e;
                            return (
                                (this._w = t * a + e * this._w),
                                (this._x = t * n + e * this._x),
                                (this._y = t * i + e * this._y),
                                (this._z = t * r + e * this._z),
                                this.normalize(),
                                this._onChangeCallback(),
                                this
                            );
                        }
                        const l = Math.sqrt(s),
                            c = Math.atan2(l, o),
                            u = Math.sin((1 - e) * c) / l,
                            h = Math.sin(e * c) / l;
                        return (
                            (this._w = a * u + this._w * h),
                            (this._x = n * u + this._x * h),
                            (this._y = i * u + this._y * h),
                            (this._z = r * u + this._z * h),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    slerpQuaternions(t, e, n) {
                        return this.copy(t).slerp(e, n);
                    }
                    random() {
                        const t = Math.random(),
                            e = Math.sqrt(1 - t),
                            n = Math.sqrt(t),
                            i = 2 * Math.PI * Math.random(),
                            r = 2 * Math.PI * Math.random();
                        return this.set(
                            e * Math.cos(i),
                            n * Math.sin(r),
                            n * Math.cos(r),
                            e * Math.sin(i)
                        );
                    }
                    equals(t) {
                        return (
                            t._x === this._x &&
                            t._y === this._y &&
                            t._z === this._z &&
                            t._w === this._w
                        );
                    }
                    fromArray(t, e = 0) {
                        return (
                            (this._x = t[e]),
                            (this._y = t[e + 1]),
                            (this._z = t[e + 2]),
                            (this._w = t[e + 3]),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this._x),
                            (t[e + 1] = this._y),
                            (t[e + 2] = this._z),
                            (t[e + 3] = this._w),
                            t
                        );
                    }
                    fromBufferAttribute(t, e) {
                        return (
                            (this._x = t.getX(e)),
                            (this._y = t.getY(e)),
                            (this._z = t.getZ(e)),
                            (this._w = t.getW(e)),
                            this
                        );
                    }
                    toJSON() {
                        return this.toArray();
                    }
                    _onChange(t) {
                        return (this._onChangeCallback = t), this;
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                            yield this._y,
                            yield this._z,
                            yield this._w;
                    }
                }
                class Tt {
                    constructor(t = 0, e = 0, n = 0) {
                        (Tt.prototype.isVector3 = !0),
                            (this.x = t),
                            (this.y = e),
                            (this.z = n);
                    }
                    set(t, e, n) {
                        return (
                            void 0 === n && (n = this.z),
                            (this.x = t),
                            (this.y = e),
                            (this.z = n),
                            this
                        );
                    }
                    setScalar(t) {
                        return (this.x = t), (this.y = t), (this.z = t), this;
                    }
                    setX(t) {
                        return (this.x = t), this;
                    }
                    setY(t) {
                        return (this.y = t), this;
                    }
                    setZ(t) {
                        return (this.z = t), this;
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            default:
                                throw new Error('index is out of range: ' + t);
                        }
                        return this;
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error('index is out of range: ' + t);
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z);
                    }
                    copy(t) {
                        return (
                            (this.x = t.x), (this.y = t.y), (this.z = t.z), this
                        );
                    }
                    add(t) {
                        return (
                            (this.x += t.x),
                            (this.y += t.y),
                            (this.z += t.z),
                            this
                        );
                    }
                    addScalar(t) {
                        return (
                            (this.x += t), (this.y += t), (this.z += t), this
                        );
                    }
                    addVectors(t, e) {
                        return (
                            (this.x = t.x + e.x),
                            (this.y = t.y + e.y),
                            (this.z = t.z + e.z),
                            this
                        );
                    }
                    addScaledVector(t, e) {
                        return (
                            (this.x += t.x * e),
                            (this.y += t.y * e),
                            (this.z += t.z * e),
                            this
                        );
                    }
                    sub(t) {
                        return (
                            (this.x -= t.x),
                            (this.y -= t.y),
                            (this.z -= t.z),
                            this
                        );
                    }
                    subScalar(t) {
                        return (
                            (this.x -= t), (this.y -= t), (this.z -= t), this
                        );
                    }
                    subVectors(t, e) {
                        return (
                            (this.x = t.x - e.x),
                            (this.y = t.y - e.y),
                            (this.z = t.z - e.z),
                            this
                        );
                    }
                    multiply(t) {
                        return (
                            (this.x *= t.x),
                            (this.y *= t.y),
                            (this.z *= t.z),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        return (
                            (this.x *= t), (this.y *= t), (this.z *= t), this
                        );
                    }
                    multiplyVectors(t, e) {
                        return (
                            (this.x = t.x * e.x),
                            (this.y = t.y * e.y),
                            (this.z = t.z * e.z),
                            this
                        );
                    }
                    applyEuler(t) {
                        return this.applyQuaternion(At.setFromEuler(t));
                    }
                    applyAxisAngle(t, e) {
                        return this.applyQuaternion(At.setFromAxisAngle(t, e));
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return (
                            (this.x = r[0] * e + r[3] * n + r[6] * i),
                            (this.y = r[1] * e + r[4] * n + r[7] * i),
                            (this.z = r[2] * e + r[5] * n + r[8] * i),
                            this
                        );
                    }
                    applyNormalMatrix(t) {
                        return this.applyMatrix3(t).normalize();
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements,
                            a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                        return (
                            (this.x =
                                (r[0] * e + r[4] * n + r[8] * i + r[12]) * a),
                            (this.y =
                                (r[1] * e + r[5] * n + r[9] * i + r[13]) * a),
                            (this.z =
                                (r[2] * e + r[6] * n + r[10] * i + r[14]) * a),
                            this
                        );
                    }
                    applyQuaternion(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.x,
                            a = t.y,
                            o = t.z,
                            s = t.w,
                            l = s * e + a * i - o * n,
                            c = s * n + o * e - r * i,
                            u = s * i + r * n - a * e,
                            h = -r * e - a * n - o * i;
                        return (
                            (this.x = l * s + h * -r + c * -o - u * -a),
                            (this.y = c * s + h * -a + u * -r - l * -o),
                            (this.z = u * s + h * -o + l * -a - c * -r),
                            this
                        );
                    }
                    project(t) {
                        return this.applyMatrix4(
                            t.matrixWorldInverse
                        ).applyMatrix4(t.projectionMatrix);
                    }
                    unproject(t) {
                        return this.applyMatrix4(
                            t.projectionMatrixInverse
                        ).applyMatrix4(t.matrixWorld);
                    }
                    transformDirection(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return (
                            (this.x = r[0] * e + r[4] * n + r[8] * i),
                            (this.y = r[1] * e + r[5] * n + r[9] * i),
                            (this.z = r[2] * e + r[6] * n + r[10] * i),
                            this.normalize()
                        );
                    }
                    divide(t) {
                        return (
                            (this.x /= t.x),
                            (this.y /= t.y),
                            (this.z /= t.z),
                            this
                        );
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t);
                    }
                    min(t) {
                        return (
                            (this.x = Math.min(this.x, t.x)),
                            (this.y = Math.min(this.y, t.y)),
                            (this.z = Math.min(this.z, t.z)),
                            this
                        );
                    }
                    max(t) {
                        return (
                            (this.x = Math.max(this.x, t.x)),
                            (this.y = Math.max(this.y, t.y)),
                            (this.z = Math.max(this.z, t.z)),
                            this
                        );
                    }
                    clamp(t, e) {
                        return (
                            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                            this
                        );
                    }
                    clampScalar(t, e) {
                        return (
                            (this.x = Math.max(t, Math.min(e, this.x))),
                            (this.y = Math.max(t, Math.min(e, this.y))),
                            (this.z = Math.max(t, Math.min(e, this.z))),
                            this
                        );
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(
                            Math.max(t, Math.min(e, n))
                        );
                    }
                    floor() {
                        return (
                            (this.x = Math.floor(this.x)),
                            (this.y = Math.floor(this.y)),
                            (this.z = Math.floor(this.z)),
                            this
                        );
                    }
                    ceil() {
                        return (
                            (this.x = Math.ceil(this.x)),
                            (this.y = Math.ceil(this.y)),
                            (this.z = Math.ceil(this.z)),
                            this
                        );
                    }
                    round() {
                        return (
                            (this.x = Math.round(this.x)),
                            (this.y = Math.round(this.y)),
                            (this.z = Math.round(this.z)),
                            this
                        );
                    }
                    roundToZero() {
                        return (
                            (this.x =
                                this.x < 0
                                    ? Math.ceil(this.x)
                                    : Math.floor(this.x)),
                            (this.y =
                                this.y < 0
                                    ? Math.ceil(this.y)
                                    : Math.floor(this.y)),
                            (this.z =
                                this.z < 0
                                    ? Math.ceil(this.z)
                                    : Math.floor(this.z)),
                            this
                        );
                    }
                    negate() {
                        return (
                            (this.x = -this.x),
                            (this.y = -this.y),
                            (this.z = -this.z),
                            this
                        );
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z;
                    }
                    lengthSq() {
                        return (
                            this.x * this.x + this.y * this.y + this.z * this.z
                        );
                    }
                    length() {
                        return Math.sqrt(
                            this.x * this.x + this.y * this.y + this.z * this.z
                        );
                    }
                    manhattanLength() {
                        return (
                            Math.abs(this.x) +
                            Math.abs(this.y) +
                            Math.abs(this.z)
                        );
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1);
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t);
                    }
                    lerp(t, e) {
                        return (
                            (this.x += (t.x - this.x) * e),
                            (this.y += (t.y - this.y) * e),
                            (this.z += (t.z - this.z) * e),
                            this
                        );
                    }
                    lerpVectors(t, e, n) {
                        return (
                            (this.x = t.x + (e.x - t.x) * n),
                            (this.y = t.y + (e.y - t.y) * n),
                            (this.z = t.z + (e.z - t.z) * n),
                            this
                        );
                    }
                    cross(t) {
                        return this.crossVectors(this, t);
                    }
                    crossVectors(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            a = e.x,
                            o = e.y,
                            s = e.z;
                        return (
                            (this.x = i * s - r * o),
                            (this.y = r * a - n * s),
                            (this.z = n * o - i * a),
                            this
                        );
                    }
                    projectOnVector(t) {
                        const e = t.lengthSq();
                        if (0 === e) return this.set(0, 0, 0);
                        const n = t.dot(this) / e;
                        return this.copy(t).multiplyScalar(n);
                    }
                    projectOnPlane(t) {
                        return wt.copy(this).projectOnVector(t), this.sub(wt);
                    }
                    reflect(t) {
                        return this.sub(
                            wt.copy(t).multiplyScalar(2 * this.dot(t))
                        );
                    }
                    angleTo(t) {
                        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (0 === e) return Math.PI / 2;
                        const n = this.dot(t) / e;
                        return Math.acos(q(n, -1, 1));
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t));
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y,
                            i = this.z - t.z;
                        return e * e + n * n + i * i;
                    }
                    manhattanDistanceTo(t) {
                        return (
                            Math.abs(this.x - t.x) +
                            Math.abs(this.y - t.y) +
                            Math.abs(this.z - t.z)
                        );
                    }
                    setFromSpherical(t) {
                        return this.setFromSphericalCoords(
                            t.radius,
                            t.phi,
                            t.theta
                        );
                    }
                    setFromSphericalCoords(t, e, n) {
                        const i = Math.sin(e) * t;
                        return (
                            (this.x = i * Math.sin(n)),
                            (this.y = Math.cos(e) * t),
                            (this.z = i * Math.cos(n)),
                            this
                        );
                    }
                    setFromCylindrical(t) {
                        return this.setFromCylindricalCoords(
                            t.radius,
                            t.theta,
                            t.y
                        );
                    }
                    setFromCylindricalCoords(t, e, n) {
                        return (
                            (this.x = t * Math.sin(e)),
                            (this.y = n),
                            (this.z = t * Math.cos(e)),
                            this
                        );
                    }
                    setFromMatrixPosition(t) {
                        const e = t.elements;
                        return (
                            (this.x = e[12]),
                            (this.y = e[13]),
                            (this.z = e[14]),
                            this
                        );
                    }
                    setFromMatrixScale(t) {
                        const e = this.setFromMatrixColumn(t, 0).length(),
                            n = this.setFromMatrixColumn(t, 1).length(),
                            i = this.setFromMatrixColumn(t, 2).length();
                        return (this.x = e), (this.y = n), (this.z = i), this;
                    }
                    setFromMatrixColumn(t, e) {
                        return this.fromArray(t.elements, 4 * e);
                    }
                    setFromMatrix3Column(t, e) {
                        return this.fromArray(t.elements, 3 * e);
                    }
                    setFromEuler(t) {
                        return (
                            (this.x = t._x),
                            (this.y = t._y),
                            (this.z = t._z),
                            this
                        );
                    }
                    setFromColor(t) {
                        return (
                            (this.x = t.r), (this.y = t.g), (this.z = t.b), this
                        );
                    }
                    equals(t) {
                        return (
                            t.x === this.x && t.y === this.y && t.z === this.z
                        );
                    }
                    fromArray(t, e = 0) {
                        return (
                            (this.x = t[e]),
                            (this.y = t[e + 1]),
                            (this.z = t[e + 2]),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this.x),
                            (t[e + 1] = this.y),
                            (t[e + 2] = this.z),
                            t
                        );
                    }
                    fromBufferAttribute(t, e) {
                        return (
                            (this.x = t.getX(e)),
                            (this.y = t.getY(e)),
                            (this.z = t.getZ(e)),
                            this
                        );
                    }
                    random() {
                        return (
                            (this.x = Math.random()),
                            (this.y = Math.random()),
                            (this.z = Math.random()),
                            this
                        );
                    }
                    randomDirection() {
                        const t = 2 * (Math.random() - 0.5),
                            e = Math.random() * Math.PI * 2,
                            n = Math.sqrt(1 - t ** 2);
                        return (
                            (this.x = n * Math.cos(e)),
                            (this.y = n * Math.sin(e)),
                            (this.z = t),
                            this
                        );
                    }
                    *[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z;
                    }
                }
                const wt = new Tt(),
                    At = new St();
                class Ct {
                    constructor(
                        t = new Tt(1 / 0, 1 / 0, 1 / 0),
                        e = new Tt(-1 / 0, -1 / 0, -1 / 0)
                    ) {
                        (this.isBox3 = !0), (this.min = t), (this.max = e);
                    }
                    set(t, e) {
                        return this.min.copy(t), this.max.copy(e), this;
                    }
                    setFromArray(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e += 3)
                            this.expandByPoint(Lt.fromArray(t, e));
                        return this;
                    }
                    setFromBufferAttribute(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.count; e < n; e++)
                            this.expandByPoint(Lt.fromBufferAttribute(t, e));
                        return this;
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++)
                            this.expandByPoint(t[e]);
                        return this;
                    }
                    setFromCenterAndSize(t, e) {
                        const n = Lt.copy(e).multiplyScalar(0.5);
                        return (
                            this.min.copy(t).sub(n),
                            this.max.copy(t).add(n),
                            this
                        );
                    }
                    setFromObject(t, e = !1) {
                        return this.makeEmpty(), this.expandByObject(t, e);
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this;
                    }
                    makeEmpty() {
                        return (
                            (this.min.x = this.min.y = this.min.z = 1 / 0),
                            (this.max.x = this.max.y = this.max.z = -1 / 0),
                            this
                        );
                    }
                    isEmpty() {
                        return (
                            this.max.x < this.min.x ||
                            this.max.y < this.min.y ||
                            this.max.z < this.min.z
                        );
                    }
                    getCenter(t) {
                        return this.isEmpty()
                            ? t.set(0, 0, 0)
                            : t
                                  .addVectors(this.min, this.max)
                                  .multiplyScalar(0.5);
                    }
                    getSize(t) {
                        return this.isEmpty()
                            ? t.set(0, 0, 0)
                            : t.subVectors(this.max, this.min);
                    }
                    expandByPoint(t) {
                        return this.min.min(t), this.max.max(t), this;
                    }
                    expandByVector(t) {
                        return this.min.sub(t), this.max.add(t), this;
                    }
                    expandByScalar(t) {
                        return (
                            this.min.addScalar(-t), this.max.addScalar(t), this
                        );
                    }
                    expandByObject(t, e = !1) {
                        if (
                            (t.updateWorldMatrix(!1, !1),
                            void 0 !== t.boundingBox)
                        )
                            null === t.boundingBox && t.computeBoundingBox(),
                                Pt.copy(t.boundingBox),
                                Pt.applyMatrix4(t.matrixWorld),
                                this.union(Pt);
                        else {
                            const n = t.geometry;
                            if (void 0 !== n)
                                if (
                                    e &&
                                    void 0 !== n.attributes &&
                                    void 0 !== n.attributes.position
                                ) {
                                    const e = n.attributes.position;
                                    for (let n = 0, i = e.count; n < i; n++)
                                        Lt.fromBufferAttribute(
                                            e,
                                            n
                                        ).applyMatrix4(t.matrixWorld),
                                            this.expandByPoint(Lt);
                                } else
                                    null === n.boundingBox &&
                                        n.computeBoundingBox(),
                                        Pt.copy(n.boundingBox),
                                        Pt.applyMatrix4(t.matrixWorld),
                                        this.union(Pt);
                        }
                        const n = t.children;
                        for (let t = 0, i = n.length; t < i; t++)
                            this.expandByObject(n[t], e);
                        return this;
                    }
                    containsPoint(t) {
                        return !(
                            t.x < this.min.x ||
                            t.x > this.max.x ||
                            t.y < this.min.y ||
                            t.y > this.max.y ||
                            t.z < this.min.z ||
                            t.z > this.max.z
                        );
                    }
                    containsBox(t) {
                        return (
                            this.min.x <= t.min.x &&
                            t.max.x <= this.max.x &&
                            this.min.y <= t.min.y &&
                            t.max.y <= this.max.y &&
                            this.min.z <= t.min.z &&
                            t.max.z <= this.max.z
                        );
                    }
                    getParameter(t, e) {
                        return e.set(
                            (t.x - this.min.x) / (this.max.x - this.min.x),
                            (t.y - this.min.y) / (this.max.y - this.min.y),
                            (t.z - this.min.z) / (this.max.z - this.min.z)
                        );
                    }
                    intersectsBox(t) {
                        return !(
                            t.max.x < this.min.x ||
                            t.min.x > this.max.x ||
                            t.max.y < this.min.y ||
                            t.min.y > this.max.y ||
                            t.max.z < this.min.z ||
                            t.min.z > this.max.z
                        );
                    }
                    intersectsSphere(t) {
                        return (
                            this.clampPoint(t.center, Lt),
                            Lt.distanceToSquared(t.center) <=
                                t.radius * t.radius
                        );
                    }
                    intersectsPlane(t) {
                        let e, n;
                        return (
                            t.normal.x > 0
                                ? ((e = t.normal.x * this.min.x),
                                  (n = t.normal.x * this.max.x))
                                : ((e = t.normal.x * this.max.x),
                                  (n = t.normal.x * this.min.x)),
                            t.normal.y > 0
                                ? ((e += t.normal.y * this.min.y),
                                  (n += t.normal.y * this.max.y))
                                : ((e += t.normal.y * this.max.y),
                                  (n += t.normal.y * this.min.y)),
                            t.normal.z > 0
                                ? ((e += t.normal.z * this.min.z),
                                  (n += t.normal.z * this.max.z))
                                : ((e += t.normal.z * this.max.z),
                                  (n += t.normal.z * this.min.z)),
                            e <= -t.constant && n >= -t.constant
                        );
                    }
                    intersectsTriangle(t) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(zt),
                            Bt.subVectors(this.max, zt),
                            Dt.subVectors(t.a, zt),
                            It.subVectors(t.b, zt),
                            Ut.subVectors(t.c, zt),
                            Ot.subVectors(It, Dt),
                            Nt.subVectors(Ut, It),
                            Ft.subVectors(Dt, Ut);
                        let e = [
                            0,
                            -Ot.z,
                            Ot.y,
                            0,
                            -Nt.z,
                            Nt.y,
                            0,
                            -Ft.z,
                            Ft.y,
                            Ot.z,
                            0,
                            -Ot.x,
                            Nt.z,
                            0,
                            -Nt.x,
                            Ft.z,
                            0,
                            -Ft.x,
                            -Ot.y,
                            Ot.x,
                            0,
                            -Nt.y,
                            Nt.x,
                            0,
                            -Ft.y,
                            Ft.x,
                            0,
                        ];
                        return (
                            !!Gt(e, Dt, It, Ut, Bt) &&
                            ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                            !!Gt(e, Dt, It, Ut, Bt) &&
                                (kt.crossVectors(Ot, Nt),
                                (e = [kt.x, kt.y, kt.z]),
                                Gt(e, Dt, It, Ut, Bt)))
                        );
                    }
                    clampPoint(t, e) {
                        return e.copy(t).clamp(this.min, this.max);
                    }
                    distanceToPoint(t) {
                        return this.clampPoint(t, Lt).distanceTo(t);
                    }
                    getBoundingSphere(t) {
                        return (
                            this.isEmpty()
                                ? t.makeEmpty()
                                : (this.getCenter(t.center),
                                  (t.radius = 0.5 * this.getSize(Lt).length())),
                            t
                        );
                    }
                    intersect(t) {
                        return (
                            this.min.max(t.min),
                            this.max.min(t.max),
                            this.isEmpty() && this.makeEmpty(),
                            this
                        );
                    }
                    union(t) {
                        return this.min.min(t.min), this.max.max(t.max), this;
                    }
                    applyMatrix4(t) {
                        return (
                            this.isEmpty() ||
                                (Rt[0]
                                    .set(this.min.x, this.min.y, this.min.z)
                                    .applyMatrix4(t),
                                Rt[1]
                                    .set(this.min.x, this.min.y, this.max.z)
                                    .applyMatrix4(t),
                                Rt[2]
                                    .set(this.min.x, this.max.y, this.min.z)
                                    .applyMatrix4(t),
                                Rt[3]
                                    .set(this.min.x, this.max.y, this.max.z)
                                    .applyMatrix4(t),
                                Rt[4]
                                    .set(this.max.x, this.min.y, this.min.z)
                                    .applyMatrix4(t),
                                Rt[5]
                                    .set(this.max.x, this.min.y, this.max.z)
                                    .applyMatrix4(t),
                                Rt[6]
                                    .set(this.max.x, this.max.y, this.min.z)
                                    .applyMatrix4(t),
                                Rt[7]
                                    .set(this.max.x, this.max.y, this.max.z)
                                    .applyMatrix4(t),
                                this.setFromPoints(Rt)),
                            this
                        );
                    }
                    translate(t) {
                        return this.min.add(t), this.max.add(t), this;
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max);
                    }
                }
                const Rt = [
                        new Tt(),
                        new Tt(),
                        new Tt(),
                        new Tt(),
                        new Tt(),
                        new Tt(),
                        new Tt(),
                        new Tt(),
                    ],
                    Lt = new Tt(),
                    Pt = new Ct(),
                    Dt = new Tt(),
                    It = new Tt(),
                    Ut = new Tt(),
                    Ot = new Tt(),
                    Nt = new Tt(),
                    Ft = new Tt(),
                    zt = new Tt(),
                    Bt = new Tt(),
                    kt = new Tt(),
                    Ht = new Tt();
                function Gt(t, e, n, i, r) {
                    for (let a = 0, o = t.length - 3; a <= o; a += 3) {
                        Ht.fromArray(t, a);
                        const o =
                                r.x * Math.abs(Ht.x) +
                                r.y * Math.abs(Ht.y) +
                                r.z * Math.abs(Ht.z),
                            s = e.dot(Ht),
                            l = n.dot(Ht),
                            c = i.dot(Ht);
                        if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > o)
                            return !1;
                    }
                    return !0;
                }
                const Vt = new Ct(),
                    Wt = new Tt(),
                    jt = new Tt();
                class Xt {
                    constructor(t = new Tt(), e = -1) {
                        (this.center = t), (this.radius = e);
                    }
                    set(t, e) {
                        return this.center.copy(t), (this.radius = e), this;
                    }
                    setFromPoints(t, e) {
                        const n = this.center;
                        void 0 !== e
                            ? n.copy(e)
                            : Vt.setFromPoints(t).getCenter(n);
                        let i = 0;
                        for (let e = 0, r = t.length; e < r; e++)
                            i = Math.max(i, n.distanceToSquared(t[e]));
                        return (this.radius = Math.sqrt(i)), this;
                    }
                    copy(t) {
                        return (
                            this.center.copy(t.center),
                            (this.radius = t.radius),
                            this
                        );
                    }
                    isEmpty() {
                        return this.radius < 0;
                    }
                    makeEmpty() {
                        return (
                            this.center.set(0, 0, 0), (this.radius = -1), this
                        );
                    }
                    containsPoint(t) {
                        return (
                            t.distanceToSquared(this.center) <=
                            this.radius * this.radius
                        );
                    }
                    distanceToPoint(t) {
                        return t.distanceTo(this.center) - this.radius;
                    }
                    intersectsSphere(t) {
                        const e = this.radius + t.radius;
                        return t.center.distanceToSquared(this.center) <= e * e;
                    }
                    intersectsBox(t) {
                        return t.intersectsSphere(this);
                    }
                    intersectsPlane(t) {
                        return (
                            Math.abs(t.distanceToPoint(this.center)) <=
                            this.radius
                        );
                    }
                    clampPoint(t, e) {
                        const n = this.center.distanceToSquared(t);
                        return (
                            e.copy(t),
                            n > this.radius * this.radius &&
                                (e.sub(this.center).normalize(),
                                e.multiplyScalar(this.radius).add(this.center)),
                            e
                        );
                    }
                    getBoundingBox(t) {
                        return this.isEmpty()
                            ? (t.makeEmpty(), t)
                            : (t.set(this.center, this.center),
                              t.expandByScalar(this.radius),
                              t);
                    }
                    applyMatrix4(t) {
                        return (
                            this.center.applyMatrix4(t),
                            (this.radius = this.radius * t.getMaxScaleOnAxis()),
                            this
                        );
                    }
                    translate(t) {
                        return this.center.add(t), this;
                    }
                    expandByPoint(t) {
                        if (this.isEmpty())
                            return this.center.copy(t), (this.radius = 0), this;
                        Wt.subVectors(t, this.center);
                        const e = Wt.lengthSq();
                        if (e > this.radius * this.radius) {
                            const t = Math.sqrt(e),
                                n = 0.5 * (t - this.radius);
                            this.center.addScaledVector(Wt, n / t),
                                (this.radius += n);
                        }
                        return this;
                    }
                    union(t) {
                        return t.isEmpty()
                            ? this
                            : this.isEmpty()
                              ? (this.copy(t), this)
                              : (!0 === this.center.equals(t.center)
                                    ? (this.radius = Math.max(
                                          this.radius,
                                          t.radius
                                      ))
                                    : (jt
                                          .subVectors(t.center, this.center)
                                          .setLength(t.radius),
                                      this.expandByPoint(
                                          Wt.copy(t.center).add(jt)
                                      ),
                                      this.expandByPoint(
                                          Wt.copy(t.center).sub(jt)
                                      )),
                                this);
                    }
                    equals(t) {
                        return (
                            t.center.equals(this.center) &&
                            t.radius === this.radius
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                const Yt = new Tt(),
                    qt = new Tt(),
                    Kt = new Tt(),
                    Zt = new Tt(),
                    Jt = new Tt(),
                    Qt = new Tt(),
                    $t = new Tt();
                class te {
                    constructor(t = new Tt(), e = new Tt(0, 0, -1)) {
                        (this.origin = t), (this.direction = e);
                    }
                    set(t, e) {
                        return (
                            this.origin.copy(t), this.direction.copy(e), this
                        );
                    }
                    copy(t) {
                        return (
                            this.origin.copy(t.origin),
                            this.direction.copy(t.direction),
                            this
                        );
                    }
                    at(t, e) {
                        return e
                            .copy(this.origin)
                            .addScaledVector(this.direction, t);
                    }
                    lookAt(t) {
                        return (
                            this.direction.copy(t).sub(this.origin).normalize(),
                            this
                        );
                    }
                    recast(t) {
                        return this.origin.copy(this.at(t, Yt)), this;
                    }
                    closestPointToPoint(t, e) {
                        e.subVectors(t, this.origin);
                        const n = e.dot(this.direction);
                        return n < 0
                            ? e.copy(this.origin)
                            : e
                                  .copy(this.origin)
                                  .addScaledVector(this.direction, n);
                    }
                    distanceToPoint(t) {
                        return Math.sqrt(this.distanceSqToPoint(t));
                    }
                    distanceSqToPoint(t) {
                        const e = Yt.subVectors(t, this.origin).dot(
                            this.direction
                        );
                        return e < 0
                            ? this.origin.distanceToSquared(t)
                            : (Yt.copy(this.origin).addScaledVector(
                                  this.direction,
                                  e
                              ),
                              Yt.distanceToSquared(t));
                    }
                    distanceSqToSegment(t, e, n, i) {
                        qt.copy(t).add(e).multiplyScalar(0.5),
                            Kt.copy(e).sub(t).normalize(),
                            Zt.copy(this.origin).sub(qt);
                        const r = 0.5 * t.distanceTo(e),
                            a = -this.direction.dot(Kt),
                            o = Zt.dot(this.direction),
                            s = -Zt.dot(Kt),
                            l = Zt.lengthSq(),
                            c = Math.abs(1 - a * a);
                        let u, h, d, p;
                        if (c > 0)
                            if (
                                ((u = a * s - o),
                                (h = a * o - s),
                                (p = r * c),
                                u >= 0)
                            )
                                if (h >= -p)
                                    if (h <= p) {
                                        const t = 1 / c;
                                        (u *= t),
                                            (h *= t),
                                            (d =
                                                u * (u + a * h + 2 * o) +
                                                h * (a * u + h + 2 * s) +
                                                l);
                                    } else
                                        (h = r),
                                            (u = Math.max(0, -(a * h + o))),
                                            (d = -u * u + h * (h + 2 * s) + l);
                                else
                                    (h = -r),
                                        (u = Math.max(0, -(a * h + o))),
                                        (d = -u * u + h * (h + 2 * s) + l);
                            else
                                h <= -p
                                    ? ((u = Math.max(0, -(-a * r + o))),
                                      (h =
                                          u > 0
                                              ? -r
                                              : Math.min(Math.max(-r, -s), r)),
                                      (d = -u * u + h * (h + 2 * s) + l))
                                    : h <= p
                                      ? ((u = 0),
                                        (h = Math.min(Math.max(-r, -s), r)),
                                        (d = h * (h + 2 * s) + l))
                                      : ((u = Math.max(0, -(a * r + o))),
                                        (h =
                                            u > 0
                                                ? r
                                                : Math.min(
                                                      Math.max(-r, -s),
                                                      r
                                                  )),
                                        (d = -u * u + h * (h + 2 * s) + l));
                        else
                            (h = a > 0 ? -r : r),
                                (u = Math.max(0, -(a * h + o))),
                                (d = -u * u + h * (h + 2 * s) + l);
                        return (
                            n &&
                                n
                                    .copy(this.origin)
                                    .addScaledVector(this.direction, u),
                            i && i.copy(qt).addScaledVector(Kt, h),
                            d
                        );
                    }
                    intersectSphere(t, e) {
                        Yt.subVectors(t.center, this.origin);
                        const n = Yt.dot(this.direction),
                            i = Yt.dot(Yt) - n * n,
                            r = t.radius * t.radius;
                        if (i > r) return null;
                        const a = Math.sqrt(r - i),
                            o = n - a,
                            s = n + a;
                        return s < 0
                            ? null
                            : o < 0
                              ? this.at(s, e)
                              : this.at(o, e);
                    }
                    intersectsSphere(t) {
                        return (
                            this.distanceSqToPoint(t.center) <=
                            t.radius * t.radius
                        );
                    }
                    distanceToPlane(t) {
                        const e = t.normal.dot(this.direction);
                        if (0 === e)
                            return 0 === t.distanceToPoint(this.origin)
                                ? 0
                                : null;
                        const n = -(this.origin.dot(t.normal) + t.constant) / e;
                        return n >= 0 ? n : null;
                    }
                    intersectPlane(t, e) {
                        const n = this.distanceToPlane(t);
                        return null === n ? null : this.at(n, e);
                    }
                    intersectsPlane(t) {
                        const e = t.distanceToPoint(this.origin);
                        return 0 === e || t.normal.dot(this.direction) * e < 0;
                    }
                    intersectBox(t, e) {
                        let n, i, r, a, o, s;
                        const l = 1 / this.direction.x,
                            c = 1 / this.direction.y,
                            u = 1 / this.direction.z,
                            h = this.origin;
                        return (
                            l >= 0
                                ? ((n = (t.min.x - h.x) * l),
                                  (i = (t.max.x - h.x) * l))
                                : ((n = (t.max.x - h.x) * l),
                                  (i = (t.min.x - h.x) * l)),
                            c >= 0
                                ? ((r = (t.min.y - h.y) * c),
                                  (a = (t.max.y - h.y) * c))
                                : ((r = (t.max.y - h.y) * c),
                                  (a = (t.min.y - h.y) * c)),
                            n > a || r > i
                                ? null
                                : ((r > n || isNaN(n)) && (n = r),
                                  (a < i || isNaN(i)) && (i = a),
                                  u >= 0
                                      ? ((o = (t.min.z - h.z) * u),
                                        (s = (t.max.z - h.z) * u))
                                      : ((o = (t.max.z - h.z) * u),
                                        (s = (t.min.z - h.z) * u)),
                                  n > s || o > i
                                      ? null
                                      : ((o > n || n != n) && (n = o),
                                        (s < i || i != i) && (i = s),
                                        i < 0
                                            ? null
                                            : this.at(n >= 0 ? n : i, e)))
                        );
                    }
                    intersectsBox(t) {
                        return null !== this.intersectBox(t, Yt);
                    }
                    intersectTriangle(t, e, n, i, r) {
                        Jt.subVectors(e, t),
                            Qt.subVectors(n, t),
                            $t.crossVectors(Jt, Qt);
                        let a,
                            o = this.direction.dot($t);
                        if (o > 0) {
                            if (i) return null;
                            a = 1;
                        } else {
                            if (!(o < 0)) return null;
                            (a = -1), (o = -o);
                        }
                        Zt.subVectors(this.origin, t);
                        const s =
                            a * this.direction.dot(Qt.crossVectors(Zt, Qt));
                        if (s < 0) return null;
                        const l = a * this.direction.dot(Jt.cross(Zt));
                        if (l < 0) return null;
                        if (s + l > o) return null;
                        const c = -a * Zt.dot($t);
                        return c < 0 ? null : this.at(c / o, r);
                    }
                    applyMatrix4(t) {
                        return (
                            this.origin.applyMatrix4(t),
                            this.direction.transformDirection(t),
                            this
                        );
                    }
                    equals(t) {
                        return (
                            t.origin.equals(this.origin) &&
                            t.direction.equals(this.direction)
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                class ee {
                    constructor() {
                        (ee.prototype.isMatrix4 = !0),
                            (this.elements = [
                                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
                            ]);
                    }
                    set(t, e, n, i, r, a, o, s, l, c, u, h, d, p, f, m) {
                        const g = this.elements;
                        return (
                            (g[0] = t),
                            (g[4] = e),
                            (g[8] = n),
                            (g[12] = i),
                            (g[1] = r),
                            (g[5] = a),
                            (g[9] = o),
                            (g[13] = s),
                            (g[2] = l),
                            (g[6] = c),
                            (g[10] = u),
                            (g[14] = h),
                            (g[3] = d),
                            (g[7] = p),
                            (g[11] = f),
                            (g[15] = m),
                            this
                        );
                    }
                    identity() {
                        return (
                            this.set(
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    clone() {
                        return new ee().fromArray(this.elements);
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return (
                            (e[0] = n[0]),
                            (e[1] = n[1]),
                            (e[2] = n[2]),
                            (e[3] = n[3]),
                            (e[4] = n[4]),
                            (e[5] = n[5]),
                            (e[6] = n[6]),
                            (e[7] = n[7]),
                            (e[8] = n[8]),
                            (e[9] = n[9]),
                            (e[10] = n[10]),
                            (e[11] = n[11]),
                            (e[12] = n[12]),
                            (e[13] = n[13]),
                            (e[14] = n[14]),
                            (e[15] = n[15]),
                            this
                        );
                    }
                    copyPosition(t) {
                        const e = this.elements,
                            n = t.elements;
                        return (
                            (e[12] = n[12]),
                            (e[13] = n[13]),
                            (e[14] = n[14]),
                            this
                        );
                    }
                    setFromMatrix3(t) {
                        const e = t.elements;
                        return (
                            this.set(
                                e[0],
                                e[3],
                                e[6],
                                0,
                                e[1],
                                e[4],
                                e[7],
                                0,
                                e[2],
                                e[5],
                                e[8],
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    extractBasis(t, e, n) {
                        return (
                            t.setFromMatrixColumn(this, 0),
                            e.setFromMatrixColumn(this, 1),
                            n.setFromMatrixColumn(this, 2),
                            this
                        );
                    }
                    makeBasis(t, e, n) {
                        return (
                            this.set(
                                t.x,
                                e.x,
                                n.x,
                                0,
                                t.y,
                                e.y,
                                n.y,
                                0,
                                t.z,
                                e.z,
                                n.z,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    extractRotation(t) {
                        const e = this.elements,
                            n = t.elements,
                            i = 1 / ne.setFromMatrixColumn(t, 0).length(),
                            r = 1 / ne.setFromMatrixColumn(t, 1).length(),
                            a = 1 / ne.setFromMatrixColumn(t, 2).length();
                        return (
                            (e[0] = n[0] * i),
                            (e[1] = n[1] * i),
                            (e[2] = n[2] * i),
                            (e[3] = 0),
                            (e[4] = n[4] * r),
                            (e[5] = n[5] * r),
                            (e[6] = n[6] * r),
                            (e[7] = 0),
                            (e[8] = n[8] * a),
                            (e[9] = n[9] * a),
                            (e[10] = n[10] * a),
                            (e[11] = 0),
                            (e[12] = 0),
                            (e[13] = 0),
                            (e[14] = 0),
                            (e[15] = 1),
                            this
                        );
                    }
                    makeRotationFromEuler(t) {
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z,
                            a = Math.cos(n),
                            o = Math.sin(n),
                            s = Math.cos(i),
                            l = Math.sin(i),
                            c = Math.cos(r),
                            u = Math.sin(r);
                        if ('XYZ' === t.order) {
                            const t = a * c,
                                n = a * u,
                                i = o * c,
                                r = o * u;
                            (e[0] = s * c),
                                (e[4] = -s * u),
                                (e[8] = l),
                                (e[1] = n + i * l),
                                (e[5] = t - r * l),
                                (e[9] = -o * s),
                                (e[2] = r - t * l),
                                (e[6] = i + n * l),
                                (e[10] = a * s);
                        } else if ('YXZ' === t.order) {
                            const t = s * c,
                                n = s * u,
                                i = l * c,
                                r = l * u;
                            (e[0] = t + r * o),
                                (e[4] = i * o - n),
                                (e[8] = a * l),
                                (e[1] = a * u),
                                (e[5] = a * c),
                                (e[9] = -o),
                                (e[2] = n * o - i),
                                (e[6] = r + t * o),
                                (e[10] = a * s);
                        } else if ('ZXY' === t.order) {
                            const t = s * c,
                                n = s * u,
                                i = l * c,
                                r = l * u;
                            (e[0] = t - r * o),
                                (e[4] = -a * u),
                                (e[8] = i + n * o),
                                (e[1] = n + i * o),
                                (e[5] = a * c),
                                (e[9] = r - t * o),
                                (e[2] = -a * l),
                                (e[6] = o),
                                (e[10] = a * s);
                        } else if ('ZYX' === t.order) {
                            const t = a * c,
                                n = a * u,
                                i = o * c,
                                r = o * u;
                            (e[0] = s * c),
                                (e[4] = i * l - n),
                                (e[8] = t * l + r),
                                (e[1] = s * u),
                                (e[5] = r * l + t),
                                (e[9] = n * l - i),
                                (e[2] = -l),
                                (e[6] = o * s),
                                (e[10] = a * s);
                        } else if ('YZX' === t.order) {
                            const t = a * s,
                                n = a * l,
                                i = o * s,
                                r = o * l;
                            (e[0] = s * c),
                                (e[4] = r - t * u),
                                (e[8] = i * u + n),
                                (e[1] = u),
                                (e[5] = a * c),
                                (e[9] = -o * c),
                                (e[2] = -l * c),
                                (e[6] = n * u + i),
                                (e[10] = t - r * u);
                        } else if ('XZY' === t.order) {
                            const t = a * s,
                                n = a * l,
                                i = o * s,
                                r = o * l;
                            (e[0] = s * c),
                                (e[4] = -u),
                                (e[8] = l * c),
                                (e[1] = t * u + r),
                                (e[5] = a * c),
                                (e[9] = n * u - i),
                                (e[2] = i * u - n),
                                (e[6] = o * c),
                                (e[10] = r * u + t);
                        }
                        return (
                            (e[3] = 0),
                            (e[7] = 0),
                            (e[11] = 0),
                            (e[12] = 0),
                            (e[13] = 0),
                            (e[14] = 0),
                            (e[15] = 1),
                            this
                        );
                    }
                    makeRotationFromQuaternion(t) {
                        return this.compose(re, t, ae);
                    }
                    lookAt(t, e, n) {
                        const i = this.elements;
                        return (
                            le.subVectors(t, e),
                            0 === le.lengthSq() && (le.z = 1),
                            le.normalize(),
                            oe.crossVectors(n, le),
                            0 === oe.lengthSq() &&
                                (1 === Math.abs(n.z)
                                    ? (le.x += 1e-4)
                                    : (le.z += 1e-4),
                                le.normalize(),
                                oe.crossVectors(n, le)),
                            oe.normalize(),
                            se.crossVectors(le, oe),
                            (i[0] = oe.x),
                            (i[4] = se.x),
                            (i[8] = le.x),
                            (i[1] = oe.y),
                            (i[5] = se.y),
                            (i[9] = le.y),
                            (i[2] = oe.z),
                            (i[6] = se.z),
                            (i[10] = le.z),
                            this
                        );
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t);
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this);
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            a = n[0],
                            o = n[4],
                            s = n[8],
                            l = n[12],
                            c = n[1],
                            u = n[5],
                            h = n[9],
                            d = n[13],
                            p = n[2],
                            f = n[6],
                            m = n[10],
                            g = n[14],
                            v = n[3],
                            _ = n[7],
                            x = n[11],
                            y = n[15],
                            M = i[0],
                            b = i[4],
                            E = i[8],
                            S = i[12],
                            T = i[1],
                            w = i[5],
                            A = i[9],
                            C = i[13],
                            R = i[2],
                            L = i[6],
                            P = i[10],
                            D = i[14],
                            I = i[3],
                            U = i[7],
                            O = i[11],
                            N = i[15];
                        return (
                            (r[0] = a * M + o * T + s * R + l * I),
                            (r[4] = a * b + o * w + s * L + l * U),
                            (r[8] = a * E + o * A + s * P + l * O),
                            (r[12] = a * S + o * C + s * D + l * N),
                            (r[1] = c * M + u * T + h * R + d * I),
                            (r[5] = c * b + u * w + h * L + d * U),
                            (r[9] = c * E + u * A + h * P + d * O),
                            (r[13] = c * S + u * C + h * D + d * N),
                            (r[2] = p * M + f * T + m * R + g * I),
                            (r[6] = p * b + f * w + m * L + g * U),
                            (r[10] = p * E + f * A + m * P + g * O),
                            (r[14] = p * S + f * C + m * D + g * N),
                            (r[3] = v * M + _ * T + x * R + y * I),
                            (r[7] = v * b + _ * w + x * L + y * U),
                            (r[11] = v * E + _ * A + x * P + y * O),
                            (r[15] = v * S + _ * C + x * D + y * N),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return (
                            (e[0] *= t),
                            (e[4] *= t),
                            (e[8] *= t),
                            (e[12] *= t),
                            (e[1] *= t),
                            (e[5] *= t),
                            (e[9] *= t),
                            (e[13] *= t),
                            (e[2] *= t),
                            (e[6] *= t),
                            (e[10] *= t),
                            (e[14] *= t),
                            (e[3] *= t),
                            (e[7] *= t),
                            (e[11] *= t),
                            (e[15] *= t),
                            this
                        );
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[4],
                            i = t[8],
                            r = t[12],
                            a = t[1],
                            o = t[5],
                            s = t[9],
                            l = t[13],
                            c = t[2],
                            u = t[6],
                            h = t[10],
                            d = t[14];
                        return (
                            t[3] *
                                (+r * s * u -
                                    i * l * u -
                                    r * o * h +
                                    n * l * h +
                                    i * o * d -
                                    n * s * d) +
                            t[7] *
                                (+e * s * d -
                                    e * l * h +
                                    r * a * h -
                                    i * a * d +
                                    i * l * c -
                                    r * s * c) +
                            t[11] *
                                (+e * l * u -
                                    e * o * d -
                                    r * a * u +
                                    n * a * d +
                                    r * o * c -
                                    n * l * c) +
                            t[15] *
                                (-i * o * c -
                                    e * s * u +
                                    e * o * h +
                                    i * a * u -
                                    n * a * h +
                                    n * s * c)
                        );
                    }
                    transpose() {
                        const t = this.elements;
                        let e;
                        return (
                            (e = t[1]),
                            (t[1] = t[4]),
                            (t[4] = e),
                            (e = t[2]),
                            (t[2] = t[8]),
                            (t[8] = e),
                            (e = t[6]),
                            (t[6] = t[9]),
                            (t[9] = e),
                            (e = t[3]),
                            (t[3] = t[12]),
                            (t[12] = e),
                            (e = t[7]),
                            (t[7] = t[13]),
                            (t[13] = e),
                            (e = t[11]),
                            (t[11] = t[14]),
                            (t[14] = e),
                            this
                        );
                    }
                    setPosition(t, e, n) {
                        const i = this.elements;
                        return (
                            t.isVector3
                                ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
                                : ((i[12] = t), (i[13] = e), (i[14] = n)),
                            this
                        );
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            a = t[4],
                            o = t[5],
                            s = t[6],
                            l = t[7],
                            c = t[8],
                            u = t[9],
                            h = t[10],
                            d = t[11],
                            p = t[12],
                            f = t[13],
                            m = t[14],
                            g = t[15],
                            v =
                                u * m * l -
                                f * h * l +
                                f * s * d -
                                o * m * d -
                                u * s * g +
                                o * h * g,
                            _ =
                                p * h * l -
                                c * m * l -
                                p * s * d +
                                a * m * d +
                                c * s * g -
                                a * h * g,
                            x =
                                c * f * l -
                                p * u * l +
                                p * o * d -
                                a * f * d -
                                c * o * g +
                                a * u * g,
                            y =
                                p * u * s -
                                c * f * s -
                                p * o * h +
                                a * f * h +
                                c * o * m -
                                a * u * m,
                            M = e * v + n * _ + i * x + r * y;
                        if (0 === M)
                            return this.set(
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
                            );
                        const b = 1 / M;
                        return (
                            (t[0] = v * b),
                            (t[1] =
                                (f * h * r -
                                    u * m * r -
                                    f * i * d +
                                    n * m * d +
                                    u * i * g -
                                    n * h * g) *
                                b),
                            (t[2] =
                                (o * m * r -
                                    f * s * r +
                                    f * i * l -
                                    n * m * l -
                                    o * i * g +
                                    n * s * g) *
                                b),
                            (t[3] =
                                (u * s * r -
                                    o * h * r -
                                    u * i * l +
                                    n * h * l +
                                    o * i * d -
                                    n * s * d) *
                                b),
                            (t[4] = _ * b),
                            (t[5] =
                                (c * m * r -
                                    p * h * r +
                                    p * i * d -
                                    e * m * d -
                                    c * i * g +
                                    e * h * g) *
                                b),
                            (t[6] =
                                (p * s * r -
                                    a * m * r -
                                    p * i * l +
                                    e * m * l +
                                    a * i * g -
                                    e * s * g) *
                                b),
                            (t[7] =
                                (a * h * r -
                                    c * s * r +
                                    c * i * l -
                                    e * h * l -
                                    a * i * d +
                                    e * s * d) *
                                b),
                            (t[8] = x * b),
                            (t[9] =
                                (p * u * r -
                                    c * f * r -
                                    p * n * d +
                                    e * f * d +
                                    c * n * g -
                                    e * u * g) *
                                b),
                            (t[10] =
                                (a * f * r -
                                    p * o * r +
                                    p * n * l -
                                    e * f * l -
                                    a * n * g +
                                    e * o * g) *
                                b),
                            (t[11] =
                                (c * o * r -
                                    a * u * r -
                                    c * n * l +
                                    e * u * l +
                                    a * n * d -
                                    e * o * d) *
                                b),
                            (t[12] = y * b),
                            (t[13] =
                                (c * f * i -
                                    p * u * i +
                                    p * n * h -
                                    e * f * h -
                                    c * n * m +
                                    e * u * m) *
                                b),
                            (t[14] =
                                (p * o * i -
                                    a * f * i -
                                    p * n * s +
                                    e * f * s +
                                    a * n * m -
                                    e * o * m) *
                                b),
                            (t[15] =
                                (a * u * i -
                                    c * o * i +
                                    c * n * s -
                                    e * u * s -
                                    a * n * h +
                                    e * o * h) *
                                b),
                            this
                        );
                    }
                    scale(t) {
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z;
                        return (
                            (e[0] *= n),
                            (e[4] *= i),
                            (e[8] *= r),
                            (e[1] *= n),
                            (e[5] *= i),
                            (e[9] *= r),
                            (e[2] *= n),
                            (e[6] *= i),
                            (e[10] *= r),
                            (e[3] *= n),
                            (e[7] *= i),
                            (e[11] *= r),
                            this
                        );
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements,
                            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(e, n, i));
                    }
                    makeTranslation(t, e, n) {
                        return (
                            this.set(
                                1,
                                0,
                                0,
                                t,
                                0,
                                1,
                                0,
                                e,
                                0,
                                0,
                                1,
                                n,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeRotationX(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return (
                            this.set(
                                1,
                                0,
                                0,
                                0,
                                0,
                                e,
                                -n,
                                0,
                                0,
                                n,
                                e,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeRotationY(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return (
                            this.set(
                                e,
                                0,
                                n,
                                0,
                                0,
                                1,
                                0,
                                0,
                                -n,
                                0,
                                e,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeRotationZ(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return (
                            this.set(
                                e,
                                -n,
                                0,
                                0,
                                n,
                                e,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeRotationAxis(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = 1 - n,
                            a = t.x,
                            o = t.y,
                            s = t.z,
                            l = r * a,
                            c = r * o;
                        return (
                            this.set(
                                l * a + n,
                                l * o - i * s,
                                l * s + i * o,
                                0,
                                l * o + i * s,
                                c * o + n,
                                c * s - i * a,
                                0,
                                l * s - i * o,
                                c * s + i * a,
                                r * s * s + n,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeScale(t, e, n) {
                        return (
                            this.set(
                                t,
                                0,
                                0,
                                0,
                                0,
                                e,
                                0,
                                0,
                                0,
                                0,
                                n,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeShear(t, e, n, i, r, a) {
                        return (
                            this.set(
                                1,
                                n,
                                r,
                                0,
                                t,
                                1,
                                a,
                                0,
                                e,
                                i,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    compose(t, e, n) {
                        const i = this.elements,
                            r = e._x,
                            a = e._y,
                            o = e._z,
                            s = e._w,
                            l = r + r,
                            c = a + a,
                            u = o + o,
                            h = r * l,
                            d = r * c,
                            p = r * u,
                            f = a * c,
                            m = a * u,
                            g = o * u,
                            v = s * l,
                            _ = s * c,
                            x = s * u,
                            y = n.x,
                            M = n.y,
                            b = n.z;
                        return (
                            (i[0] = (1 - (f + g)) * y),
                            (i[1] = (d + x) * y),
                            (i[2] = (p - _) * y),
                            (i[3] = 0),
                            (i[4] = (d - x) * M),
                            (i[5] = (1 - (h + g)) * M),
                            (i[6] = (m + v) * M),
                            (i[7] = 0),
                            (i[8] = (p + _) * b),
                            (i[9] = (m - v) * b),
                            (i[10] = (1 - (h + f)) * b),
                            (i[11] = 0),
                            (i[12] = t.x),
                            (i[13] = t.y),
                            (i[14] = t.z),
                            (i[15] = 1),
                            this
                        );
                    }
                    decompose(t, e, n) {
                        const i = this.elements;
                        let r = ne.set(i[0], i[1], i[2]).length();
                        const a = ne.set(i[4], i[5], i[6]).length(),
                            o = ne.set(i[8], i[9], i[10]).length();
                        this.determinant() < 0 && (r = -r),
                            (t.x = i[12]),
                            (t.y = i[13]),
                            (t.z = i[14]),
                            ie.copy(this);
                        const s = 1 / r,
                            l = 1 / a,
                            c = 1 / o;
                        return (
                            (ie.elements[0] *= s),
                            (ie.elements[1] *= s),
                            (ie.elements[2] *= s),
                            (ie.elements[4] *= l),
                            (ie.elements[5] *= l),
                            (ie.elements[6] *= l),
                            (ie.elements[8] *= c),
                            (ie.elements[9] *= c),
                            (ie.elements[10] *= c),
                            e.setFromRotationMatrix(ie),
                            (n.x = r),
                            (n.y = a),
                            (n.z = o),
                            this
                        );
                    }
                    makePerspective(t, e, n, i, r, a) {
                        const o = this.elements,
                            s = (2 * r) / (e - t),
                            l = (2 * r) / (n - i),
                            c = (e + t) / (e - t),
                            u = (n + i) / (n - i),
                            h = -(a + r) / (a - r),
                            d = (-2 * a * r) / (a - r);
                        return (
                            (o[0] = s),
                            (o[4] = 0),
                            (o[8] = c),
                            (o[12] = 0),
                            (o[1] = 0),
                            (o[5] = l),
                            (o[9] = u),
                            (o[13] = 0),
                            (o[2] = 0),
                            (o[6] = 0),
                            (o[10] = h),
                            (o[14] = d),
                            (o[3] = 0),
                            (o[7] = 0),
                            (o[11] = -1),
                            (o[15] = 0),
                            this
                        );
                    }
                    makeOrthographic(t, e, n, i, r, a) {
                        const o = this.elements,
                            s = 1 / (e - t),
                            l = 1 / (n - i),
                            c = 1 / (a - r),
                            u = (e + t) * s,
                            h = (n + i) * l,
                            d = (a + r) * c;
                        return (
                            (o[0] = 2 * s),
                            (o[4] = 0),
                            (o[8] = 0),
                            (o[12] = -u),
                            (o[1] = 0),
                            (o[5] = 2 * l),
                            (o[9] = 0),
                            (o[13] = -h),
                            (o[2] = 0),
                            (o[6] = 0),
                            (o[10] = -2 * c),
                            (o[14] = -d),
                            (o[3] = 0),
                            (o[7] = 0),
                            (o[11] = 0),
                            (o[15] = 1),
                            this
                        );
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 16; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0;
                    }
                    fromArray(t, e = 0) {
                        for (let n = 0; n < 16; n++)
                            this.elements[n] = t[n + e];
                        return this;
                    }
                    toArray(t = [], e = 0) {
                        const n = this.elements;
                        return (
                            (t[e] = n[0]),
                            (t[e + 1] = n[1]),
                            (t[e + 2] = n[2]),
                            (t[e + 3] = n[3]),
                            (t[e + 4] = n[4]),
                            (t[e + 5] = n[5]),
                            (t[e + 6] = n[6]),
                            (t[e + 7] = n[7]),
                            (t[e + 8] = n[8]),
                            (t[e + 9] = n[9]),
                            (t[e + 10] = n[10]),
                            (t[e + 11] = n[11]),
                            (t[e + 12] = n[12]),
                            (t[e + 13] = n[13]),
                            (t[e + 14] = n[14]),
                            (t[e + 15] = n[15]),
                            t
                        );
                    }
                }
                const ne = new Tt(),
                    ie = new ee(),
                    re = new Tt(0, 0, 0),
                    ae = new Tt(1, 1, 1),
                    oe = new Tt(),
                    se = new Tt(),
                    le = new Tt(),
                    ce = new ee(),
                    ue = new St();
                class he {
                    constructor(t = 0, e = 0, n = 0, i = he.DEFAULT_ORDER) {
                        (this.isEuler = !0),
                            (this._x = t),
                            (this._y = e),
                            (this._z = n),
                            (this._order = i);
                    }
                    get x() {
                        return this._x;
                    }
                    set x(t) {
                        (this._x = t), this._onChangeCallback();
                    }
                    get y() {
                        return this._y;
                    }
                    set y(t) {
                        (this._y = t), this._onChangeCallback();
                    }
                    get z() {
                        return this._z;
                    }
                    set z(t) {
                        (this._z = t), this._onChangeCallback();
                    }
                    get order() {
                        return this._order;
                    }
                    set order(t) {
                        (this._order = t), this._onChangeCallback();
                    }
                    set(t, e, n, i = this._order) {
                        return (
                            (this._x = t),
                            (this._y = e),
                            (this._z = n),
                            (this._order = i),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor(
                            this._x,
                            this._y,
                            this._z,
                            this._order
                        );
                    }
                    copy(t) {
                        return (
                            (this._x = t._x),
                            (this._y = t._y),
                            (this._z = t._z),
                            (this._order = t._order),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    setFromRotationMatrix(t, e = this._order, n = !0) {
                        const i = t.elements,
                            r = i[0],
                            a = i[4],
                            o = i[8],
                            s = i[1],
                            l = i[5],
                            c = i[9],
                            u = i[2],
                            h = i[6],
                            d = i[10];
                        switch (e) {
                            case 'XYZ':
                                (this._y = Math.asin(q(o, -1, 1))),
                                    Math.abs(o) < 0.9999999
                                        ? ((this._x = Math.atan2(-c, d)),
                                          (this._z = Math.atan2(-a, r)))
                                        : ((this._x = Math.atan2(h, l)),
                                          (this._z = 0));
                                break;
                            case 'YXZ':
                                (this._x = Math.asin(-q(c, -1, 1))),
                                    Math.abs(c) < 0.9999999
                                        ? ((this._y = Math.atan2(o, d)),
                                          (this._z = Math.atan2(s, l)))
                                        : ((this._y = Math.atan2(-u, r)),
                                          (this._z = 0));
                                break;
                            case 'ZXY':
                                (this._x = Math.asin(q(h, -1, 1))),
                                    Math.abs(h) < 0.9999999
                                        ? ((this._y = Math.atan2(-u, d)),
                                          (this._z = Math.atan2(-a, l)))
                                        : ((this._y = 0),
                                          (this._z = Math.atan2(s, r)));
                                break;
                            case 'ZYX':
                                (this._y = Math.asin(-q(u, -1, 1))),
                                    Math.abs(u) < 0.9999999
                                        ? ((this._x = Math.atan2(h, d)),
                                          (this._z = Math.atan2(s, r)))
                                        : ((this._x = 0),
                                          (this._z = Math.atan2(-a, l)));
                                break;
                            case 'YZX':
                                (this._z = Math.asin(q(s, -1, 1))),
                                    Math.abs(s) < 0.9999999
                                        ? ((this._x = Math.atan2(-c, l)),
                                          (this._y = Math.atan2(-u, r)))
                                        : ((this._x = 0),
                                          (this._y = Math.atan2(o, d)));
                                break;
                            case 'XZY':
                                (this._z = Math.asin(-q(a, -1, 1))),
                                    Math.abs(a) < 0.9999999
                                        ? ((this._x = Math.atan2(h, l)),
                                          (this._y = Math.atan2(o, r)))
                                        : ((this._x = Math.atan2(-c, d)),
                                          (this._y = 0));
                                break;
                            default:
                                console.warn(
                                    'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
                                        e
                                );
                        }
                        return (
                            (this._order = e),
                            !0 === n && this._onChangeCallback(),
                            this
                        );
                    }
                    setFromQuaternion(t, e, n) {
                        return (
                            ce.makeRotationFromQuaternion(t),
                            this.setFromRotationMatrix(ce, e, n)
                        );
                    }
                    setFromVector3(t, e = this._order) {
                        return this.set(t.x, t.y, t.z, e);
                    }
                    reorder(t) {
                        return (
                            ue.setFromEuler(this), this.setFromQuaternion(ue, t)
                        );
                    }
                    equals(t) {
                        return (
                            t._x === this._x &&
                            t._y === this._y &&
                            t._z === this._z &&
                            t._order === this._order
                        );
                    }
                    fromArray(t) {
                        return (
                            (this._x = t[0]),
                            (this._y = t[1]),
                            (this._z = t[2]),
                            void 0 !== t[3] && (this._order = t[3]),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this._x),
                            (t[e + 1] = this._y),
                            (t[e + 2] = this._z),
                            (t[e + 3] = this._order),
                            t
                        );
                    }
                    _onChange(t) {
                        return (this._onChangeCallback = t), this;
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                            yield this._y,
                            yield this._z,
                            yield this._order;
                    }
                }
                he.DEFAULT_ORDER = 'XYZ';
                class de {
                    constructor() {
                        this.mask = 1;
                    }
                    set(t) {
                        this.mask = ((1 << t) | 0) >>> 0;
                    }
                    enable(t) {
                        this.mask |= (1 << t) | 0;
                    }
                    enableAll() {
                        this.mask = -1;
                    }
                    toggle(t) {
                        this.mask ^= (1 << t) | 0;
                    }
                    disable(t) {
                        this.mask &= ~((1 << t) | 0);
                    }
                    disableAll() {
                        this.mask = 0;
                    }
                    test(t) {
                        return 0 != (this.mask & t.mask);
                    }
                    isEnabled(t) {
                        return 0 != (this.mask & ((1 << t) | 0));
                    }
                }
                let pe = 0;
                const fe = new Tt(),
                    me = new St(),
                    ge = new ee(),
                    ve = new Tt(),
                    _e = new Tt(),
                    xe = new Tt(),
                    ye = new St(),
                    Me = new Tt(1, 0, 0),
                    be = new Tt(0, 1, 0),
                    Ee = new Tt(0, 0, 1),
                    Se = { type: 'added' },
                    Te = { type: 'removed' };
                class we extends V {
                    constructor() {
                        super(),
                            (this.isObject3D = !0),
                            Object.defineProperty(this, 'id', { value: pe++ }),
                            (this.uuid = Y()),
                            (this.name = ''),
                            (this.type = 'Object3D'),
                            (this.parent = null),
                            (this.children = []),
                            (this.up = we.DEFAULT_UP.clone());
                        const t = new Tt(),
                            e = new he(),
                            n = new St(),
                            i = new Tt(1, 1, 1);
                        e._onChange(function () {
                            n.setFromEuler(e, !1);
                        }),
                            n._onChange(function () {
                                e.setFromQuaternion(n, void 0, !1);
                            }),
                            Object.defineProperties(this, {
                                position: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: t,
                                },
                                rotation: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: e,
                                },
                                quaternion: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: n,
                                },
                                scale: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: i,
                                },
                                modelViewMatrix: { value: new ee() },
                                normalMatrix: { value: new et() },
                            }),
                            (this.matrix = new ee()),
                            (this.matrixWorld = new ee()),
                            (this.matrixAutoUpdate =
                                we.DEFAULT_MATRIX_AUTO_UPDATE),
                            (this.matrixWorldNeedsUpdate = !1),
                            (this.matrixWorldAutoUpdate =
                                we.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
                            (this.layers = new de()),
                            (this.visible = !0),
                            (this.castShadow = !1),
                            (this.receiveShadow = !1),
                            (this.frustumCulled = !0),
                            (this.renderOrder = 0),
                            (this.animations = []),
                            (this.userData = {});
                    }
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                            this.matrix.premultiply(t),
                            this.matrix.decompose(
                                this.position,
                                this.quaternion,
                                this.scale
                            );
                    }
                    applyQuaternion(t) {
                        return this.quaternion.premultiply(t), this;
                    }
                    setRotationFromAxisAngle(t, e) {
                        this.quaternion.setFromAxisAngle(t, e);
                    }
                    setRotationFromEuler(t) {
                        this.quaternion.setFromEuler(t, !0);
                    }
                    setRotationFromMatrix(t) {
                        this.quaternion.setFromRotationMatrix(t);
                    }
                    setRotationFromQuaternion(t) {
                        this.quaternion.copy(t);
                    }
                    rotateOnAxis(t, e) {
                        return (
                            me.setFromAxisAngle(t, e),
                            this.quaternion.multiply(me),
                            this
                        );
                    }
                    rotateOnWorldAxis(t, e) {
                        return (
                            me.setFromAxisAngle(t, e),
                            this.quaternion.premultiply(me),
                            this
                        );
                    }
                    rotateX(t) {
                        return this.rotateOnAxis(Me, t);
                    }
                    rotateY(t) {
                        return this.rotateOnAxis(be, t);
                    }
                    rotateZ(t) {
                        return this.rotateOnAxis(Ee, t);
                    }
                    translateOnAxis(t, e) {
                        return (
                            fe.copy(t).applyQuaternion(this.quaternion),
                            this.position.add(fe.multiplyScalar(e)),
                            this
                        );
                    }
                    translateX(t) {
                        return this.translateOnAxis(Me, t);
                    }
                    translateY(t) {
                        return this.translateOnAxis(be, t);
                    }
                    translateZ(t) {
                        return this.translateOnAxis(Ee, t);
                    }
                    localToWorld(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            t.applyMatrix4(this.matrixWorld)
                        );
                    }
                    worldToLocal(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            t.applyMatrix4(ge.copy(this.matrixWorld).invert())
                        );
                    }
                    lookAt(t, e, n) {
                        t.isVector3 ? ve.copy(t) : ve.set(t, e, n);
                        const i = this.parent;
                        this.updateWorldMatrix(!0, !1),
                            _e.setFromMatrixPosition(this.matrixWorld),
                            this.isCamera || this.isLight
                                ? ge.lookAt(_e, ve, this.up)
                                : ge.lookAt(ve, _e, this.up),
                            this.quaternion.setFromRotationMatrix(ge),
                            i &&
                                (ge.extractRotation(i.matrixWorld),
                                me.setFromRotationMatrix(ge),
                                this.quaternion.premultiply(me.invert()));
                    }
                    add(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++)
                                this.add(arguments[t]);
                            return this;
                        }
                        return t === this
                            ? (console.error(
                                  "THREE.Object3D.add: object can't be added as a child of itself.",
                                  t
                              ),
                              this)
                            : (t && t.isObject3D
                                  ? (null !== t.parent && t.parent.remove(t),
                                    (t.parent = this),
                                    this.children.push(t),
                                    t.dispatchEvent(Se))
                                  : console.error(
                                        'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                                        t
                                    ),
                              this);
                    }
                    remove(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++)
                                this.remove(arguments[t]);
                            return this;
                        }
                        const e = this.children.indexOf(t);
                        return (
                            -1 !== e &&
                                ((t.parent = null),
                                this.children.splice(e, 1),
                                t.dispatchEvent(Te)),
                            this
                        );
                    }
                    removeFromParent() {
                        const t = this.parent;
                        return null !== t && t.remove(this), this;
                    }
                    clear() {
                        for (let t = 0; t < this.children.length; t++) {
                            const e = this.children[t];
                            (e.parent = null), e.dispatchEvent(Te);
                        }
                        return (this.children.length = 0), this;
                    }
                    attach(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            ge.copy(this.matrixWorld).invert(),
                            null !== t.parent &&
                                (t.parent.updateWorldMatrix(!0, !1),
                                ge.multiply(t.parent.matrixWorld)),
                            t.applyMatrix4(ge),
                            this.add(t),
                            t.updateWorldMatrix(!1, !0),
                            this
                        );
                    }
                    getObjectById(t) {
                        return this.getObjectByProperty('id', t);
                    }
                    getObjectByName(t) {
                        return this.getObjectByProperty('name', t);
                    }
                    getObjectByProperty(t, e) {
                        if (this[t] === e) return this;
                        for (let n = 0, i = this.children.length; n < i; n++) {
                            const i = this.children[n].getObjectByProperty(
                                t,
                                e
                            );
                            if (void 0 !== i) return i;
                        }
                    }
                    getObjectsByProperty(t, e) {
                        let n = [];
                        this[t] === e && n.push(this);
                        for (let i = 0, r = this.children.length; i < r; i++) {
                            const r = this.children[i].getObjectsByProperty(
                                t,
                                e
                            );
                            r.length > 0 && (n = n.concat(r));
                        }
                        return n;
                    }
                    getWorldPosition(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            t.setFromMatrixPosition(this.matrixWorld)
                        );
                    }
                    getWorldQuaternion(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            this.matrixWorld.decompose(_e, t, xe),
                            t
                        );
                    }
                    getWorldScale(t) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            this.matrixWorld.decompose(_e, ye, t),
                            t
                        );
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return t.set(e[8], e[9], e[10]).normalize();
                    }
                    raycast() {}
                    traverse(t) {
                        t(this);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++)
                            e[n].traverse(t);
                    }
                    traverseVisible(t) {
                        if (!1 === this.visible) return;
                        t(this);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++)
                            e[n].traverseVisible(t);
                    }
                    traverseAncestors(t) {
                        const e = this.parent;
                        null !== e && (t(e), e.traverseAncestors(t));
                    }
                    updateMatrix() {
                        this.matrix.compose(
                            this.position,
                            this.quaternion,
                            this.scale
                        ),
                            (this.matrixWorldNeedsUpdate = !0);
                    }
                    updateMatrixWorld(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                            (this.matrixWorldNeedsUpdate || t) &&
                                (null === this.parent
                                    ? this.matrixWorld.copy(this.matrix)
                                    : this.matrixWorld.multiplyMatrices(
                                          this.parent.matrixWorld,
                                          this.matrix
                                      ),
                                (this.matrixWorldNeedsUpdate = !1),
                                (t = !0));
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n];
                            (!0 !== i.matrixWorldAutoUpdate && !0 !== t) ||
                                i.updateMatrixWorld(t);
                        }
                    }
                    updateWorldMatrix(t, e) {
                        const n = this.parent;
                        if (
                            (!0 === t &&
                                null !== n &&
                                !0 === n.matrixWorldAutoUpdate &&
                                n.updateWorldMatrix(!0, !1),
                            this.matrixAutoUpdate && this.updateMatrix(),
                            null === this.parent
                                ? this.matrixWorld.copy(this.matrix)
                                : this.matrixWorld.multiplyMatrices(
                                      this.parent.matrixWorld,
                                      this.matrix
                                  ),
                            !0 === e)
                        ) {
                            const t = this.children;
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                !0 === n.matrixWorldAutoUpdate &&
                                    n.updateWorldMatrix(!1, !0);
                            }
                        }
                    }
                    toJSON(t) {
                        const e = void 0 === t || 'string' == typeof t,
                            n = {};
                        e &&
                            ((t = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                                nodes: {},
                            }),
                            (n.metadata = {
                                version: 4.5,
                                type: 'Object',
                                generator: 'Object3D.toJSON',
                            }));
                        const i = {};
                        function r(e, n) {
                            return (
                                void 0 === e[n.uuid] &&
                                    (e[n.uuid] = n.toJSON(t)),
                                n.uuid
                            );
                        }
                        if (
                            ((i.uuid = this.uuid),
                            (i.type = this.type),
                            '' !== this.name && (i.name = this.name),
                            !0 === this.castShadow && (i.castShadow = !0),
                            !0 === this.receiveShadow && (i.receiveShadow = !0),
                            !1 === this.visible && (i.visible = !1),
                            !1 === this.frustumCulled && (i.frustumCulled = !1),
                            0 !== this.renderOrder &&
                                (i.renderOrder = this.renderOrder),
                            Object.keys(this.userData).length > 0 &&
                                (i.userData = this.userData),
                            (i.layers = this.layers.mask),
                            (i.matrix = this.matrix.toArray()),
                            (i.up = this.up.toArray()),
                            !1 === this.matrixAutoUpdate &&
                                (i.matrixAutoUpdate = !1),
                            this.isInstancedMesh &&
                                ((i.type = 'InstancedMesh'),
                                (i.count = this.count),
                                (i.instanceMatrix =
                                    this.instanceMatrix.toJSON()),
                                null !== this.instanceColor &&
                                    (i.instanceColor =
                                        this.instanceColor.toJSON())),
                            this.isScene)
                        )
                            this.background &&
                                (this.background.isColor
                                    ? (i.background = this.background.toJSON())
                                    : this.background.isTexture &&
                                      (i.background =
                                          this.background.toJSON(t).uuid)),
                                this.environment &&
                                    this.environment.isTexture &&
                                    !0 !==
                                        this.environment
                                            .isRenderTargetTexture &&
                                    (i.environment =
                                        this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            i.geometry = r(t.geometries, this.geometry);
                            const e = this.geometry.parameters;
                            if (void 0 !== e && void 0 !== e.shapes) {
                                const n = e.shapes;
                                if (Array.isArray(n))
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = n[e];
                                        r(t.shapes, i);
                                    }
                                else r(t.shapes, n);
                            }
                        }
                        if (
                            (this.isSkinnedMesh &&
                                ((i.bindMode = this.bindMode),
                                (i.bindMatrix = this.bindMatrix.toArray()),
                                void 0 !== this.skeleton &&
                                    (r(t.skeletons, this.skeleton),
                                    (i.skeleton = this.skeleton.uuid))),
                            void 0 !== this.material)
                        )
                            if (Array.isArray(this.material)) {
                                const e = [];
                                for (
                                    let n = 0, i = this.material.length;
                                    n < i;
                                    n++
                                )
                                    e.push(r(t.materials, this.material[n]));
                                i.material = e;
                            } else i.material = r(t.materials, this.material);
                        if (this.children.length > 0) {
                            i.children = [];
                            for (let e = 0; e < this.children.length; e++)
                                i.children.push(
                                    this.children[e].toJSON(t).object
                                );
                        }
                        if (this.animations.length > 0) {
                            i.animations = [];
                            for (let e = 0; e < this.animations.length; e++) {
                                const n = this.animations[e];
                                i.animations.push(r(t.animations, n));
                            }
                        }
                        if (e) {
                            const e = a(t.geometries),
                                i = a(t.materials),
                                r = a(t.textures),
                                o = a(t.images),
                                s = a(t.shapes),
                                l = a(t.skeletons),
                                c = a(t.animations),
                                u = a(t.nodes);
                            e.length > 0 && (n.geometries = e),
                                i.length > 0 && (n.materials = i),
                                r.length > 0 && (n.textures = r),
                                o.length > 0 && (n.images = o),
                                s.length > 0 && (n.shapes = s),
                                l.length > 0 && (n.skeletons = l),
                                c.length > 0 && (n.animations = c),
                                u.length > 0 && (n.nodes = u);
                        }
                        return (n.object = i), n;
                        function a(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i);
                            }
                            return e;
                        }
                    }
                    clone(t) {
                        return new this.constructor().copy(this, t);
                    }
                    copy(t, e = !0) {
                        if (
                            ((this.name = t.name),
                            this.up.copy(t.up),
                            this.position.copy(t.position),
                            (this.rotation.order = t.rotation.order),
                            this.quaternion.copy(t.quaternion),
                            this.scale.copy(t.scale),
                            this.matrix.copy(t.matrix),
                            this.matrixWorld.copy(t.matrixWorld),
                            (this.matrixAutoUpdate = t.matrixAutoUpdate),
                            (this.matrixWorldNeedsUpdate =
                                t.matrixWorldNeedsUpdate),
                            (this.matrixWorldAutoUpdate =
                                t.matrixWorldAutoUpdate),
                            (this.layers.mask = t.layers.mask),
                            (this.visible = t.visible),
                            (this.castShadow = t.castShadow),
                            (this.receiveShadow = t.receiveShadow),
                            (this.frustumCulled = t.frustumCulled),
                            (this.renderOrder = t.renderOrder),
                            (this.animations = t.animations),
                            (this.userData = JSON.parse(
                                JSON.stringify(t.userData)
                            )),
                            !0 === e)
                        )
                            for (let e = 0; e < t.children.length; e++) {
                                const n = t.children[e];
                                this.add(n.clone());
                            }
                        return this;
                    }
                }
                (we.DEFAULT_UP = new Tt(0, 1, 0)),
                    (we.DEFAULT_MATRIX_AUTO_UPDATE = !0),
                    (we.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
                const Ae = new Tt(),
                    Ce = new Tt(),
                    Re = new Tt(),
                    Le = new Tt(),
                    Pe = new Tt(),
                    De = new Tt(),
                    Ie = new Tt(),
                    Ue = new Tt(),
                    Oe = new Tt(),
                    Ne = new Tt();
                let Fe = !1;
                class ze {
                    constructor(t = new Tt(), e = new Tt(), n = new Tt()) {
                        (this.a = t), (this.b = e), (this.c = n);
                    }
                    static getNormal(t, e, n, i) {
                        i.subVectors(n, e), Ae.subVectors(t, e), i.cross(Ae);
                        const r = i.lengthSq();
                        return r > 0
                            ? i.multiplyScalar(1 / Math.sqrt(r))
                            : i.set(0, 0, 0);
                    }
                    static getBarycoord(t, e, n, i, r) {
                        Ae.subVectors(i, e),
                            Ce.subVectors(n, e),
                            Re.subVectors(t, e);
                        const a = Ae.dot(Ae),
                            o = Ae.dot(Ce),
                            s = Ae.dot(Re),
                            l = Ce.dot(Ce),
                            c = Ce.dot(Re),
                            u = a * l - o * o;
                        if (0 === u) return r.set(-2, -1, -1);
                        const h = 1 / u,
                            d = (l * s - o * c) * h,
                            p = (a * c - o * s) * h;
                        return r.set(1 - d - p, p, d);
                    }
                    static containsPoint(t, e, n, i) {
                        return (
                            this.getBarycoord(t, e, n, i, Le),
                            Le.x >= 0 && Le.y >= 0 && Le.x + Le.y <= 1
                        );
                    }
                    static getUV(t, e, n, i, r, a, o, s) {
                        return (
                            !1 === Fe &&
                                (console.warn(
                                    'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().'
                                ),
                                (Fe = !0)),
                            this.getInterpolation(t, e, n, i, r, a, o, s)
                        );
                    }
                    static getInterpolation(t, e, n, i, r, a, o, s) {
                        return (
                            this.getBarycoord(t, e, n, i, Le),
                            s.setScalar(0),
                            s.addScaledVector(r, Le.x),
                            s.addScaledVector(a, Le.y),
                            s.addScaledVector(o, Le.z),
                            s
                        );
                    }
                    static isFrontFacing(t, e, n, i) {
                        return (
                            Ae.subVectors(n, e),
                            Ce.subVectors(t, e),
                            Ae.cross(Ce).dot(i) < 0
                        );
                    }
                    set(t, e, n) {
                        return (
                            this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                        );
                    }
                    setFromPointsAndIndices(t, e, n, i) {
                        return (
                            this.a.copy(t[e]),
                            this.b.copy(t[n]),
                            this.c.copy(t[i]),
                            this
                        );
                    }
                    setFromAttributeAndIndices(t, e, n, i) {
                        return (
                            this.a.fromBufferAttribute(t, e),
                            this.b.fromBufferAttribute(t, n),
                            this.c.fromBufferAttribute(t, i),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        return (
                            this.a.copy(t.a),
                            this.b.copy(t.b),
                            this.c.copy(t.c),
                            this
                        );
                    }
                    getArea() {
                        return (
                            Ae.subVectors(this.c, this.b),
                            Ce.subVectors(this.a, this.b),
                            0.5 * Ae.cross(Ce).length()
                        );
                    }
                    getMidpoint(t) {
                        return t
                            .addVectors(this.a, this.b)
                            .add(this.c)
                            .multiplyScalar(1 / 3);
                    }
                    getNormal(t) {
                        return ze.getNormal(this.a, this.b, this.c, t);
                    }
                    getPlane(t) {
                        return t.setFromCoplanarPoints(this.a, this.b, this.c);
                    }
                    getBarycoord(t, e) {
                        return ze.getBarycoord(t, this.a, this.b, this.c, e);
                    }
                    getUV(t, e, n, i, r) {
                        return (
                            !1 === Fe &&
                                (console.warn(
                                    'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().'
                                ),
                                (Fe = !0)),
                            ze.getInterpolation(
                                t,
                                this.a,
                                this.b,
                                this.c,
                                e,
                                n,
                                i,
                                r
                            )
                        );
                    }
                    getInterpolation(t, e, n, i, r) {
                        return ze.getInterpolation(
                            t,
                            this.a,
                            this.b,
                            this.c,
                            e,
                            n,
                            i,
                            r
                        );
                    }
                    containsPoint(t) {
                        return ze.containsPoint(t, this.a, this.b, this.c);
                    }
                    isFrontFacing(t) {
                        return ze.isFrontFacing(this.a, this.b, this.c, t);
                    }
                    intersectsBox(t) {
                        return t.intersectsTriangle(this);
                    }
                    closestPointToPoint(t, e) {
                        const n = this.a,
                            i = this.b,
                            r = this.c;
                        let a, o;
                        Pe.subVectors(i, n),
                            De.subVectors(r, n),
                            Ue.subVectors(t, n);
                        const s = Pe.dot(Ue),
                            l = De.dot(Ue);
                        if (s <= 0 && l <= 0) return e.copy(n);
                        Oe.subVectors(t, i);
                        const c = Pe.dot(Oe),
                            u = De.dot(Oe);
                        if (c >= 0 && u <= c) return e.copy(i);
                        const h = s * u - c * l;
                        if (h <= 0 && s >= 0 && c <= 0)
                            return (
                                (a = s / (s - c)),
                                e.copy(n).addScaledVector(Pe, a)
                            );
                        Ne.subVectors(t, r);
                        const d = Pe.dot(Ne),
                            p = De.dot(Ne);
                        if (p >= 0 && d <= p) return e.copy(r);
                        const f = d * l - s * p;
                        if (f <= 0 && l >= 0 && p <= 0)
                            return (
                                (o = l / (l - p)),
                                e.copy(n).addScaledVector(De, o)
                            );
                        const m = c * p - d * u;
                        if (m <= 0 && u - c >= 0 && d - p >= 0)
                            return (
                                Ie.subVectors(r, i),
                                (o = (u - c) / (u - c + (d - p))),
                                e.copy(i).addScaledVector(Ie, o)
                            );
                        const g = 1 / (m + f + h);
                        return (
                            (a = f * g),
                            (o = h * g),
                            e
                                .copy(n)
                                .addScaledVector(Pe, a)
                                .addScaledVector(De, o)
                        );
                    }
                    equals(t) {
                        return (
                            t.a.equals(this.a) &&
                            t.b.equals(this.b) &&
                            t.c.equals(this.c)
                        );
                    }
                }
                let Be = 0;
                class ke extends V {
                    constructor() {
                        super(),
                            (this.isMaterial = !0),
                            Object.defineProperty(this, 'id', { value: Be++ }),
                            (this.uuid = Y()),
                            (this.name = ''),
                            (this.type = 'Material'),
                            (this.blending = 1),
                            (this.side = 0),
                            (this.vertexColors = !1),
                            (this.opacity = 1),
                            (this.transparent = !1),
                            (this.blendSrc = 204),
                            (this.blendDst = 205),
                            (this.blendEquation = l),
                            (this.blendSrcAlpha = null),
                            (this.blendDstAlpha = null),
                            (this.blendEquationAlpha = null),
                            (this.depthFunc = 3),
                            (this.depthTest = !0),
                            (this.depthWrite = !0),
                            (this.stencilWriteMask = 255),
                            (this.stencilFunc = 519),
                            (this.stencilRef = 0),
                            (this.stencilFuncMask = 255),
                            (this.stencilFail = k),
                            (this.stencilZFail = k),
                            (this.stencilZPass = k),
                            (this.stencilWrite = !1),
                            (this.clippingPlanes = null),
                            (this.clipIntersection = !1),
                            (this.clipShadows = !1),
                            (this.shadowSide = null),
                            (this.colorWrite = !0),
                            (this.precision = null),
                            (this.polygonOffset = !1),
                            (this.polygonOffsetFactor = 0),
                            (this.polygonOffsetUnits = 0),
                            (this.dithering = !1),
                            (this.alphaToCoverage = !1),
                            (this.premultipliedAlpha = !1),
                            (this.forceSinglePass = !1),
                            (this.visible = !0),
                            (this.toneMapped = !0),
                            (this.userData = {}),
                            (this.version = 0),
                            (this._alphaTest = 0);
                    }
                    get alphaTest() {
                        return this._alphaTest;
                    }
                    set alphaTest(t) {
                        this._alphaTest > 0 != t > 0 && this.version++,
                            (this._alphaTest = t);
                    }
                    onBuild() {}
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString();
                    }
                    setValues(t) {
                        if (void 0 !== t)
                            for (const e in t) {
                                const n = t[e];
                                if (void 0 === n) {
                                    console.warn(
                                        `THREE.Material: parameter '${e}' has value of undefined.`
                                    );
                                    continue;
                                }
                                const i = this[e];
                                void 0 !== i
                                    ? i && i.isColor
                                        ? i.set(n)
                                        : i && i.isVector3 && n && n.isVector3
                                          ? i.copy(n)
                                          : (this[e] = n)
                                    : console.warn(
                                          `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
                                      );
                            }
                    }
                    toJSON(t) {
                        const e = void 0 === t || 'string' == typeof t;
                        e && (t = { textures: {}, images: {} });
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: 'Material',
                                generator: 'Material.toJSON',
                            },
                        };
                        function i(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i);
                            }
                            return e;
                        }
                        if (
                            ((n.uuid = this.uuid),
                            (n.type = this.type),
                            '' !== this.name && (n.name = this.name),
                            this.color &&
                                this.color.isColor &&
                                (n.color = this.color.getHex()),
                            void 0 !== this.roughness &&
                                (n.roughness = this.roughness),
                            void 0 !== this.metalness &&
                                (n.metalness = this.metalness),
                            void 0 !== this.sheen && (n.sheen = this.sheen),
                            this.sheenColor &&
                                this.sheenColor.isColor &&
                                (n.sheenColor = this.sheenColor.getHex()),
                            void 0 !== this.sheenRoughness &&
                                (n.sheenRoughness = this.sheenRoughness),
                            this.emissive &&
                                this.emissive.isColor &&
                                (n.emissive = this.emissive.getHex()),
                            this.emissiveIntensity &&
                                1 !== this.emissiveIntensity &&
                                (n.emissiveIntensity = this.emissiveIntensity),
                            this.specular &&
                                this.specular.isColor &&
                                (n.specular = this.specular.getHex()),
                            void 0 !== this.specularIntensity &&
                                (n.specularIntensity = this.specularIntensity),
                            this.specularColor &&
                                this.specularColor.isColor &&
                                (n.specularColor = this.specularColor.getHex()),
                            void 0 !== this.shininess &&
                                (n.shininess = this.shininess),
                            void 0 !== this.clearcoat &&
                                (n.clearcoat = this.clearcoat),
                            void 0 !== this.clearcoatRoughness &&
                                (n.clearcoatRoughness =
                                    this.clearcoatRoughness),
                            this.clearcoatMap &&
                                this.clearcoatMap.isTexture &&
                                (n.clearcoatMap =
                                    this.clearcoatMap.toJSON(t).uuid),
                            this.clearcoatRoughnessMap &&
                                this.clearcoatRoughnessMap.isTexture &&
                                (n.clearcoatRoughnessMap =
                                    this.clearcoatRoughnessMap.toJSON(t).uuid),
                            this.clearcoatNormalMap &&
                                this.clearcoatNormalMap.isTexture &&
                                ((n.clearcoatNormalMap =
                                    this.clearcoatNormalMap.toJSON(t).uuid),
                                (n.clearcoatNormalScale =
                                    this.clearcoatNormalScale.toArray())),
                            void 0 !== this.iridescence &&
                                (n.iridescence = this.iridescence),
                            void 0 !== this.iridescenceIOR &&
                                (n.iridescenceIOR = this.iridescenceIOR),
                            void 0 !== this.iridescenceThicknessRange &&
                                (n.iridescenceThicknessRange =
                                    this.iridescenceThicknessRange),
                            this.iridescenceMap &&
                                this.iridescenceMap.isTexture &&
                                (n.iridescenceMap =
                                    this.iridescenceMap.toJSON(t).uuid),
                            this.iridescenceThicknessMap &&
                                this.iridescenceThicknessMap.isTexture &&
                                (n.iridescenceThicknessMap =
                                    this.iridescenceThicknessMap.toJSON(
                                        t
                                    ).uuid),
                            this.map &&
                                this.map.isTexture &&
                                (n.map = this.map.toJSON(t).uuid),
                            this.matcap &&
                                this.matcap.isTexture &&
                                (n.matcap = this.matcap.toJSON(t).uuid),
                            this.alphaMap &&
                                this.alphaMap.isTexture &&
                                (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                            this.lightMap &&
                                this.lightMap.isTexture &&
                                ((n.lightMap = this.lightMap.toJSON(t).uuid),
                                (n.lightMapIntensity = this.lightMapIntensity)),
                            this.aoMap &&
                                this.aoMap.isTexture &&
                                ((n.aoMap = this.aoMap.toJSON(t).uuid),
                                (n.aoMapIntensity = this.aoMapIntensity)),
                            this.bumpMap &&
                                this.bumpMap.isTexture &&
                                ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
                                (n.bumpScale = this.bumpScale)),
                            this.normalMap &&
                                this.normalMap.isTexture &&
                                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                                (n.normalMapType = this.normalMapType),
                                (n.normalScale = this.normalScale.toArray())),
                            this.displacementMap &&
                                this.displacementMap.isTexture &&
                                ((n.displacementMap =
                                    this.displacementMap.toJSON(t).uuid),
                                (n.displacementScale = this.displacementScale),
                                (n.displacementBias = this.displacementBias)),
                            this.roughnessMap &&
                                this.roughnessMap.isTexture &&
                                (n.roughnessMap =
                                    this.roughnessMap.toJSON(t).uuid),
                            this.metalnessMap &&
                                this.metalnessMap.isTexture &&
                                (n.metalnessMap =
                                    this.metalnessMap.toJSON(t).uuid),
                            this.emissiveMap &&
                                this.emissiveMap.isTexture &&
                                (n.emissiveMap =
                                    this.emissiveMap.toJSON(t).uuid),
                            this.specularMap &&
                                this.specularMap.isTexture &&
                                (n.specularMap =
                                    this.specularMap.toJSON(t).uuid),
                            this.specularIntensityMap &&
                                this.specularIntensityMap.isTexture &&
                                (n.specularIntensityMap =
                                    this.specularIntensityMap.toJSON(t).uuid),
                            this.specularColorMap &&
                                this.specularColorMap.isTexture &&
                                (n.specularColorMap =
                                    this.specularColorMap.toJSON(t).uuid),
                            this.envMap &&
                                this.envMap.isTexture &&
                                ((n.envMap = this.envMap.toJSON(t).uuid),
                                void 0 !== this.combine &&
                                    (n.combine = this.combine)),
                            void 0 !== this.envMapIntensity &&
                                (n.envMapIntensity = this.envMapIntensity),
                            void 0 !== this.reflectivity &&
                                (n.reflectivity = this.reflectivity),
                            void 0 !== this.refractionRatio &&
                                (n.refractionRatio = this.refractionRatio),
                            this.gradientMap &&
                                this.gradientMap.isTexture &&
                                (n.gradientMap =
                                    this.gradientMap.toJSON(t).uuid),
                            void 0 !== this.transmission &&
                                (n.transmission = this.transmission),
                            this.transmissionMap &&
                                this.transmissionMap.isTexture &&
                                (n.transmissionMap =
                                    this.transmissionMap.toJSON(t).uuid),
                            void 0 !== this.thickness &&
                                (n.thickness = this.thickness),
                            this.thicknessMap &&
                                this.thicknessMap.isTexture &&
                                (n.thicknessMap =
                                    this.thicknessMap.toJSON(t).uuid),
                            void 0 !== this.attenuationDistance &&
                                this.attenuationDistance !== 1 / 0 &&
                                (n.attenuationDistance =
                                    this.attenuationDistance),
                            void 0 !== this.attenuationColor &&
                                (n.attenuationColor =
                                    this.attenuationColor.getHex()),
                            void 0 !== this.size && (n.size = this.size),
                            null !== this.shadowSide &&
                                (n.shadowSide = this.shadowSide),
                            void 0 !== this.sizeAttenuation &&
                                (n.sizeAttenuation = this.sizeAttenuation),
                            1 !== this.blending && (n.blending = this.blending),
                            0 !== this.side && (n.side = this.side),
                            this.vertexColors && (n.vertexColors = !0),
                            this.opacity < 1 && (n.opacity = this.opacity),
                            !0 === this.transparent &&
                                (n.transparent = this.transparent),
                            (n.depthFunc = this.depthFunc),
                            (n.depthTest = this.depthTest),
                            (n.depthWrite = this.depthWrite),
                            (n.colorWrite = this.colorWrite),
                            (n.stencilWrite = this.stencilWrite),
                            (n.stencilWriteMask = this.stencilWriteMask),
                            (n.stencilFunc = this.stencilFunc),
                            (n.stencilRef = this.stencilRef),
                            (n.stencilFuncMask = this.stencilFuncMask),
                            (n.stencilFail = this.stencilFail),
                            (n.stencilZFail = this.stencilZFail),
                            (n.stencilZPass = this.stencilZPass),
                            void 0 !== this.rotation &&
                                0 !== this.rotation &&
                                (n.rotation = this.rotation),
                            !0 === this.polygonOffset && (n.polygonOffset = !0),
                            0 !== this.polygonOffsetFactor &&
                                (n.polygonOffsetFactor =
                                    this.polygonOffsetFactor),
                            0 !== this.polygonOffsetUnits &&
                                (n.polygonOffsetUnits =
                                    this.polygonOffsetUnits),
                            void 0 !== this.linewidth &&
                                1 !== this.linewidth &&
                                (n.linewidth = this.linewidth),
                            void 0 !== this.dashSize &&
                                (n.dashSize = this.dashSize),
                            void 0 !== this.gapSize &&
                                (n.gapSize = this.gapSize),
                            void 0 !== this.scale && (n.scale = this.scale),
                            !0 === this.dithering && (n.dithering = !0),
                            this.alphaTest > 0 &&
                                (n.alphaTest = this.alphaTest),
                            !0 === this.alphaToCoverage &&
                                (n.alphaToCoverage = this.alphaToCoverage),
                            !0 === this.premultipliedAlpha &&
                                (n.premultipliedAlpha =
                                    this.premultipliedAlpha),
                            !0 === this.forceSinglePass &&
                                (n.forceSinglePass = this.forceSinglePass),
                            !0 === this.wireframe &&
                                (n.wireframe = this.wireframe),
                            this.wireframeLinewidth > 1 &&
                                (n.wireframeLinewidth =
                                    this.wireframeLinewidth),
                            'round' !== this.wireframeLinecap &&
                                (n.wireframeLinecap = this.wireframeLinecap),
                            'round' !== this.wireframeLinejoin &&
                                (n.wireframeLinejoin = this.wireframeLinejoin),
                            !0 === this.flatShading &&
                                (n.flatShading = this.flatShading),
                            !1 === this.visible && (n.visible = !1),
                            !1 === this.toneMapped && (n.toneMapped = !1),
                            !1 === this.fog && (n.fog = !1),
                            Object.keys(this.userData).length > 0 &&
                                (n.userData = this.userData),
                            e)
                        ) {
                            const e = i(t.textures),
                                r = i(t.images);
                            e.length > 0 && (n.textures = e),
                                r.length > 0 && (n.images = r);
                        }
                        return n;
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        (this.name = t.name),
                            (this.blending = t.blending),
                            (this.side = t.side),
                            (this.vertexColors = t.vertexColors),
                            (this.opacity = t.opacity),
                            (this.transparent = t.transparent),
                            (this.blendSrc = t.blendSrc),
                            (this.blendDst = t.blendDst),
                            (this.blendEquation = t.blendEquation),
                            (this.blendSrcAlpha = t.blendSrcAlpha),
                            (this.blendDstAlpha = t.blendDstAlpha),
                            (this.blendEquationAlpha = t.blendEquationAlpha),
                            (this.depthFunc = t.depthFunc),
                            (this.depthTest = t.depthTest),
                            (this.depthWrite = t.depthWrite),
                            (this.stencilWriteMask = t.stencilWriteMask),
                            (this.stencilFunc = t.stencilFunc),
                            (this.stencilRef = t.stencilRef),
                            (this.stencilFuncMask = t.stencilFuncMask),
                            (this.stencilFail = t.stencilFail),
                            (this.stencilZFail = t.stencilZFail),
                            (this.stencilZPass = t.stencilZPass),
                            (this.stencilWrite = t.stencilWrite);
                        const e = t.clippingPlanes;
                        let n = null;
                        if (null !== e) {
                            const t = e.length;
                            n = new Array(t);
                            for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
                        }
                        return (
                            (this.clippingPlanes = n),
                            (this.clipIntersection = t.clipIntersection),
                            (this.clipShadows = t.clipShadows),
                            (this.shadowSide = t.shadowSide),
                            (this.colorWrite = t.colorWrite),
                            (this.precision = t.precision),
                            (this.polygonOffset = t.polygonOffset),
                            (this.polygonOffsetFactor = t.polygonOffsetFactor),
                            (this.polygonOffsetUnits = t.polygonOffsetUnits),
                            (this.dithering = t.dithering),
                            (this.alphaTest = t.alphaTest),
                            (this.alphaToCoverage = t.alphaToCoverage),
                            (this.premultipliedAlpha = t.premultipliedAlpha),
                            (this.forceSinglePass = t.forceSinglePass),
                            (this.visible = t.visible),
                            (this.toneMapped = t.toneMapped),
                            (this.userData = JSON.parse(
                                JSON.stringify(t.userData)
                            )),
                            this
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: 'dispose' });
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++;
                    }
                }
                const He = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074,
                    },
                    Ge = { h: 0, s: 0, l: 0 },
                    Ve = { h: 0, s: 0, l: 0 };
                function We(t, e, n) {
                    return (
                        n < 0 && (n += 1),
                        n > 1 && (n -= 1),
                        n < 1 / 6
                            ? t + 6 * (e - t) * n
                            : n < 0.5
                              ? e
                              : n < 2 / 3
                                ? t + 6 * (e - t) * (2 / 3 - n)
                                : t
                    );
                }
                class je {
                    constructor(t, e, n) {
                        return (
                            (this.isColor = !0),
                            (this.r = 1),
                            (this.g = 1),
                            (this.b = 1),
                            void 0 === e && void 0 === n
                                ? this.set(t)
                                : this.setRGB(t, e, n)
                        );
                    }
                    set(t) {
                        return (
                            t && t.isColor
                                ? this.copy(t)
                                : 'number' == typeof t
                                  ? this.setHex(t)
                                  : 'string' == typeof t && this.setStyle(t),
                            this
                        );
                    }
                    setScalar(t) {
                        return (this.r = t), (this.g = t), (this.b = t), this;
                    }
                    setHex(t, e = F) {
                        return (
                            (t = Math.floor(t)),
                            (this.r = ((t >> 16) & 255) / 255),
                            (this.g = ((t >> 8) & 255) / 255),
                            (this.b = (255 & t) / 255),
                            pt.toWorkingColorSpace(this, e),
                            this
                        );
                    }
                    setRGB(t, e, n, i = pt.workingColorSpace) {
                        return (
                            (this.r = t),
                            (this.g = e),
                            (this.b = n),
                            pt.toWorkingColorSpace(this, i),
                            this
                        );
                    }
                    setHSL(t, e, n, i = pt.workingColorSpace) {
                        if (
                            ((t = ((t % (r = 1)) + r) % r),
                            (e = q(e, 0, 1)),
                            (n = q(n, 0, 1)),
                            0 === e)
                        )
                            this.r = this.g = this.b = n;
                        else {
                            const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                                r = 2 * n - i;
                            (this.r = We(r, i, t + 1 / 3)),
                                (this.g = We(r, i, t)),
                                (this.b = We(r, i, t - 1 / 3));
                        }
                        var r;
                        return pt.toWorkingColorSpace(this, i), this;
                    }
                    setStyle(t, e = F) {
                        function n(e) {
                            void 0 !== e &&
                                parseFloat(e) < 1 &&
                                console.warn(
                                    'THREE.Color: Alpha component of ' +
                                        t +
                                        ' will be ignored.'
                                );
                        }
                        let i;
                        if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
                            let r;
                            const a = i[1],
                                o = i[2];
                            switch (a) {
                                case 'rgb':
                                case 'rgba':
                                    if (
                                        (r =
                                            /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                                o
                                            ))
                                    )
                                        return (
                                            n(r[4]),
                                            this.setRGB(
                                                Math.min(
                                                    255,
                                                    parseInt(r[1], 10)
                                                ) / 255,
                                                Math.min(
                                                    255,
                                                    parseInt(r[2], 10)
                                                ) / 255,
                                                Math.min(
                                                    255,
                                                    parseInt(r[3], 10)
                                                ) / 255,
                                                e
                                            )
                                        );
                                    if (
                                        (r =
                                            /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                                o
                                            ))
                                    )
                                        return (
                                            n(r[4]),
                                            this.setRGB(
                                                Math.min(
                                                    100,
                                                    parseInt(r[1], 10)
                                                ) / 100,
                                                Math.min(
                                                    100,
                                                    parseInt(r[2], 10)
                                                ) / 100,
                                                Math.min(
                                                    100,
                                                    parseInt(r[3], 10)
                                                ) / 100,
                                                e
                                            )
                                        );
                                    break;
                                case 'hsl':
                                case 'hsla':
                                    if (
                                        (r =
                                            /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                                o
                                            ))
                                    )
                                        return (
                                            n(r[4]),
                                            this.setHSL(
                                                parseFloat(r[1]) / 360,
                                                parseFloat(r[2]) / 100,
                                                parseFloat(r[3]) / 100,
                                                e
                                            )
                                        );
                                    break;
                                default:
                                    console.warn(
                                        'THREE.Color: Unknown color model ' + t
                                    );
                            }
                        } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
                            const n = i[1],
                                r = n.length;
                            if (3 === r)
                                return this.setRGB(
                                    parseInt(n.charAt(0), 16) / 15,
                                    parseInt(n.charAt(1), 16) / 15,
                                    parseInt(n.charAt(2), 16) / 15,
                                    e
                                );
                            if (6 === r) return this.setHex(parseInt(n, 16), e);
                            console.warn('THREE.Color: Invalid hex color ' + t);
                        } else if (t && t.length > 0)
                            return this.setColorName(t, e);
                        return this;
                    }
                    setColorName(t, e = F) {
                        const n = He[t.toLowerCase()];
                        return (
                            void 0 !== n
                                ? this.setHex(n, e)
                                : console.warn(
                                      'THREE.Color: Unknown color ' + t
                                  ),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor(this.r, this.g, this.b);
                    }
                    copy(t) {
                        return (
                            (this.r = t.r), (this.g = t.g), (this.b = t.b), this
                        );
                    }
                    copySRGBToLinear(t) {
                        return (
                            (this.r = st(t.r)),
                            (this.g = st(t.g)),
                            (this.b = st(t.b)),
                            this
                        );
                    }
                    copyLinearToSRGB(t) {
                        return (
                            (this.r = lt(t.r)),
                            (this.g = lt(t.g)),
                            (this.b = lt(t.b)),
                            this
                        );
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this), this;
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this), this;
                    }
                    getHex(t = F) {
                        return (
                            pt.fromWorkingColorSpace(Xe.copy(this), t),
                            65536 * Math.round(q(255 * Xe.r, 0, 255)) +
                                256 * Math.round(q(255 * Xe.g, 0, 255)) +
                                Math.round(q(255 * Xe.b, 0, 255))
                        );
                    }
                    getHexString(t = F) {
                        return ('000000' + this.getHex(t).toString(16)).slice(
                            -6
                        );
                    }
                    getHSL(t, e = pt.workingColorSpace) {
                        pt.fromWorkingColorSpace(Xe.copy(this), e);
                        const n = Xe.r,
                            i = Xe.g,
                            r = Xe.b,
                            a = Math.max(n, i, r),
                            o = Math.min(n, i, r);
                        let s, l;
                        const c = (o + a) / 2;
                        if (o === a) (s = 0), (l = 0);
                        else {
                            const t = a - o;
                            switch (
                                ((l = c <= 0.5 ? t / (a + o) : t / (2 - a - o)),
                                a)
                            ) {
                                case n:
                                    s = (i - r) / t + (i < r ? 6 : 0);
                                    break;
                                case i:
                                    s = (r - n) / t + 2;
                                    break;
                                case r:
                                    s = (n - i) / t + 4;
                            }
                            s /= 6;
                        }
                        return (t.h = s), (t.s = l), (t.l = c), t;
                    }
                    getRGB(t, e = pt.workingColorSpace) {
                        return (
                            pt.fromWorkingColorSpace(Xe.copy(this), e),
                            (t.r = Xe.r),
                            (t.g = Xe.g),
                            (t.b = Xe.b),
                            t
                        );
                    }
                    getStyle(t = F) {
                        pt.fromWorkingColorSpace(Xe.copy(this), t);
                        const e = Xe.r,
                            n = Xe.g,
                            i = Xe.b;
                        return t !== F
                            ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
                            : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(255 * i)})`;
                    }
                    offsetHSL(t, e, n) {
                        return (
                            this.getHSL(Ge),
                            (Ge.h += t),
                            (Ge.s += e),
                            (Ge.l += n),
                            this.setHSL(Ge.h, Ge.s, Ge.l),
                            this
                        );
                    }
                    add(t) {
                        return (
                            (this.r += t.r),
                            (this.g += t.g),
                            (this.b += t.b),
                            this
                        );
                    }
                    addColors(t, e) {
                        return (
                            (this.r = t.r + e.r),
                            (this.g = t.g + e.g),
                            (this.b = t.b + e.b),
                            this
                        );
                    }
                    addScalar(t) {
                        return (
                            (this.r += t), (this.g += t), (this.b += t), this
                        );
                    }
                    sub(t) {
                        return (
                            (this.r = Math.max(0, this.r - t.r)),
                            (this.g = Math.max(0, this.g - t.g)),
                            (this.b = Math.max(0, this.b - t.b)),
                            this
                        );
                    }
                    multiply(t) {
                        return (
                            (this.r *= t.r),
                            (this.g *= t.g),
                            (this.b *= t.b),
                            this
                        );
                    }
                    multiplyScalar(t) {
                        return (
                            (this.r *= t), (this.g *= t), (this.b *= t), this
                        );
                    }
                    lerp(t, e) {
                        return (
                            (this.r += (t.r - this.r) * e),
                            (this.g += (t.g - this.g) * e),
                            (this.b += (t.b - this.b) * e),
                            this
                        );
                    }
                    lerpColors(t, e, n) {
                        return (
                            (this.r = t.r + (e.r - t.r) * n),
                            (this.g = t.g + (e.g - t.g) * n),
                            (this.b = t.b + (e.b - t.b) * n),
                            this
                        );
                    }
                    lerpHSL(t, e) {
                        this.getHSL(Ge), t.getHSL(Ve);
                        const n = K(Ge.h, Ve.h, e),
                            i = K(Ge.s, Ve.s, e),
                            r = K(Ge.l, Ve.l, e);
                        return this.setHSL(n, i, r), this;
                    }
                    setFromVector3(t) {
                        return (
                            (this.r = t.x), (this.g = t.y), (this.b = t.z), this
                        );
                    }
                    applyMatrix3(t) {
                        const e = this.r,
                            n = this.g,
                            i = this.b,
                            r = t.elements;
                        return (
                            (this.r = r[0] * e + r[3] * n + r[6] * i),
                            (this.g = r[1] * e + r[4] * n + r[7] * i),
                            (this.b = r[2] * e + r[5] * n + r[8] * i),
                            this
                        );
                    }
                    equals(t) {
                        return (
                            t.r === this.r && t.g === this.g && t.b === this.b
                        );
                    }
                    fromArray(t, e = 0) {
                        return (
                            (this.r = t[e]),
                            (this.g = t[e + 1]),
                            (this.b = t[e + 2]),
                            this
                        );
                    }
                    toArray(t = [], e = 0) {
                        return (
                            (t[e] = this.r),
                            (t[e + 1] = this.g),
                            (t[e + 2] = this.b),
                            t
                        );
                    }
                    fromBufferAttribute(t, e) {
                        return (
                            (this.r = t.getX(e)),
                            (this.g = t.getY(e)),
                            (this.b = t.getZ(e)),
                            this
                        );
                    }
                    toJSON() {
                        return this.getHex();
                    }
                    *[Symbol.iterator]() {
                        yield this.r, yield this.g, yield this.b;
                    }
                }
                const Xe = new je();
                je.NAMES = He;
                class Ye extends ke {
                    constructor(t) {
                        super(),
                            (this.isMeshBasicMaterial = !0),
                            (this.type = 'MeshBasicMaterial'),
                            (this.color = new je(16777215)),
                            (this.map = null),
                            (this.lightMap = null),
                            (this.lightMapIntensity = 1),
                            (this.aoMap = null),
                            (this.aoMapIntensity = 1),
                            (this.specularMap = null),
                            (this.alphaMap = null),
                            (this.envMap = null),
                            (this.combine = 0),
                            (this.reflectivity = 1),
                            (this.refractionRatio = 0.98),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.wireframeLinecap = 'round'),
                            (this.wireframeLinejoin = 'round'),
                            (this.fog = !0),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.color.copy(t.color),
                            (this.map = t.map),
                            (this.lightMap = t.lightMap),
                            (this.lightMapIntensity = t.lightMapIntensity),
                            (this.aoMap = t.aoMap),
                            (this.aoMapIntensity = t.aoMapIntensity),
                            (this.specularMap = t.specularMap),
                            (this.alphaMap = t.alphaMap),
                            (this.envMap = t.envMap),
                            (this.combine = t.combine),
                            (this.reflectivity = t.reflectivity),
                            (this.refractionRatio = t.refractionRatio),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            (this.wireframeLinecap = t.wireframeLinecap),
                            (this.wireframeLinejoin = t.wireframeLinejoin),
                            (this.fog = t.fog),
                            this
                        );
                    }
                }
                const qe = new Tt(),
                    Ke = new tt();
                class Ze {
                    constructor(t, e, n = !1) {
                        if (Array.isArray(t))
                            throw new TypeError(
                                'THREE.BufferAttribute: array should be a Typed Array.'
                            );
                        (this.isBufferAttribute = !0),
                            (this.name = ''),
                            (this.array = t),
                            (this.itemSize = e),
                            (this.count = void 0 !== t ? t.length / e : 0),
                            (this.normalized = n),
                            (this.usage = 35044),
                            (this.updateRange = { offset: 0, count: -1 }),
                            (this.version = 0);
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        !0 === t && this.version++;
                    }
                    setUsage(t) {
                        return (this.usage = t), this;
                    }
                    copy(t) {
                        return (
                            (this.name = t.name),
                            (this.array = new t.array.constructor(t.array)),
                            (this.itemSize = t.itemSize),
                            (this.count = t.count),
                            (this.normalized = t.normalized),
                            (this.usage = t.usage),
                            this
                        );
                    }
                    copyAt(t, e, n) {
                        (t *= this.itemSize), (n *= e.itemSize);
                        for (let i = 0, r = this.itemSize; i < r; i++)
                            this.array[t + i] = e.array[n + i];
                        return this;
                    }
                    copyArray(t) {
                        return this.array.set(t), this;
                    }
                    applyMatrix3(t) {
                        if (2 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++)
                                Ke.fromBufferAttribute(this, e),
                                    Ke.applyMatrix3(t),
                                    this.setXY(e, Ke.x, Ke.y);
                        else if (3 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++)
                                qe.fromBufferAttribute(this, e),
                                    qe.applyMatrix3(t),
                                    this.setXYZ(e, qe.x, qe.y, qe.z);
                        return this;
                    }
                    applyMatrix4(t) {
                        for (let e = 0, n = this.count; e < n; e++)
                            qe.fromBufferAttribute(this, e),
                                qe.applyMatrix4(t),
                                this.setXYZ(e, qe.x, qe.y, qe.z);
                        return this;
                    }
                    applyNormalMatrix(t) {
                        for (let e = 0, n = this.count; e < n; e++)
                            qe.fromBufferAttribute(this, e),
                                qe.applyNormalMatrix(t),
                                this.setXYZ(e, qe.x, qe.y, qe.z);
                        return this;
                    }
                    transformDirection(t) {
                        for (let e = 0, n = this.count; e < n; e++)
                            qe.fromBufferAttribute(this, e),
                                qe.transformDirection(t),
                                this.setXYZ(e, qe.x, qe.y, qe.z);
                        return this;
                    }
                    set(t, e = 0) {
                        return this.array.set(t, e), this;
                    }
                    getX(t) {
                        let e = this.array[t * this.itemSize];
                        return this.normalized && (e = Q(e, this.array)), e;
                    }
                    setX(t, e) {
                        return (
                            this.normalized && (e = $(e, this.array)),
                            (this.array[t * this.itemSize] = e),
                            this
                        );
                    }
                    getY(t) {
                        let e = this.array[t * this.itemSize + 1];
                        return this.normalized && (e = Q(e, this.array)), e;
                    }
                    setY(t, e) {
                        return (
                            this.normalized && (e = $(e, this.array)),
                            (this.array[t * this.itemSize + 1] = e),
                            this
                        );
                    }
                    getZ(t) {
                        let e = this.array[t * this.itemSize + 2];
                        return this.normalized && (e = Q(e, this.array)), e;
                    }
                    setZ(t, e) {
                        return (
                            this.normalized && (e = $(e, this.array)),
                            (this.array[t * this.itemSize + 2] = e),
                            this
                        );
                    }
                    getW(t) {
                        let e = this.array[t * this.itemSize + 3];
                        return this.normalized && (e = Q(e, this.array)), e;
                    }
                    setW(t, e) {
                        return (
                            this.normalized && (e = $(e, this.array)),
                            (this.array[t * this.itemSize + 3] = e),
                            this
                        );
                    }
                    setXY(t, e, n) {
                        return (
                            (t *= this.itemSize),
                            this.normalized &&
                                ((e = $(e, this.array)),
                                (n = $(n, this.array))),
                            (this.array[t + 0] = e),
                            (this.array[t + 1] = n),
                            this
                        );
                    }
                    setXYZ(t, e, n, i) {
                        return (
                            (t *= this.itemSize),
                            this.normalized &&
                                ((e = $(e, this.array)),
                                (n = $(n, this.array)),
                                (i = $(i, this.array))),
                            (this.array[t + 0] = e),
                            (this.array[t + 1] = n),
                            (this.array[t + 2] = i),
                            this
                        );
                    }
                    setXYZW(t, e, n, i, r) {
                        return (
                            (t *= this.itemSize),
                            this.normalized &&
                                ((e = $(e, this.array)),
                                (n = $(n, this.array)),
                                (i = $(i, this.array)),
                                (r = $(r, this.array))),
                            (this.array[t + 0] = e),
                            (this.array[t + 1] = n),
                            (this.array[t + 2] = i),
                            (this.array[t + 3] = r),
                            this
                        );
                    }
                    onUpload(t) {
                        return (this.onUploadCallback = t), this;
                    }
                    clone() {
                        return new this.constructor(
                            this.array,
                            this.itemSize
                        ).copy(this);
                    }
                    toJSON() {
                        const t = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.from(this.array),
                            normalized: this.normalized,
                        };
                        return (
                            '' !== this.name && (t.name = this.name),
                            35044 !== this.usage && (t.usage = this.usage),
                            (0 === this.updateRange.offset &&
                                -1 === this.updateRange.count) ||
                                (t.updateRange = this.updateRange),
                            t
                        );
                    }
                    copyColorsArray() {
                        console.error(
                            'THREE.BufferAttribute: copyColorsArray() was removed in r144.'
                        );
                    }
                    copyVector2sArray() {
                        console.error(
                            'THREE.BufferAttribute: copyVector2sArray() was removed in r144.'
                        );
                    }
                    copyVector3sArray() {
                        console.error(
                            'THREE.BufferAttribute: copyVector3sArray() was removed in r144.'
                        );
                    }
                    copyVector4sArray() {
                        console.error(
                            'THREE.BufferAttribute: copyVector4sArray() was removed in r144.'
                        );
                    }
                }
                class Je extends Ze {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n);
                    }
                }
                class Qe extends Ze {
                    constructor(t, e, n) {
                        super(new Uint32Array(t), e, n);
                    }
                }
                class $e extends Ze {
                    constructor(t, e, n) {
                        super(new Float32Array(t), e, n);
                    }
                }
                let tn = 0;
                const en = new ee(),
                    nn = new we(),
                    rn = new Tt(),
                    an = new Ct(),
                    on = new Ct(),
                    sn = new Tt();
                class ln extends V {
                    constructor() {
                        super(),
                            (this.isBufferGeometry = !0),
                            Object.defineProperty(this, 'id', { value: tn++ }),
                            (this.uuid = Y()),
                            (this.name = ''),
                            (this.type = 'BufferGeometry'),
                            (this.index = null),
                            (this.attributes = {}),
                            (this.morphAttributes = {}),
                            (this.morphTargetsRelative = !1),
                            (this.groups = []),
                            (this.boundingBox = null),
                            (this.boundingSphere = null),
                            (this.drawRange = { start: 0, count: 1 / 0 }),
                            (this.userData = {});
                    }
                    getIndex() {
                        return this.index;
                    }
                    setIndex(t) {
                        return (
                            Array.isArray(t)
                                ? (this.index = new (it(t) ? Qe : Je)(t, 1))
                                : (this.index = t),
                            this
                        );
                    }
                    getAttribute(t) {
                        return this.attributes[t];
                    }
                    setAttribute(t, e) {
                        return (this.attributes[t] = e), this;
                    }
                    deleteAttribute(t) {
                        return delete this.attributes[t], this;
                    }
                    hasAttribute(t) {
                        return void 0 !== this.attributes[t];
                    }
                    addGroup(t, e, n = 0) {
                        this.groups.push({
                            start: t,
                            count: e,
                            materialIndex: n,
                        });
                    }
                    clearGroups() {
                        this.groups = [];
                    }
                    setDrawRange(t, e) {
                        (this.drawRange.start = t), (this.drawRange.count = e);
                    }
                    applyMatrix4(t) {
                        const e = this.attributes.position;
                        void 0 !== e &&
                            (e.applyMatrix4(t), (e.needsUpdate = !0));
                        const n = this.attributes.normal;
                        if (void 0 !== n) {
                            const e = new et().getNormalMatrix(t);
                            n.applyNormalMatrix(e), (n.needsUpdate = !0);
                        }
                        const i = this.attributes.tangent;
                        return (
                            void 0 !== i &&
                                (i.transformDirection(t), (i.needsUpdate = !0)),
                            null !== this.boundingBox &&
                                this.computeBoundingBox(),
                            null !== this.boundingSphere &&
                                this.computeBoundingSphere(),
                            this
                        );
                    }
                    applyQuaternion(t) {
                        return (
                            en.makeRotationFromQuaternion(t),
                            this.applyMatrix4(en),
                            this
                        );
                    }
                    rotateX(t) {
                        return en.makeRotationX(t), this.applyMatrix4(en), this;
                    }
                    rotateY(t) {
                        return en.makeRotationY(t), this.applyMatrix4(en), this;
                    }
                    rotateZ(t) {
                        return en.makeRotationZ(t), this.applyMatrix4(en), this;
                    }
                    translate(t, e, n) {
                        return (
                            en.makeTranslation(t, e, n),
                            this.applyMatrix4(en),
                            this
                        );
                    }
                    scale(t, e, n) {
                        return (
                            en.makeScale(t, e, n), this.applyMatrix4(en), this
                        );
                    }
                    lookAt(t) {
                        return (
                            nn.lookAt(t),
                            nn.updateMatrix(),
                            this.applyMatrix4(nn.matrix),
                            this
                        );
                    }
                    center() {
                        return (
                            this.computeBoundingBox(),
                            this.boundingBox.getCenter(rn).negate(),
                            this.translate(rn.x, rn.y, rn.z),
                            this
                        );
                    }
                    setFromPoints(t) {
                        const e = [];
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.push(i.x, i.y, i.z || 0);
                        }
                        return (
                            this.setAttribute('position', new $e(e, 3)), this
                        );
                    }
                    computeBoundingBox() {
                        null === this.boundingBox &&
                            (this.boundingBox = new Ct());
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute)
                            return (
                                console.error(
                                    'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                                    this
                                ),
                                void this.boundingBox.set(
                                    new Tt(-1 / 0, -1 / 0, -1 / 0),
                                    new Tt(1 / 0, 1 / 0, 1 / 0)
                                )
                            );
                        if (void 0 !== t) {
                            if ((this.boundingBox.setFromBufferAttribute(t), e))
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    an.setFromBufferAttribute(n),
                                        this.morphTargetsRelative
                                            ? (sn.addVectors(
                                                  this.boundingBox.min,
                                                  an.min
                                              ),
                                              this.boundingBox.expandByPoint(
                                                  sn
                                              ),
                                              sn.addVectors(
                                                  this.boundingBox.max,
                                                  an.max
                                              ),
                                              this.boundingBox.expandByPoint(
                                                  sn
                                              ))
                                            : (this.boundingBox.expandByPoint(
                                                  an.min
                                              ),
                                              this.boundingBox.expandByPoint(
                                                  an.max
                                              ));
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) ||
                            isNaN(this.boundingBox.min.y) ||
                            isNaN(this.boundingBox.min.z)) &&
                            console.error(
                                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                                this
                            );
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere &&
                            (this.boundingSphere = new Xt());
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute)
                            return (
                                console.error(
                                    'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                                    this
                                ),
                                void this.boundingSphere.set(new Tt(), 1 / 0)
                            );
                        if (t) {
                            const n = this.boundingSphere.center;
                            if ((an.setFromBufferAttribute(t), e))
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    on.setFromBufferAttribute(n),
                                        this.morphTargetsRelative
                                            ? (sn.addVectors(an.min, on.min),
                                              an.expandByPoint(sn),
                                              sn.addVectors(an.max, on.max),
                                              an.expandByPoint(sn))
                                            : (an.expandByPoint(on.min),
                                              an.expandByPoint(on.max));
                                }
                            an.getCenter(n);
                            let i = 0;
                            for (let e = 0, r = t.count; e < r; e++)
                                sn.fromBufferAttribute(t, e),
                                    (i = Math.max(i, n.distanceToSquared(sn)));
                            if (e)
                                for (let r = 0, a = e.length; r < a; r++) {
                                    const a = e[r],
                                        o = this.morphTargetsRelative;
                                    for (let e = 0, r = a.count; e < r; e++)
                                        sn.fromBufferAttribute(a, e),
                                            o &&
                                                (rn.fromBufferAttribute(t, e),
                                                sn.add(rn)),
                                            (i = Math.max(
                                                i,
                                                n.distanceToSquared(sn)
                                            ));
                                }
                            (this.boundingSphere.radius = Math.sqrt(i)),
                                isNaN(this.boundingSphere.radius) &&
                                    console.error(
                                        'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                                        this
                                    );
                        }
                    }
                    computeTangents() {
                        const t = this.index,
                            e = this.attributes;
                        if (
                            null === t ||
                            void 0 === e.position ||
                            void 0 === e.normal ||
                            void 0 === e.uv
                        )
                            return void console.error(
                                'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
                            );
                        const n = t.array,
                            i = e.position.array,
                            r = e.normal.array,
                            a = e.uv.array,
                            o = i.length / 3;
                        !1 === this.hasAttribute('tangent') &&
                            this.setAttribute(
                                'tangent',
                                new Ze(new Float32Array(4 * o), 4)
                            );
                        const s = this.getAttribute('tangent').array,
                            l = [],
                            c = [];
                        for (let t = 0; t < o; t++)
                            (l[t] = new Tt()), (c[t] = new Tt());
                        const u = new Tt(),
                            h = new Tt(),
                            d = new Tt(),
                            p = new tt(),
                            f = new tt(),
                            m = new tt(),
                            g = new Tt(),
                            v = new Tt();
                        function _(t, e, n) {
                            u.fromArray(i, 3 * t),
                                h.fromArray(i, 3 * e),
                                d.fromArray(i, 3 * n),
                                p.fromArray(a, 2 * t),
                                f.fromArray(a, 2 * e),
                                m.fromArray(a, 2 * n),
                                h.sub(u),
                                d.sub(u),
                                f.sub(p),
                                m.sub(p);
                            const r = 1 / (f.x * m.y - m.x * f.y);
                            isFinite(r) &&
                                (g
                                    .copy(h)
                                    .multiplyScalar(m.y)
                                    .addScaledVector(d, -f.y)
                                    .multiplyScalar(r),
                                v
                                    .copy(d)
                                    .multiplyScalar(f.x)
                                    .addScaledVector(h, -m.x)
                                    .multiplyScalar(r),
                                l[t].add(g),
                                l[e].add(g),
                                l[n].add(g),
                                c[t].add(v),
                                c[e].add(v),
                                c[n].add(v));
                        }
                        let x = this.groups;
                        0 === x.length && (x = [{ start: 0, count: n.length }]);
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3)
                                _(n[t + 0], n[t + 1], n[t + 2]);
                        }
                        const y = new Tt(),
                            M = new Tt(),
                            b = new Tt(),
                            E = new Tt();
                        function S(t) {
                            b.fromArray(r, 3 * t), E.copy(b);
                            const e = l[t];
                            y.copy(e),
                                y.sub(b.multiplyScalar(b.dot(e))).normalize(),
                                M.crossVectors(E, e);
                            const n = M.dot(c[t]) < 0 ? -1 : 1;
                            (s[4 * t] = y.x),
                                (s[4 * t + 1] = y.y),
                                (s[4 * t + 2] = y.z),
                                (s[4 * t + 3] = n);
                        }
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3)
                                S(n[t + 0]), S(n[t + 1]), S(n[t + 2]);
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index,
                            e = this.getAttribute('position');
                        if (void 0 !== e) {
                            let n = this.getAttribute('normal');
                            if (void 0 === n)
                                (n = new Ze(new Float32Array(3 * e.count), 3)),
                                    this.setAttribute('normal', n);
                            else
                                for (let t = 0, e = n.count; t < e; t++)
                                    n.setXYZ(t, 0, 0, 0);
                            const i = new Tt(),
                                r = new Tt(),
                                a = new Tt(),
                                o = new Tt(),
                                s = new Tt(),
                                l = new Tt(),
                                c = new Tt(),
                                u = new Tt();
                            if (t)
                                for (let h = 0, d = t.count; h < d; h += 3) {
                                    const d = t.getX(h + 0),
                                        p = t.getX(h + 1),
                                        f = t.getX(h + 2);
                                    i.fromBufferAttribute(e, d),
                                        r.fromBufferAttribute(e, p),
                                        a.fromBufferAttribute(e, f),
                                        c.subVectors(a, r),
                                        u.subVectors(i, r),
                                        c.cross(u),
                                        o.fromBufferAttribute(n, d),
                                        s.fromBufferAttribute(n, p),
                                        l.fromBufferAttribute(n, f),
                                        o.add(c),
                                        s.add(c),
                                        l.add(c),
                                        n.setXYZ(d, o.x, o.y, o.z),
                                        n.setXYZ(p, s.x, s.y, s.z),
                                        n.setXYZ(f, l.x, l.y, l.z);
                                }
                            else
                                for (let t = 0, o = e.count; t < o; t += 3)
                                    i.fromBufferAttribute(e, t + 0),
                                        r.fromBufferAttribute(e, t + 1),
                                        a.fromBufferAttribute(e, t + 2),
                                        c.subVectors(a, r),
                                        u.subVectors(i, r),
                                        c.cross(u),
                                        n.setXYZ(t + 0, c.x, c.y, c.z),
                                        n.setXYZ(t + 1, c.x, c.y, c.z),
                                        n.setXYZ(t + 2, c.x, c.y, c.z);
                            this.normalizeNormals(), (n.needsUpdate = !0);
                        }
                    }
                    merge() {
                        return (
                            console.error(
                                'THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead.'
                            ),
                            this
                        );
                    }
                    normalizeNormals() {
                        const t = this.attributes.normal;
                        for (let e = 0, n = t.count; e < n; e++)
                            sn.fromBufferAttribute(t, e),
                                sn.normalize(),
                                t.setXYZ(e, sn.x, sn.y, sn.z);
                    }
                    toNonIndexed() {
                        function t(t, e) {
                            const n = t.array,
                                i = t.itemSize,
                                r = t.normalized,
                                a = new n.constructor(e.length * i);
                            let o = 0,
                                s = 0;
                            for (let r = 0, l = e.length; r < l; r++) {
                                o = t.isInterleavedBufferAttribute
                                    ? e[r] * t.data.stride + t.offset
                                    : e[r] * i;
                                for (let t = 0; t < i; t++) a[s++] = n[o++];
                            }
                            return new Ze(a, i, r);
                        }
                        if (null === this.index)
                            return (
                                console.warn(
                                    'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'
                                ),
                                this
                            );
                        const e = new ln(),
                            n = this.index.array,
                            i = this.attributes;
                        for (const r in i) {
                            const a = t(i[r], n);
                            e.setAttribute(r, a);
                        }
                        const r = this.morphAttributes;
                        for (const i in r) {
                            const a = [],
                                o = r[i];
                            for (let e = 0, i = o.length; e < i; e++) {
                                const i = t(o[e], n);
                                a.push(i);
                            }
                            e.morphAttributes[i] = a;
                        }
                        e.morphTargetsRelative = this.morphTargetsRelative;
                        const a = this.groups;
                        for (let t = 0, n = a.length; t < n; t++) {
                            const n = a[t];
                            e.addGroup(n.start, n.count, n.materialIndex);
                        }
                        return e;
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.5,
                                type: 'BufferGeometry',
                                generator: 'BufferGeometry.toJSON',
                            },
                        };
                        if (
                            ((t.uuid = this.uuid),
                            (t.type = this.type),
                            '' !== this.name && (t.name = this.name),
                            Object.keys(this.userData).length > 0 &&
                                (t.userData = this.userData),
                            void 0 !== this.parameters)
                        ) {
                            const e = this.parameters;
                            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                            return t;
                        }
                        t.data = { attributes: {} };
                        const e = this.index;
                        null !== e &&
                            (t.data.index = {
                                type: e.array.constructor.name,
                                array: Array.prototype.slice.call(e.array),
                            });
                        const n = this.attributes;
                        for (const e in n) {
                            const i = n[e];
                            t.data.attributes[e] = i.toJSON(t.data);
                        }
                        const i = {};
                        let r = !1;
                        for (const e in this.morphAttributes) {
                            const n = this.morphAttributes[e],
                                a = [];
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                a.push(i.toJSON(t.data));
                            }
                            a.length > 0 && ((i[e] = a), (r = !0));
                        }
                        r &&
                            ((t.data.morphAttributes = i),
                            (t.data.morphTargetsRelative =
                                this.morphTargetsRelative));
                        const a = this.groups;
                        a.length > 0 &&
                            (t.data.groups = JSON.parse(JSON.stringify(a)));
                        const o = this.boundingSphere;
                        return (
                            null !== o &&
                                (t.data.boundingSphere = {
                                    center: o.center.toArray(),
                                    radius: o.radius,
                                }),
                            t
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(t) {
                        (this.index = null),
                            (this.attributes = {}),
                            (this.morphAttributes = {}),
                            (this.groups = []),
                            (this.boundingBox = null),
                            (this.boundingSphere = null);
                        const e = {};
                        this.name = t.name;
                        const n = t.index;
                        null !== n && this.setIndex(n.clone(e));
                        const i = t.attributes;
                        for (const t in i) {
                            const n = i[t];
                            this.setAttribute(t, n.clone(e));
                        }
                        const r = t.morphAttributes;
                        for (const t in r) {
                            const n = [],
                                i = r[t];
                            for (let t = 0, r = i.length; t < r; t++)
                                n.push(i[t].clone(e));
                            this.morphAttributes[t] = n;
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const a = t.groups;
                        for (let t = 0, e = a.length; t < e; t++) {
                            const e = a[t];
                            this.addGroup(e.start, e.count, e.materialIndex);
                        }
                        const o = t.boundingBox;
                        null !== o && (this.boundingBox = o.clone());
                        const s = t.boundingSphere;
                        return (
                            null !== s && (this.boundingSphere = s.clone()),
                            (this.drawRange.start = t.drawRange.start),
                            (this.drawRange.count = t.drawRange.count),
                            (this.userData = t.userData),
                            this
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: 'dispose' });
                    }
                }
                const cn = new ee(),
                    un = new te(),
                    hn = new Xt(),
                    dn = new Tt(),
                    pn = new Tt(),
                    fn = new Tt(),
                    mn = new Tt(),
                    gn = new Tt(),
                    vn = new Tt(),
                    _n = new tt(),
                    xn = new tt(),
                    yn = new tt(),
                    Mn = new Tt(),
                    bn = new Tt(),
                    En = new Tt(),
                    Sn = new Tt(),
                    Tn = new Tt();
                class wn extends we {
                    constructor(t = new ln(), e = new Ye()) {
                        super(),
                            (this.isMesh = !0),
                            (this.type = 'Mesh'),
                            (this.geometry = t),
                            (this.material = e),
                            this.updateMorphTargets();
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            void 0 !== t.morphTargetInfluences &&
                                (this.morphTargetInfluences =
                                    t.morphTargetInfluences.slice()),
                            void 0 !== t.morphTargetDictionary &&
                                (this.morphTargetDictionary = Object.assign(
                                    {},
                                    t.morphTargetDictionary
                                )),
                            (this.material = t.material),
                            (this.geometry = t.geometry),
                            this
                        );
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes,
                            e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (void 0 !== n) {
                                (this.morphTargetInfluences = []),
                                    (this.morphTargetDictionary = {});
                                for (let t = 0, e = n.length; t < e; t++) {
                                    const e = n[t].name || String(t);
                                    this.morphTargetInfluences.push(0),
                                        (this.morphTargetDictionary[e] = t);
                                }
                            }
                        }
                    }
                    getVertexPosition(t, e) {
                        const n = this.geometry,
                            i = n.attributes.position,
                            r = n.morphAttributes.position,
                            a = n.morphTargetsRelative;
                        e.fromBufferAttribute(i, t);
                        const o = this.morphTargetInfluences;
                        if (r && o) {
                            vn.set(0, 0, 0);
                            for (let n = 0, i = r.length; n < i; n++) {
                                const i = o[n],
                                    s = r[n];
                                0 !== i &&
                                    (gn.fromBufferAttribute(s, t),
                                    a
                                        ? vn.addScaledVector(gn, i)
                                        : vn.addScaledVector(gn.sub(e), i));
                            }
                            e.add(vn);
                        }
                        return e;
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.material,
                            r = this.matrixWorld;
                        if (void 0 !== i) {
                            if (
                                (null === n.boundingSphere &&
                                    n.computeBoundingSphere(),
                                hn.copy(n.boundingSphere),
                                hn.applyMatrix4(r),
                                un.copy(t.ray).recast(t.near),
                                !1 === hn.containsPoint(un.origin))
                            ) {
                                if (null === un.intersectSphere(hn, dn)) return;
                                if (
                                    un.origin.distanceToSquared(dn) >
                                    (t.far - t.near) ** 2
                                )
                                    return;
                            }
                            cn.copy(r).invert(),
                                un.copy(t.ray).applyMatrix4(cn),
                                (null !== n.boundingBox &&
                                    !1 === un.intersectsBox(n.boundingBox)) ||
                                    this._computeIntersections(t, e);
                        }
                    }
                    _computeIntersections(t, e) {
                        let n;
                        const i = this.geometry,
                            r = this.material,
                            a = i.index,
                            o = i.attributes.position,
                            s = i.attributes.uv,
                            l = i.attributes.uv1,
                            c = i.attributes.normal,
                            u = i.groups,
                            h = i.drawRange;
                        if (null !== a)
                            if (Array.isArray(r))
                                for (let i = 0, o = u.length; i < o; i++) {
                                    const o = u[i],
                                        d = r[o.materialIndex];
                                    for (
                                        let i = Math.max(o.start, h.start),
                                            r = Math.min(
                                                a.count,
                                                Math.min(
                                                    o.start + o.count,
                                                    h.start + h.count
                                                )
                                            );
                                        i < r;
                                        i += 3
                                    ) {
                                        const r = a.getX(i),
                                            u = a.getX(i + 1),
                                            h = a.getX(i + 2);
                                        (n = An(
                                            this,
                                            d,
                                            t,
                                            un,
                                            s,
                                            l,
                                            c,
                                            r,
                                            u,
                                            h
                                        )),
                                            n &&
                                                ((n.faceIndex = Math.floor(
                                                    i / 3
                                                )),
                                                (n.face.materialIndex =
                                                    o.materialIndex),
                                                e.push(n));
                                    }
                                }
                            else
                                for (
                                    let i = Math.max(0, h.start),
                                        o = Math.min(
                                            a.count,
                                            h.start + h.count
                                        );
                                    i < o;
                                    i += 3
                                ) {
                                    const o = a.getX(i),
                                        u = a.getX(i + 1),
                                        h = a.getX(i + 2);
                                    (n = An(this, r, t, un, s, l, c, o, u, h)),
                                        n &&
                                            ((n.faceIndex = Math.floor(i / 3)),
                                            e.push(n));
                                }
                        else if (void 0 !== o)
                            if (Array.isArray(r))
                                for (let i = 0, a = u.length; i < a; i++) {
                                    const a = u[i],
                                        d = r[a.materialIndex];
                                    for (
                                        let i = Math.max(a.start, h.start),
                                            r = Math.min(
                                                o.count,
                                                Math.min(
                                                    a.start + a.count,
                                                    h.start + h.count
                                                )
                                            );
                                        i < r;
                                        i += 3
                                    )
                                        (n = An(
                                            this,
                                            d,
                                            t,
                                            un,
                                            s,
                                            l,
                                            c,
                                            i,
                                            i + 1,
                                            i + 2
                                        )),
                                            n &&
                                                ((n.faceIndex = Math.floor(
                                                    i / 3
                                                )),
                                                (n.face.materialIndex =
                                                    a.materialIndex),
                                                e.push(n));
                                }
                            else
                                for (
                                    let i = Math.max(0, h.start),
                                        a = Math.min(
                                            o.count,
                                            h.start + h.count
                                        );
                                    i < a;
                                    i += 3
                                )
                                    (n = An(
                                        this,
                                        r,
                                        t,
                                        un,
                                        s,
                                        l,
                                        c,
                                        i,
                                        i + 1,
                                        i + 2
                                    )),
                                        n &&
                                            ((n.faceIndex = Math.floor(i / 3)),
                                            e.push(n));
                    }
                }
                function An(t, e, n, i, r, a, s, l, c, u) {
                    t.getVertexPosition(l, pn),
                        t.getVertexPosition(c, fn),
                        t.getVertexPosition(u, mn);
                    const h = (function (t, e, n, i, r, a, s, l) {
                        let c;
                        if (
                            ((c =
                                e.side === o
                                    ? i.intersectTriangle(s, a, r, !0, l)
                                    : i.intersectTriangle(
                                          r,
                                          a,
                                          s,
                                          0 === e.side,
                                          l
                                      )),
                            null === c)
                        )
                            return null;
                        Tn.copy(l), Tn.applyMatrix4(t.matrixWorld);
                        const u = n.ray.origin.distanceTo(Tn);
                        return u < n.near || u > n.far
                            ? null
                            : { distance: u, point: Tn.clone(), object: t };
                    })(t, e, n, i, pn, fn, mn, Sn);
                    if (h) {
                        r &&
                            (_n.fromBufferAttribute(r, l),
                            xn.fromBufferAttribute(r, c),
                            yn.fromBufferAttribute(r, u),
                            (h.uv = ze.getInterpolation(
                                Sn,
                                pn,
                                fn,
                                mn,
                                _n,
                                xn,
                                yn,
                                new tt()
                            ))),
                            a &&
                                (_n.fromBufferAttribute(a, l),
                                xn.fromBufferAttribute(a, c),
                                yn.fromBufferAttribute(a, u),
                                (h.uv1 = ze.getInterpolation(
                                    Sn,
                                    pn,
                                    fn,
                                    mn,
                                    _n,
                                    xn,
                                    yn,
                                    new tt()
                                )),
                                (h.uv2 = h.uv1)),
                            s &&
                                (Mn.fromBufferAttribute(s, l),
                                bn.fromBufferAttribute(s, c),
                                En.fromBufferAttribute(s, u),
                                (h.normal = ze.getInterpolation(
                                    Sn,
                                    pn,
                                    fn,
                                    mn,
                                    Mn,
                                    bn,
                                    En,
                                    new Tt()
                                )),
                                h.normal.dot(i.direction) > 0 &&
                                    h.normal.multiplyScalar(-1));
                        const t = {
                            a: l,
                            b: c,
                            c: u,
                            normal: new Tt(),
                            materialIndex: 0,
                        };
                        ze.getNormal(pn, fn, mn, t.normal), (h.face = t);
                    }
                    return h;
                }
                class Cn extends ln {
                    constructor(t = 1, e = 1, n = 1, i = 1, r = 1, a = 1) {
                        super(),
                            (this.type = 'BoxGeometry'),
                            (this.parameters = {
                                width: t,
                                height: e,
                                depth: n,
                                widthSegments: i,
                                heightSegments: r,
                                depthSegments: a,
                            });
                        const o = this;
                        (i = Math.floor(i)),
                            (r = Math.floor(r)),
                            (a = Math.floor(a));
                        const s = [],
                            l = [],
                            c = [],
                            u = [];
                        let h = 0,
                            d = 0;
                        function p(t, e, n, i, r, a, p, f, m, g, v) {
                            const _ = a / m,
                                x = p / g,
                                y = a / 2,
                                M = p / 2,
                                b = f / 2,
                                E = m + 1,
                                S = g + 1;
                            let T = 0,
                                w = 0;
                            const A = new Tt();
                            for (let a = 0; a < S; a++) {
                                const o = a * x - M;
                                for (let s = 0; s < E; s++) {
                                    const h = s * _ - y;
                                    (A[t] = h * i),
                                        (A[e] = o * r),
                                        (A[n] = b),
                                        l.push(A.x, A.y, A.z),
                                        (A[t] = 0),
                                        (A[e] = 0),
                                        (A[n] = f > 0 ? 1 : -1),
                                        c.push(A.x, A.y, A.z),
                                        u.push(s / m),
                                        u.push(1 - a / g),
                                        (T += 1);
                                }
                            }
                            for (let t = 0; t < g; t++)
                                for (let e = 0; e < m; e++) {
                                    const n = h + e + E * t,
                                        i = h + e + E * (t + 1),
                                        r = h + (e + 1) + E * (t + 1),
                                        a = h + (e + 1) + E * t;
                                    s.push(n, i, a), s.push(i, r, a), (w += 6);
                                }
                            o.addGroup(d, w, v), (d += w), (h += T);
                        }
                        p('z', 'y', 'x', -1, -1, n, e, t, a, r, 0),
                            p('z', 'y', 'x', 1, -1, n, e, -t, a, r, 1),
                            p('x', 'z', 'y', 1, 1, t, n, e, i, a, 2),
                            p('x', 'z', 'y', 1, -1, t, n, -e, i, a, 3),
                            p('x', 'y', 'z', 1, -1, t, e, n, i, r, 4),
                            p('x', 'y', 'z', -1, -1, t, e, -n, i, r, 5),
                            this.setIndex(s),
                            this.setAttribute('position', new $e(l, 3)),
                            this.setAttribute('normal', new $e(c, 3)),
                            this.setAttribute('uv', new $e(u, 2));
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.parameters = Object.assign({}, t.parameters)),
                            this
                        );
                    }
                    static fromJSON(t) {
                        return new Cn(
                            t.width,
                            t.height,
                            t.depth,
                            t.widthSegments,
                            t.heightSegments,
                            t.depthSegments
                        );
                    }
                }
                function Rn(t) {
                    const e = {};
                    for (const n in t) {
                        e[n] = {};
                        for (const i in t[n]) {
                            const r = t[n][i];
                            r &&
                            (r.isColor ||
                                r.isMatrix3 ||
                                r.isMatrix4 ||
                                r.isVector2 ||
                                r.isVector3 ||
                                r.isVector4 ||
                                r.isTexture ||
                                r.isQuaternion)
                                ? r.isRenderTargetTexture
                                    ? (console.warn(
                                          'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'
                                      ),
                                      (e[n][i] = null))
                                    : (e[n][i] = r.clone())
                                : Array.isArray(r)
                                  ? (e[n][i] = r.slice())
                                  : (e[n][i] = r);
                        }
                    }
                    return e;
                }
                function Ln(t) {
                    const e = {};
                    for (let n = 0; n < t.length; n++) {
                        const i = Rn(t[n]);
                        for (const t in i) e[t] = i[t];
                    }
                    return e;
                }
                function Pn(t) {
                    return null === t.getRenderTarget()
                        ? t.outputColorSpace
                        : z;
                }
                const Dn = { clone: Rn, merge: Ln };
                class In extends ke {
                    constructor(t) {
                        super(),
                            (this.isShaderMaterial = !0),
                            (this.type = 'ShaderMaterial'),
                            (this.defines = {}),
                            (this.uniforms = {}),
                            (this.uniformsGroups = []),
                            (this.vertexShader =
                                'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
                            (this.fragmentShader =
                                'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
                            (this.linewidth = 1),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.fog = !1),
                            (this.lights = !1),
                            (this.clipping = !1),
                            (this.forceSinglePass = !0),
                            (this.extensions = {
                                derivatives: !1,
                                fragDepth: !1,
                                drawBuffers: !1,
                                shaderTextureLOD: !1,
                            }),
                            (this.defaultAttributeValues = {
                                color: [1, 1, 1],
                                uv: [0, 0],
                                uv1: [0, 0],
                            }),
                            (this.index0AttributeName = void 0),
                            (this.uniformsNeedUpdate = !1),
                            (this.glslVersion = null),
                            void 0 !== t && this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.fragmentShader = t.fragmentShader),
                            (this.vertexShader = t.vertexShader),
                            (this.uniforms = Rn(t.uniforms)),
                            (this.uniformsGroups = (function (t) {
                                const e = [];
                                for (let n = 0; n < t.length; n++)
                                    e.push(t[n].clone());
                                return e;
                            })(t.uniformsGroups)),
                            (this.defines = Object.assign({}, t.defines)),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            (this.fog = t.fog),
                            (this.lights = t.lights),
                            (this.clipping = t.clipping),
                            (this.extensions = Object.assign({}, t.extensions)),
                            (this.glslVersion = t.glslVersion),
                            this
                        );
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        (e.glslVersion = this.glslVersion), (e.uniforms = {});
                        for (const n in this.uniforms) {
                            const i = this.uniforms[n].value;
                            i && i.isTexture
                                ? (e.uniforms[n] = {
                                      type: 't',
                                      value: i.toJSON(t).uuid,
                                  })
                                : i && i.isColor
                                  ? (e.uniforms[n] = {
                                        type: 'c',
                                        value: i.getHex(),
                                    })
                                  : i && i.isVector2
                                    ? (e.uniforms[n] = {
                                          type: 'v2',
                                          value: i.toArray(),
                                      })
                                    : i && i.isVector3
                                      ? (e.uniforms[n] = {
                                            type: 'v3',
                                            value: i.toArray(),
                                        })
                                      : i && i.isVector4
                                        ? (e.uniforms[n] = {
                                              type: 'v4',
                                              value: i.toArray(),
                                          })
                                        : i && i.isMatrix3
                                          ? (e.uniforms[n] = {
                                                type: 'm3',
                                                value: i.toArray(),
                                            })
                                          : i && i.isMatrix4
                                            ? (e.uniforms[n] = {
                                                  type: 'm4',
                                                  value: i.toArray(),
                                              })
                                            : (e.uniforms[n] = { value: i });
                        }
                        Object.keys(this.defines).length > 0 &&
                            (e.defines = this.defines),
                            (e.vertexShader = this.vertexShader),
                            (e.fragmentShader = this.fragmentShader),
                            (e.lights = this.lights),
                            (e.clipping = this.clipping);
                        const n = {};
                        for (const t in this.extensions)
                            !0 === this.extensions[t] && (n[t] = !0);
                        return (
                            Object.keys(n).length > 0 && (e.extensions = n), e
                        );
                    }
                }
                class Un extends we {
                    constructor() {
                        super(),
                            (this.isCamera = !0),
                            (this.type = 'Camera'),
                            (this.matrixWorldInverse = new ee()),
                            (this.projectionMatrix = new ee()),
                            (this.projectionMatrixInverse = new ee());
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            this.matrixWorldInverse.copy(t.matrixWorldInverse),
                            this.projectionMatrix.copy(t.projectionMatrix),
                            this.projectionMatrixInverse.copy(
                                t.projectionMatrixInverse
                            ),
                            this
                        );
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return t.set(-e[8], -e[9], -e[10]).normalize();
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t),
                            this.matrixWorldInverse
                                .copy(this.matrixWorld)
                                .invert();
                    }
                    updateWorldMatrix(t, e) {
                        super.updateWorldMatrix(t, e),
                            this.matrixWorldInverse
                                .copy(this.matrixWorld)
                                .invert();
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                class On extends Un {
                    constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
                        super(),
                            (this.isPerspectiveCamera = !0),
                            (this.type = 'PerspectiveCamera'),
                            (this.fov = t),
                            (this.zoom = 1),
                            (this.near = n),
                            (this.far = i),
                            (this.focus = 10),
                            (this.aspect = e),
                            (this.view = null),
                            (this.filmGauge = 35),
                            (this.filmOffset = 0),
                            this.updateProjectionMatrix();
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            (this.fov = t.fov),
                            (this.zoom = t.zoom),
                            (this.near = t.near),
                            (this.far = t.far),
                            (this.focus = t.focus),
                            (this.aspect = t.aspect),
                            (this.view =
                                null === t.view
                                    ? null
                                    : Object.assign({}, t.view)),
                            (this.filmGauge = t.filmGauge),
                            (this.filmOffset = t.filmOffset),
                            this
                        );
                    }
                    setFocalLength(t) {
                        const e = (0.5 * this.getFilmHeight()) / t;
                        (this.fov = 2 * X * Math.atan(e)),
                            this.updateProjectionMatrix();
                    }
                    getFocalLength() {
                        const t = Math.tan(0.5 * j * this.fov);
                        return (0.5 * this.getFilmHeight()) / t;
                    }
                    getEffectiveFOV() {
                        return (
                            2 *
                            X *
                            Math.atan(Math.tan(0.5 * j * this.fov) / this.zoom)
                        );
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1);
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1);
                    }
                    setViewOffset(t, e, n, i, r, a) {
                        (this.aspect = t / e),
                            null === this.view &&
                                (this.view = {
                                    enabled: !0,
                                    fullWidth: 1,
                                    fullHeight: 1,
                                    offsetX: 0,
                                    offsetY: 0,
                                    width: 1,
                                    height: 1,
                                }),
                            (this.view.enabled = !0),
                            (this.view.fullWidth = t),
                            (this.view.fullHeight = e),
                            (this.view.offsetX = n),
                            (this.view.offsetY = i),
                            (this.view.width = r),
                            (this.view.height = a),
                            this.updateProjectionMatrix();
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1),
                            this.updateProjectionMatrix();
                    }
                    updateProjectionMatrix() {
                        const t = this.near;
                        let e = (t * Math.tan(0.5 * j * this.fov)) / this.zoom,
                            n = 2 * e,
                            i = this.aspect * n,
                            r = -0.5 * i;
                        const a = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const t = a.fullWidth,
                                o = a.fullHeight;
                            (r += (a.offsetX * i) / t),
                                (e -= (a.offsetY * n) / o),
                                (i *= a.width / t),
                                (n *= a.height / o);
                        }
                        const o = this.filmOffset;
                        0 !== o && (r += (t * o) / this.getFilmWidth()),
                            this.projectionMatrix.makePerspective(
                                r,
                                r + i,
                                e,
                                e - n,
                                t,
                                this.far
                            ),
                            this.projectionMatrixInverse
                                .copy(this.projectionMatrix)
                                .invert();
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (
                            (e.object.fov = this.fov),
                            (e.object.zoom = this.zoom),
                            (e.object.near = this.near),
                            (e.object.far = this.far),
                            (e.object.focus = this.focus),
                            (e.object.aspect = this.aspect),
                            null !== this.view &&
                                (e.object.view = Object.assign({}, this.view)),
                            (e.object.filmGauge = this.filmGauge),
                            (e.object.filmOffset = this.filmOffset),
                            e
                        );
                    }
                }
                const Nn = -90;
                class Fn extends we {
                    constructor(t, e, n) {
                        super(),
                            (this.type = 'CubeCamera'),
                            (this.renderTarget = n);
                        const i = new On(Nn, 1, t, e);
                        (i.layers = this.layers),
                            i.up.set(0, 1, 0),
                            i.lookAt(1, 0, 0),
                            this.add(i);
                        const r = new On(Nn, 1, t, e);
                        (r.layers = this.layers),
                            r.up.set(0, 1, 0),
                            r.lookAt(-1, 0, 0),
                            this.add(r);
                        const a = new On(Nn, 1, t, e);
                        (a.layers = this.layers),
                            a.up.set(0, 0, -1),
                            a.lookAt(0, 1, 0),
                            this.add(a);
                        const o = new On(Nn, 1, t, e);
                        (o.layers = this.layers),
                            o.up.set(0, 0, 1),
                            o.lookAt(0, -1, 0),
                            this.add(o);
                        const s = new On(Nn, 1, t, e);
                        (s.layers = this.layers),
                            s.up.set(0, 1, 0),
                            s.lookAt(0, 0, 1),
                            this.add(s);
                        const l = new On(Nn, 1, t, e);
                        (l.layers = this.layers),
                            l.up.set(0, 1, 0),
                            l.lookAt(0, 0, -1),
                            this.add(l);
                    }
                    update(t, e) {
                        null === this.parent && this.updateMatrixWorld();
                        const n = this.renderTarget,
                            [i, r, a, o, s, l] = this.children,
                            c = t.getRenderTarget(),
                            u = t.toneMapping,
                            h = t.xr.enabled;
                        (t.toneMapping = 0), (t.xr.enabled = !1);
                        const d = n.texture.generateMipmaps;
                        (n.texture.generateMipmaps = !1),
                            t.setRenderTarget(n, 0),
                            t.render(e, i),
                            t.setRenderTarget(n, 1),
                            t.render(e, r),
                            t.setRenderTarget(n, 2),
                            t.render(e, a),
                            t.setRenderTarget(n, 3),
                            t.render(e, o),
                            t.setRenderTarget(n, 4),
                            t.render(e, s),
                            (n.texture.generateMipmaps = d),
                            t.setRenderTarget(n, 5),
                            t.render(e, l),
                            t.setRenderTarget(c),
                            (t.toneMapping = u),
                            (t.xr.enabled = h),
                            (n.texture.needsPMREMUpdate = !0);
                    }
                }
                class zn extends xt {
                    constructor(t, e, n, i, r, a, o, s, l, u) {
                        super(
                            (t = void 0 !== t ? t : []),
                            (e = void 0 !== e ? e : c),
                            n,
                            i,
                            r,
                            a,
                            o,
                            s,
                            l,
                            u
                        ),
                            (this.isCubeTexture = !0),
                            (this.flipY = !1);
                    }
                    get images() {
                        return this.image;
                    }
                    set images(t) {
                        this.image = t;
                    }
                }
                class Bn extends Mt {
                    constructor(t = 1, e = {}) {
                        super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
                        const n = { width: t, height: t, depth: 1 },
                            i = [n, n, n, n, n, n];
                        void 0 !== e.encoding &&
                            (ot(
                                'THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.'
                            ),
                            (e.colorSpace = e.encoding === N ? F : '')),
                            (this.texture = new zn(
                                i,
                                e.mapping,
                                e.wrapS,
                                e.wrapT,
                                e.magFilter,
                                e.minFilter,
                                e.format,
                                e.type,
                                e.anisotropy,
                                e.colorSpace
                            )),
                            (this.texture.isRenderTargetTexture = !0),
                            (this.texture.generateMipmaps =
                                void 0 !== e.generateMipmaps &&
                                e.generateMipmaps),
                            (this.texture.minFilter =
                                void 0 !== e.minFilter ? e.minFilter : v);
                    }
                    fromEquirectangularTexture(t, e) {
                        (this.texture.type = e.type),
                            (this.texture.colorSpace = e.colorSpace),
                            (this.texture.generateMipmaps = e.generateMipmaps),
                            (this.texture.minFilter = e.minFilter),
                            (this.texture.magFilter = e.magFilter);
                        const n = { tEquirect: { value: null } },
                            i =
                                '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
                            r =
                                '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t',
                            a = new Cn(5, 5, 5),
                            s = new In({
                                name: 'CubemapFromEquirect',
                                uniforms: Rn(n),
                                vertexShader: i,
                                fragmentShader: r,
                                side: o,
                                blending: 0,
                            });
                        s.uniforms.tEquirect.value = e;
                        const l = new wn(a, s),
                            c = e.minFilter;
                        return (
                            e.minFilter === _ && (e.minFilter = v),
                            new Fn(1, 10, this).update(t, l),
                            (e.minFilter = c),
                            l.geometry.dispose(),
                            l.material.dispose(),
                            this
                        );
                    }
                    clear(t, e, n, i) {
                        const r = t.getRenderTarget();
                        for (let r = 0; r < 6; r++)
                            t.setRenderTarget(this, r), t.clear(e, n, i);
                        t.setRenderTarget(r);
                    }
                }
                const kn = new Tt(),
                    Hn = new Tt(),
                    Gn = new et();
                class Vn {
                    constructor(t = new Tt(1, 0, 0), e = 0) {
                        (this.isPlane = !0),
                            (this.normal = t),
                            (this.constant = e);
                    }
                    set(t, e) {
                        return this.normal.copy(t), (this.constant = e), this;
                    }
                    setComponents(t, e, n, i) {
                        return (
                            this.normal.set(t, e, n), (this.constant = i), this
                        );
                    }
                    setFromNormalAndCoplanarPoint(t, e) {
                        return (
                            this.normal.copy(t),
                            (this.constant = -e.dot(this.normal)),
                            this
                        );
                    }
                    setFromCoplanarPoints(t, e, n) {
                        const i = kn
                            .subVectors(n, e)
                            .cross(Hn.subVectors(t, e))
                            .normalize();
                        return this.setFromNormalAndCoplanarPoint(i, t), this;
                    }
                    copy(t) {
                        return (
                            this.normal.copy(t.normal),
                            (this.constant = t.constant),
                            this
                        );
                    }
                    normalize() {
                        const t = 1 / this.normal.length();
                        return (
                            this.normal.multiplyScalar(t),
                            (this.constant *= t),
                            this
                        );
                    }
                    negate() {
                        return (
                            (this.constant *= -1), this.normal.negate(), this
                        );
                    }
                    distanceToPoint(t) {
                        return this.normal.dot(t) + this.constant;
                    }
                    distanceToSphere(t) {
                        return this.distanceToPoint(t.center) - t.radius;
                    }
                    projectPoint(t, e) {
                        return e
                            .copy(t)
                            .addScaledVector(
                                this.normal,
                                -this.distanceToPoint(t)
                            );
                    }
                    intersectLine(t, e) {
                        const n = t.delta(kn),
                            i = this.normal.dot(n);
                        if (0 === i)
                            return 0 === this.distanceToPoint(t.start)
                                ? e.copy(t.start)
                                : null;
                        const r =
                            -(t.start.dot(this.normal) + this.constant) / i;
                        return r < 0 || r > 1
                            ? null
                            : e.copy(t.start).addScaledVector(n, r);
                    }
                    intersectsLine(t) {
                        const e = this.distanceToPoint(t.start),
                            n = this.distanceToPoint(t.end);
                        return (e < 0 && n > 0) || (n < 0 && e > 0);
                    }
                    intersectsBox(t) {
                        return t.intersectsPlane(this);
                    }
                    intersectsSphere(t) {
                        return t.intersectsPlane(this);
                    }
                    coplanarPoint(t) {
                        return t
                            .copy(this.normal)
                            .multiplyScalar(-this.constant);
                    }
                    applyMatrix4(t, e) {
                        const n = e || Gn.getNormalMatrix(t),
                            i = this.coplanarPoint(kn).applyMatrix4(t),
                            r = this.normal.applyMatrix3(n).normalize();
                        return (this.constant = -i.dot(r)), this;
                    }
                    translate(t) {
                        return (this.constant -= t.dot(this.normal)), this;
                    }
                    equals(t) {
                        return (
                            t.normal.equals(this.normal) &&
                            t.constant === this.constant
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                const Wn = new Xt(),
                    jn = new Tt();
                class Xn {
                    constructor(
                        t = new Vn(),
                        e = new Vn(),
                        n = new Vn(),
                        i = new Vn(),
                        r = new Vn(),
                        a = new Vn()
                    ) {
                        this.planes = [t, e, n, i, r, a];
                    }
                    set(t, e, n, i, r, a) {
                        const o = this.planes;
                        return (
                            o[0].copy(t),
                            o[1].copy(e),
                            o[2].copy(n),
                            o[3].copy(i),
                            o[4].copy(r),
                            o[5].copy(a),
                            this
                        );
                    }
                    copy(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                        return this;
                    }
                    setFromProjectionMatrix(t) {
                        const e = this.planes,
                            n = t.elements,
                            i = n[0],
                            r = n[1],
                            a = n[2],
                            o = n[3],
                            s = n[4],
                            l = n[5],
                            c = n[6],
                            u = n[7],
                            h = n[8],
                            d = n[9],
                            p = n[10],
                            f = n[11],
                            m = n[12],
                            g = n[13],
                            v = n[14],
                            _ = n[15];
                        return (
                            e[0]
                                .setComponents(o - i, u - s, f - h, _ - m)
                                .normalize(),
                            e[1]
                                .setComponents(o + i, u + s, f + h, _ + m)
                                .normalize(),
                            e[2]
                                .setComponents(o + r, u + l, f + d, _ + g)
                                .normalize(),
                            e[3]
                                .setComponents(o - r, u - l, f - d, _ - g)
                                .normalize(),
                            e[4]
                                .setComponents(o - a, u - c, f - p, _ - v)
                                .normalize(),
                            e[5]
                                .setComponents(o + a, u + c, f + p, _ + v)
                                .normalize(),
                            this
                        );
                    }
                    intersectsObject(t) {
                        if (void 0 !== t.boundingSphere)
                            null === t.boundingSphere &&
                                t.computeBoundingSphere(),
                                Wn.copy(t.boundingSphere).applyMatrix4(
                                    t.matrixWorld
                                );
                        else {
                            const e = t.geometry;
                            null === e.boundingSphere &&
                                e.computeBoundingSphere(),
                                Wn.copy(e.boundingSphere).applyMatrix4(
                                    t.matrixWorld
                                );
                        }
                        return this.intersectsSphere(Wn);
                    }
                    intersectsSprite(t) {
                        return (
                            Wn.center.set(0, 0, 0),
                            (Wn.radius = 0.7071067811865476),
                            Wn.applyMatrix4(t.matrixWorld),
                            this.intersectsSphere(Wn)
                        );
                    }
                    intersectsSphere(t) {
                        const e = this.planes,
                            n = t.center,
                            i = -t.radius;
                        for (let t = 0; t < 6; t++)
                            if (e[t].distanceToPoint(n) < i) return !1;
                        return !0;
                    }
                    intersectsBox(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const i = e[n];
                            if (
                                ((jn.x = i.normal.x > 0 ? t.max.x : t.min.x),
                                (jn.y = i.normal.y > 0 ? t.max.y : t.min.y),
                                (jn.z = i.normal.z > 0 ? t.max.z : t.min.z),
                                i.distanceToPoint(jn) < 0)
                            )
                                return !1;
                        }
                        return !0;
                    }
                    containsPoint(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (e[n].distanceToPoint(t) < 0) return !1;
                        return !0;
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                function Yn() {
                    let t = null,
                        e = !1,
                        n = null,
                        i = null;
                    function r(e, a) {
                        n(e, a), (i = t.requestAnimationFrame(r));
                    }
                    return {
                        start: function () {
                            !0 !== e &&
                                null !== n &&
                                ((i = t.requestAnimationFrame(r)), (e = !0));
                        },
                        stop: function () {
                            t.cancelAnimationFrame(i), (e = !1);
                        },
                        setAnimationLoop: function (t) {
                            n = t;
                        },
                        setContext: function (e) {
                            t = e;
                        },
                    };
                }
                function qn(t, e) {
                    const n = e.isWebGL2,
                        i = new WeakMap();
                    return {
                        get: function (t) {
                            return (
                                t.isInterleavedBufferAttribute && (t = t.data),
                                i.get(t)
                            );
                        },
                        remove: function (e) {
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const n = i.get(e);
                            n && (t.deleteBuffer(n.buffer), i.delete(e));
                        },
                        update: function (e, r) {
                            if (e.isGLBufferAttribute) {
                                const t = i.get(e);
                                return void (
                                    (!t || t.version < e.version) &&
                                    i.set(e, {
                                        buffer: e.buffer,
                                        type: e.type,
                                        bytesPerElement: e.elementSize,
                                        version: e.version,
                                    })
                                );
                            }
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const a = i.get(e);
                            void 0 === a
                                ? i.set(
                                      e,
                                      (function (e, i) {
                                          const r = e.array,
                                              a = e.usage,
                                              o = t.createBuffer();
                                          let s;
                                          if (
                                              (t.bindBuffer(i, o),
                                              t.bufferData(i, r, a),
                                              e.onUploadCallback(),
                                              r instanceof Float32Array)
                                          )
                                              s = t.FLOAT;
                                          else if (r instanceof Uint16Array)
                                              if (e.isFloat16BufferAttribute) {
                                                  if (!n)
                                                      throw new Error(
                                                          'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.'
                                                      );
                                                  s = t.HALF_FLOAT;
                                              } else s = t.UNSIGNED_SHORT;
                                          else if (r instanceof Int16Array)
                                              s = t.SHORT;
                                          else if (r instanceof Uint32Array)
                                              s = t.UNSIGNED_INT;
                                          else if (r instanceof Int32Array)
                                              s = t.INT;
                                          else if (r instanceof Int8Array)
                                              s = t.BYTE;
                                          else if (r instanceof Uint8Array)
                                              s = t.UNSIGNED_BYTE;
                                          else {
                                              if (
                                                  !(
                                                      r instanceof
                                                      Uint8ClampedArray
                                                  )
                                              )
                                                  throw new Error(
                                                      'THREE.WebGLAttributes: Unsupported buffer data format: ' +
                                                          r
                                                  );
                                              s = t.UNSIGNED_BYTE;
                                          }
                                          return {
                                              buffer: o,
                                              type: s,
                                              bytesPerElement:
                                                  r.BYTES_PER_ELEMENT,
                                              version: e.version,
                                          };
                                      })(e, r)
                                  )
                                : a.version < e.version &&
                                  ((function (e, i, r) {
                                      const a = i.array,
                                          o = i.updateRange;
                                      t.bindBuffer(r, e),
                                          -1 === o.count
                                              ? t.bufferSubData(r, 0, a)
                                              : (n
                                                    ? t.bufferSubData(
                                                          r,
                                                          o.offset *
                                                              a.BYTES_PER_ELEMENT,
                                                          a,
                                                          o.offset,
                                                          o.count
                                                      )
                                                    : t.bufferSubData(
                                                          r,
                                                          o.offset *
                                                              a.BYTES_PER_ELEMENT,
                                                          a.subarray(
                                                              o.offset,
                                                              o.offset + o.count
                                                          )
                                                      ),
                                                (o.count = -1)),
                                          i.onUploadCallback();
                                  })(a.buffer, e, r),
                                  (a.version = e.version));
                        },
                    };
                }
                class Kn extends ln {
                    constructor(t = 1, e = 1, n = 1, i = 1) {
                        super(),
                            (this.type = 'PlaneGeometry'),
                            (this.parameters = {
                                width: t,
                                height: e,
                                widthSegments: n,
                                heightSegments: i,
                            });
                        const r = t / 2,
                            a = e / 2,
                            o = Math.floor(n),
                            s = Math.floor(i),
                            l = o + 1,
                            c = s + 1,
                            u = t / o,
                            h = e / s,
                            d = [],
                            p = [],
                            f = [],
                            m = [];
                        for (let t = 0; t < c; t++) {
                            const e = t * h - a;
                            for (let n = 0; n < l; n++) {
                                const i = n * u - r;
                                p.push(i, -e, 0),
                                    f.push(0, 0, 1),
                                    m.push(n / o),
                                    m.push(1 - t / s);
                            }
                        }
                        for (let t = 0; t < s; t++)
                            for (let e = 0; e < o; e++) {
                                const n = e + l * t,
                                    i = e + l * (t + 1),
                                    r = e + 1 + l * (t + 1),
                                    a = e + 1 + l * t;
                                d.push(n, i, a), d.push(i, r, a);
                            }
                        this.setIndex(d),
                            this.setAttribute('position', new $e(p, 3)),
                            this.setAttribute('normal', new $e(f, 3)),
                            this.setAttribute('uv', new $e(m, 2));
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.parameters = Object.assign({}, t.parameters)),
                            this
                        );
                    }
                    static fromJSON(t) {
                        return new Kn(
                            t.width,
                            t.height,
                            t.widthSegments,
                            t.heightSegments
                        );
                    }
                }
                const Zn = {
                        alphamap_fragment:
                            '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif',
                        alphamap_pars_fragment:
                            '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
                        alphatest_fragment:
                            '#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif',
                        alphatest_pars_fragment:
                            '#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif',
                        aomap_fragment:
                            '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif',
                        aomap_pars_fragment:
                            '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
                        begin_vertex: 'vec3 transformed = vec3( position );',
                        beginnormal_vertex:
                            'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
                        bsdfs: 'float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated',
                        iridescence_fragment:
                            '#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif',
                        bumpmap_pars_fragment:
                            '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
                        clipping_planes_fragment:
                            '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
                        clipping_planes_pars_fragment:
                            '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
                        clipping_planes_pars_vertex:
                            '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
                        clipping_planes_vertex:
                            '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
                        color_fragment:
                            '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
                        color_pars_fragment:
                            '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
                        color_pars_vertex:
                            '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif',
                        color_vertex:
                            '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif',
                        common: '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated',
                        cube_uv_reflection_fragment:
                            '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
                        defaultnormal_vertex:
                            'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
                        displacementmap_pars_vertex:
                            '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
                        displacementmap_vertex:
                            '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif',
                        emissivemap_fragment:
                            '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
                        emissivemap_pars_fragment:
                            '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
                        encodings_fragment:
                            'gl_FragColor = linearToOutputTexel( gl_FragColor );',
                        encodings_pars_fragment:
                            'vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}',
                        envmap_fragment:
                            '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
                        envmap_common_pars_fragment:
                            '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
                        envmap_pars_fragment:
                            '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
                        envmap_pars_vertex:
                            '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
                        envmap_physical_pars_fragment:
                            '#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif',
                        envmap_vertex:
                            '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
                        fog_vertex:
                            '#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif',
                        fog_pars_vertex:
                            '#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif',
                        fog_fragment:
                            '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
                        fog_pars_fragment:
                            '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
                        gradientmap_pars_fragment:
                            '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}',
                        lightmap_fragment:
                            '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif',
                        lightmap_pars_fragment:
                            '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
                        lights_lambert_fragment:
                            'LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;',
                        lights_lambert_pars_fragment:
                            'varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert',
                        lights_pars_begin:
                            'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif',
                        lights_toon_fragment:
                            'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
                        lights_toon_pars_fragment:
                            'varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon',
                        lights_phong_fragment:
                            'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
                        lights_phong_pars_fragment:
                            'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong',
                        lights_physical_fragment:
                            'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif',
                        lights_physical_pars_fragment:
                            'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
                        lights_fragment_begin:
                            '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
                        lights_fragment_maps:
                            '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif',
                        lights_fragment_end:
                            '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
                        logdepthbuf_fragment:
                            '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
                        logdepthbuf_pars_fragment:
                            '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
                        logdepthbuf_pars_vertex:
                            '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
                        logdepthbuf_vertex:
                            '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
                        map_fragment:
                            '#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif',
                        map_pars_fragment:
                            '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
                        map_particle_fragment:
                            '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
                        map_particle_pars_fragment:
                            '#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
                        metalnessmap_fragment:
                            'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
                        metalnessmap_pars_fragment:
                            '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
                        morphcolor_vertex:
                            '#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif',
                        morphnormal_vertex:
                            '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif',
                        morphtarget_pars_vertex:
                            '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif',
                        morphtarget_vertex:
                            '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif',
                        normal_fragment_begin:
                            'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_NORMALMAP_TANGENTSPACE\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
                        normal_fragment_maps:
                            '#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
                        normal_pars_fragment:
                            '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
                        normal_pars_vertex:
                            '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
                        normal_vertex:
                            '#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif',
                        normalmap_pars_fragment:
                            '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif',
                        clearcoat_normal_fragment_begin:
                            '#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
                        clearcoat_normal_fragment_maps:
                            '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif',
                        clearcoat_pars_fragment:
                            '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif',
                        iridescence_pars_fragment:
                            '#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif',
                        output_fragment:
                            '#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );',
                        packing:
                            'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}',
                        premultiplied_alpha_fragment:
                            '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
                        project_vertex:
                            'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
                        dithering_fragment:
                            '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
                        dithering_pars_fragment:
                            '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
                        roughnessmap_fragment:
                            'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
                        roughnessmap_pars_fragment:
                            '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
                        shadowmap_pars_fragment:
                            '#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
                        shadowmap_pars_vertex:
                            '#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
                        shadowmap_vertex:
                            '#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif',
                        shadowmask_pars_fragment:
                            'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
                        skinbase_vertex:
                            '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
                        skinning_pars_vertex:
                            '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif',
                        skinning_vertex:
                            '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
                        skinnormal_vertex:
                            '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
                        specularmap_fragment:
                            'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
                        specularmap_pars_fragment:
                            '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
                        tonemapping_fragment:
                            '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
                        tonemapping_pars_fragment:
                            '#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
                        transmission_fragment:
                            '#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif',
                        transmission_pars_fragment:
                            '#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif',
                        uv_pars_fragment:
                            '#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif',
                        uv_pars_vertex:
                            '#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif',
                        uv_vertex:
                            '#ifdef USE_UV\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif',
                        worldpos_vertex:
                            '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
                        background_vert:
                            'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
                        background_frag:
                            'uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                        backgroundCube_vert:
                            'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
                        backgroundCube_frag:
                            '#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                        cube_vert:
                            'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
                        cube_frag:
                            'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                        depth_vert:
                            '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
                        depth_frag:
                            '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
                        distanceRGBA_vert:
                            '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
                        distanceRGBA_frag:
                            '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
                        equirect_vert:
                            'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
                        equirect_frag:
                            'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                        linedashed_vert:
                            'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
                        linedashed_frag:
                            'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
                        meshbasic_vert:
                            '#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
                        meshbasic_frag:
                            'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                        meshlambert_vert:
                            '#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                        meshlambert_frag:
                            '#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                        meshmatcap_vert:
                            '#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
                        meshmatcap_frag:
                            '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                        meshnormal_vert:
                            '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
                        meshnormal_frag:
                            '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}',
                        meshphong_vert:
                            '#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                        meshphong_frag:
                            '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                        meshphysical_vert:
                            '#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}',
                        meshphysical_frag:
                            '#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                        meshtoon_vert:
                            '#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                        meshtoon_frag:
                            '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                        points_vert:
                            'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
                        points_frag:
                            'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
                        shadow_vert:
                            '#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                        shadow_frag:
                            'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
                        sprite_vert:
                            'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
                        sprite_frag:
                            'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
                    },
                    Jn = {
                        common: {
                            diffuse: { value: new je(16777215) },
                            opacity: { value: 1 },
                            map: { value: null },
                            mapTransform: { value: new et() },
                            alphaMap: { value: null },
                            alphaMapTransform: { value: new et() },
                            alphaTest: { value: 0 },
                        },
                        specularmap: {
                            specularMap: { value: null },
                            specularMapTransform: { value: new et() },
                        },
                        envmap: {
                            envMap: { value: null },
                            flipEnvMap: { value: -1 },
                            reflectivity: { value: 1 },
                            ior: { value: 1.5 },
                            refractionRatio: { value: 0.98 },
                        },
                        aomap: {
                            aoMap: { value: null },
                            aoMapIntensity: { value: 1 },
                            aoMapTransform: { value: new et() },
                        },
                        lightmap: {
                            lightMap: { value: null },
                            lightMapIntensity: { value: 1 },
                            lightMapTransform: { value: new et() },
                        },
                        bumpmap: {
                            bumpMap: { value: null },
                            bumpMapTransform: { value: new et() },
                            bumpScale: { value: 1 },
                        },
                        normalmap: {
                            normalMap: { value: null },
                            normalMapTransform: { value: new et() },
                            normalScale: { value: new tt(1, 1) },
                        },
                        displacementmap: {
                            displacementMap: { value: null },
                            displacementMapTransform: { value: new et() },
                            displacementScale: { value: 1 },
                            displacementBias: { value: 0 },
                        },
                        emissivemap: {
                            emissiveMap: { value: null },
                            emissiveMapTransform: { value: new et() },
                        },
                        metalnessmap: {
                            metalnessMap: { value: null },
                            metalnessMapTransform: { value: new et() },
                        },
                        roughnessmap: {
                            roughnessMap: { value: null },
                            roughnessMapTransform: { value: new et() },
                        },
                        gradientmap: { gradientMap: { value: null } },
                        fog: {
                            fogDensity: { value: 25e-5 },
                            fogNear: { value: 1 },
                            fogFar: { value: 2e3 },
                            fogColor: { value: new je(16777215) },
                        },
                        lights: {
                            ambientLightColor: { value: [] },
                            lightProbe: { value: [] },
                            directionalLights: {
                                value: [],
                                properties: { direction: {}, color: {} },
                            },
                            directionalLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                },
                            },
                            directionalShadowMap: { value: [] },
                            directionalShadowMatrix: { value: [] },
                            spotLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    direction: {},
                                    distance: {},
                                    coneCos: {},
                                    penumbraCos: {},
                                    decay: {},
                                },
                            },
                            spotLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                },
                            },
                            spotLightMap: { value: [] },
                            spotShadowMap: { value: [] },
                            spotLightMatrix: { value: [] },
                            pointLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    decay: {},
                                    distance: {},
                                },
                            },
                            pointLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                    shadowCameraNear: {},
                                    shadowCameraFar: {},
                                },
                            },
                            pointShadowMap: { value: [] },
                            pointShadowMatrix: { value: [] },
                            hemisphereLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    skyColor: {},
                                    groundColor: {},
                                },
                            },
                            rectAreaLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    width: {},
                                    height: {},
                                },
                            },
                            ltc_1: { value: null },
                            ltc_2: { value: null },
                        },
                        points: {
                            diffuse: { value: new je(16777215) },
                            opacity: { value: 1 },
                            size: { value: 1 },
                            scale: { value: 1 },
                            map: { value: null },
                            alphaMap: { value: null },
                            alphaTest: { value: 0 },
                            uvTransform: { value: new et() },
                        },
                        sprite: {
                            diffuse: { value: new je(16777215) },
                            opacity: { value: 1 },
                            center: { value: new tt(0.5, 0.5) },
                            rotation: { value: 0 },
                            map: { value: null },
                            mapTransform: { value: new et() },
                            alphaMap: { value: null },
                            alphaTest: { value: 0 },
                        },
                    },
                    Qn = {
                        basic: {
                            uniforms: Ln([
                                Jn.common,
                                Jn.specularmap,
                                Jn.envmap,
                                Jn.aomap,
                                Jn.lightmap,
                                Jn.fog,
                            ]),
                            vertexShader: Zn.meshbasic_vert,
                            fragmentShader: Zn.meshbasic_frag,
                        },
                        lambert: {
                            uniforms: Ln([
                                Jn.common,
                                Jn.specularmap,
                                Jn.envmap,
                                Jn.aomap,
                                Jn.lightmap,
                                Jn.emissivemap,
                                Jn.bumpmap,
                                Jn.normalmap,
                                Jn.displacementmap,
                                Jn.fog,
                                Jn.lights,
                                { emissive: { value: new je(0) } },
                            ]),
                            vertexShader: Zn.meshlambert_vert,
                            fragmentShader: Zn.meshlambert_frag,
                        },
                        phong: {
                            uniforms: Ln([
                                Jn.common,
                                Jn.specularmap,
                                Jn.envmap,
                                Jn.aomap,
                                Jn.lightmap,
                                Jn.emissivemap,
                                Jn.bumpmap,
                                Jn.normalmap,
                                Jn.displacementmap,
                                Jn.fog,
                                Jn.lights,
                                {
                                    emissive: { value: new je(0) },
                                    specular: { value: new je(1118481) },
                                    shininess: { value: 30 },
                                },
                            ]),
                            vertexShader: Zn.meshphong_vert,
                            fragmentShader: Zn.meshphong_frag,
                        },
                        standard: {
                            uniforms: Ln([
                                Jn.common,
                                Jn.envmap,
                                Jn.aomap,
                                Jn.lightmap,
                                Jn.emissivemap,
                                Jn.bumpmap,
                                Jn.normalmap,
                                Jn.displacementmap,
                                Jn.roughnessmap,
                                Jn.metalnessmap,
                                Jn.fog,
                                Jn.lights,
                                {
                                    emissive: { value: new je(0) },
                                    roughness: { value: 1 },
                                    metalness: { value: 0 },
                                    envMapIntensity: { value: 1 },
                                },
                            ]),
                            vertexShader: Zn.meshphysical_vert,
                            fragmentShader: Zn.meshphysical_frag,
                        },
                        toon: {
                            uniforms: Ln([
                                Jn.common,
                                Jn.aomap,
                                Jn.lightmap,
                                Jn.emissivemap,
                                Jn.bumpmap,
                                Jn.normalmap,
                                Jn.displacementmap,
                                Jn.gradientmap,
                                Jn.fog,
                                Jn.lights,
                                { emissive: { value: new je(0) } },
                            ]),
                            vertexShader: Zn.meshtoon_vert,
                            fragmentShader: Zn.meshtoon_frag,
                        },
                        matcap: {
                            uniforms: Ln([
                                Jn.common,
                                Jn.bumpmap,
                                Jn.normalmap,
                                Jn.displacementmap,
                                Jn.fog,
                                { matcap: { value: null } },
                            ]),
                            vertexShader: Zn.meshmatcap_vert,
                            fragmentShader: Zn.meshmatcap_frag,
                        },
                        points: {
                            uniforms: Ln([Jn.points, Jn.fog]),
                            vertexShader: Zn.points_vert,
                            fragmentShader: Zn.points_frag,
                        },
                        dashed: {
                            uniforms: Ln([
                                Jn.common,
                                Jn.fog,
                                {
                                    scale: { value: 1 },
                                    dashSize: { value: 1 },
                                    totalSize: { value: 2 },
                                },
                            ]),
                            vertexShader: Zn.linedashed_vert,
                            fragmentShader: Zn.linedashed_frag,
                        },
                        depth: {
                            uniforms: Ln([Jn.common, Jn.displacementmap]),
                            vertexShader: Zn.depth_vert,
                            fragmentShader: Zn.depth_frag,
                        },
                        normal: {
                            uniforms: Ln([
                                Jn.common,
                                Jn.bumpmap,
                                Jn.normalmap,
                                Jn.displacementmap,
                                { opacity: { value: 1 } },
                            ]),
                            vertexShader: Zn.meshnormal_vert,
                            fragmentShader: Zn.meshnormal_frag,
                        },
                        sprite: {
                            uniforms: Ln([Jn.sprite, Jn.fog]),
                            vertexShader: Zn.sprite_vert,
                            fragmentShader: Zn.sprite_frag,
                        },
                        background: {
                            uniforms: {
                                uvTransform: { value: new et() },
                                t2D: { value: null },
                                backgroundIntensity: { value: 1 },
                            },
                            vertexShader: Zn.background_vert,
                            fragmentShader: Zn.background_frag,
                        },
                        backgroundCube: {
                            uniforms: {
                                envMap: { value: null },
                                flipEnvMap: { value: -1 },
                                backgroundBlurriness: { value: 0 },
                                backgroundIntensity: { value: 1 },
                            },
                            vertexShader: Zn.backgroundCube_vert,
                            fragmentShader: Zn.backgroundCube_frag,
                        },
                        cube: {
                            uniforms: {
                                tCube: { value: null },
                                tFlip: { value: -1 },
                                opacity: { value: 1 },
                            },
                            vertexShader: Zn.cube_vert,
                            fragmentShader: Zn.cube_frag,
                        },
                        equirect: {
                            uniforms: { tEquirect: { value: null } },
                            vertexShader: Zn.equirect_vert,
                            fragmentShader: Zn.equirect_frag,
                        },
                        distanceRGBA: {
                            uniforms: Ln([
                                Jn.common,
                                Jn.displacementmap,
                                {
                                    referencePosition: { value: new Tt() },
                                    nearDistance: { value: 1 },
                                    farDistance: { value: 1e3 },
                                },
                            ]),
                            vertexShader: Zn.distanceRGBA_vert,
                            fragmentShader: Zn.distanceRGBA_frag,
                        },
                        shadow: {
                            uniforms: Ln([
                                Jn.lights,
                                Jn.fog,
                                {
                                    color: { value: new je(0) },
                                    opacity: { value: 1 },
                                },
                            ]),
                            vertexShader: Zn.shadow_vert,
                            fragmentShader: Zn.shadow_frag,
                        },
                    };
                Qn.physical = {
                    uniforms: Ln([
                        Qn.standard.uniforms,
                        {
                            clearcoat: { value: 0 },
                            clearcoatMap: { value: null },
                            clearcoatMapTransform: { value: new et() },
                            clearcoatNormalMap: { value: null },
                            clearcoatNormalMapTransform: { value: new et() },
                            clearcoatNormalScale: { value: new tt(1, 1) },
                            clearcoatRoughness: { value: 0 },
                            clearcoatRoughnessMap: { value: null },
                            clearcoatRoughnessMapTransform: { value: new et() },
                            iridescence: { value: 0 },
                            iridescenceMap: { value: null },
                            iridescenceMapTransform: { value: new et() },
                            iridescenceIOR: { value: 1.3 },
                            iridescenceThicknessMinimum: { value: 100 },
                            iridescenceThicknessMaximum: { value: 400 },
                            iridescenceThicknessMap: { value: null },
                            iridescenceThicknessMapTransform: {
                                value: new et(),
                            },
                            sheen: { value: 0 },
                            sheenColor: { value: new je(0) },
                            sheenColorMap: { value: null },
                            sheenColorMapTransform: { value: new et() },
                            sheenRoughness: { value: 1 },
                            sheenRoughnessMap: { value: null },
                            sheenRoughnessMapTransform: { value: new et() },
                            transmission: { value: 0 },
                            transmissionMap: { value: null },
                            transmissionMapTransform: { value: new et() },
                            transmissionSamplerSize: { value: new tt() },
                            transmissionSamplerMap: { value: null },
                            thickness: { value: 0 },
                            thicknessMap: { value: null },
                            thicknessMapTransform: { value: new et() },
                            attenuationDistance: { value: 0 },
                            attenuationColor: { value: new je(0) },
                            specularColor: { value: new je(1, 1, 1) },
                            specularColorMap: { value: null },
                            specularColorMapTransform: { value: new et() },
                            specularIntensity: { value: 1 },
                            specularIntensityMap: { value: null },
                            specularIntensityMapTransform: { value: new et() },
                        },
                    ]),
                    vertexShader: Zn.meshphysical_vert,
                    fragmentShader: Zn.meshphysical_frag,
                };
                const $n = { r: 0, b: 0, g: 0 };
                function ti(t, e, n, i, r, a, s) {
                    const l = new je(0);
                    let c,
                        u,
                        d = !0 === a ? 0 : 1,
                        p = null,
                        f = 0,
                        m = null;
                    function g(e, n) {
                        e.getRGB($n, Pn(t)),
                            i.buffers.color.setClear($n.r, $n.g, $n.b, n, s);
                    }
                    return {
                        getClearColor: function () {
                            return l;
                        },
                        setClearColor: function (t, e = 1) {
                            l.set(t), (d = e), g(l, d);
                        },
                        getClearAlpha: function () {
                            return d;
                        },
                        setClearAlpha: function (t) {
                            (d = t), g(l, d);
                        },
                        render: function (a, v) {
                            let _ = !1,
                                x = !0 === v.isScene ? v.background : null;
                            switch (
                                (x &&
                                    x.isTexture &&
                                    (x = (
                                        v.backgroundBlurriness > 0 ? n : e
                                    ).get(x)),
                                null === x
                                    ? g(l, d)
                                    : x && x.isColor && (g(x, 1), (_ = !0)),
                                t.xr.getEnvironmentBlendMode())
                            ) {
                                case 'opaque':
                                    _ = !0;
                                    break;
                                case 'additive':
                                    i.buffers.color.setClear(0, 0, 0, 1, s),
                                        (_ = !0);
                                    break;
                                case 'alpha-blend':
                                    i.buffers.color.setClear(0, 0, 0, 0, s),
                                        (_ = !0);
                            }
                            (t.autoClear || _) &&
                                t.clear(
                                    t.autoClearColor,
                                    t.autoClearDepth,
                                    t.autoClearStencil
                                ),
                                x && (x.isCubeTexture || x.mapping === h)
                                    ? (void 0 === u &&
                                          ((u = new wn(
                                              new Cn(1, 1, 1),
                                              new In({
                                                  name: 'BackgroundCubeMaterial',
                                                  uniforms: Rn(
                                                      Qn.backgroundCube.uniforms
                                                  ),
                                                  vertexShader:
                                                      Qn.backgroundCube
                                                          .vertexShader,
                                                  fragmentShader:
                                                      Qn.backgroundCube
                                                          .fragmentShader,
                                                  side: o,
                                                  depthTest: !1,
                                                  depthWrite: !1,
                                                  fog: !1,
                                              })
                                          )),
                                          u.geometry.deleteAttribute('normal'),
                                          u.geometry.deleteAttribute('uv'),
                                          (u.onBeforeRender = function (
                                              t,
                                              e,
                                              n
                                          ) {
                                              this.matrixWorld.copyPosition(
                                                  n.matrixWorld
                                              );
                                          }),
                                          Object.defineProperty(
                                              u.material,
                                              'envMap',
                                              {
                                                  get: function () {
                                                      return this.uniforms
                                                          .envMap.value;
                                                  },
                                              }
                                          ),
                                          r.update(u)),
                                      (u.material.uniforms.envMap.value = x),
                                      (u.material.uniforms.flipEnvMap.value =
                                          x.isCubeTexture &&
                                          !1 === x.isRenderTargetTexture
                                              ? -1
                                              : 1),
                                      (u.material.uniforms.backgroundBlurriness.value =
                                          v.backgroundBlurriness),
                                      (u.material.uniforms.backgroundIntensity.value =
                                          v.backgroundIntensity),
                                      (u.material.toneMapped =
                                          x.colorSpace !== F),
                                      (p === x &&
                                          f === x.version &&
                                          m === t.toneMapping) ||
                                          ((u.material.needsUpdate = !0),
                                          (p = x),
                                          (f = x.version),
                                          (m = t.toneMapping)),
                                      u.layers.enableAll(),
                                      a.unshift(
                                          u,
                                          u.geometry,
                                          u.material,
                                          0,
                                          0,
                                          null
                                      ))
                                    : x &&
                                      x.isTexture &&
                                      (void 0 === c &&
                                          ((c = new wn(
                                              new Kn(2, 2),
                                              new In({
                                                  name: 'BackgroundMaterial',
                                                  uniforms: Rn(
                                                      Qn.background.uniforms
                                                  ),
                                                  vertexShader:
                                                      Qn.background
                                                          .vertexShader,
                                                  fragmentShader:
                                                      Qn.background
                                                          .fragmentShader,
                                                  side: 0,
                                                  depthTest: !1,
                                                  depthWrite: !1,
                                                  fog: !1,
                                              })
                                          )),
                                          c.geometry.deleteAttribute('normal'),
                                          Object.defineProperty(
                                              c.material,
                                              'map',
                                              {
                                                  get: function () {
                                                      return this.uniforms.t2D
                                                          .value;
                                                  },
                                              }
                                          ),
                                          r.update(c)),
                                      (c.material.uniforms.t2D.value = x),
                                      (c.material.uniforms.backgroundIntensity.value =
                                          v.backgroundIntensity),
                                      (c.material.toneMapped =
                                          x.colorSpace !== F),
                                      !0 === x.matrixAutoUpdate &&
                                          x.updateMatrix(),
                                      c.material.uniforms.uvTransform.value.copy(
                                          x.matrix
                                      ),
                                      (p === x &&
                                          f === x.version &&
                                          m === t.toneMapping) ||
                                          ((c.material.needsUpdate = !0),
                                          (p = x),
                                          (f = x.version),
                                          (m = t.toneMapping)),
                                      c.layers.enableAll(),
                                      a.unshift(
                                          c,
                                          c.geometry,
                                          c.material,
                                          0,
                                          0,
                                          null
                                      ));
                        },
                    };
                }
                function ei(t, e, n, i) {
                    const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                        a = i.isWebGL2
                            ? null
                            : e.get('OES_vertex_array_object'),
                        o = i.isWebGL2 || null !== a,
                        s = {},
                        l = p(null);
                    let c = l,
                        u = !1;
                    function h(e) {
                        return i.isWebGL2
                            ? t.bindVertexArray(e)
                            : a.bindVertexArrayOES(e);
                    }
                    function d(e) {
                        return i.isWebGL2
                            ? t.deleteVertexArray(e)
                            : a.deleteVertexArrayOES(e);
                    }
                    function p(t) {
                        const e = [],
                            n = [],
                            i = [];
                        for (let t = 0; t < r; t++)
                            (e[t] = 0), (n[t] = 0), (i[t] = 0);
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: e,
                            enabledAttributes: n,
                            attributeDivisors: i,
                            object: t,
                            attributes: {},
                            index: null,
                        };
                    }
                    function f() {
                        const t = c.newAttributes;
                        for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
                    }
                    function m(t) {
                        g(t, 0);
                    }
                    function g(n, r) {
                        const a = c.newAttributes,
                            o = c.enabledAttributes,
                            s = c.attributeDivisors;
                        (a[n] = 1),
                            0 === o[n] &&
                                (t.enableVertexAttribArray(n), (o[n] = 1)),
                            s[n] !== r &&
                                ((i.isWebGL2
                                    ? t
                                    : e.get('ANGLE_instanced_arrays'))[
                                    i.isWebGL2
                                        ? 'vertexAttribDivisor'
                                        : 'vertexAttribDivisorANGLE'
                                ](n, r),
                                (s[n] = r));
                    }
                    function v() {
                        const e = c.newAttributes,
                            n = c.enabledAttributes;
                        for (let i = 0, r = n.length; i < r; i++)
                            n[i] !== e[i] &&
                                (t.disableVertexAttribArray(i), (n[i] = 0));
                    }
                    function _(e, n, r, a, o, s) {
                        !0 !== i.isWebGL2 ||
                        (r !== t.INT && r !== t.UNSIGNED_INT)
                            ? t.vertexAttribPointer(e, n, r, a, o, s)
                            : t.vertexAttribIPointer(e, n, r, o, s);
                    }
                    function x() {
                        y(), (u = !0), c !== l && ((c = l), h(c.object));
                    }
                    function y() {
                        (l.geometry = null),
                            (l.program = null),
                            (l.wireframe = !1);
                    }
                    return {
                        setup: function (r, l, d, x, y) {
                            let M = !1;
                            if (o) {
                                const e = (function (e, n, r) {
                                    const o = !0 === r.wireframe;
                                    let l = s[e.id];
                                    void 0 === l && ((l = {}), (s[e.id] = l));
                                    let c = l[n.id];
                                    void 0 === c && ((c = {}), (l[n.id] = c));
                                    let u = c[o];
                                    return (
                                        void 0 === u &&
                                            ((u = p(
                                                i.isWebGL2
                                                    ? t.createVertexArray()
                                                    : a.createVertexArrayOES()
                                            )),
                                            (c[o] = u)),
                                        u
                                    );
                                })(x, d, l);
                                c !== e && ((c = e), h(c.object)),
                                    (M = (function (t, e, n, i) {
                                        const r = c.attributes,
                                            a = e.attributes;
                                        let o = 0;
                                        const s = n.getAttributes();
                                        for (const e in s)
                                            if (s[e].location >= 0) {
                                                const n = r[e];
                                                let i = a[e];
                                                if (
                                                    (void 0 === i &&
                                                        ('instanceMatrix' ===
                                                            e &&
                                                            t.instanceMatrix &&
                                                            (i =
                                                                t.instanceMatrix),
                                                        'instanceColor' === e &&
                                                            t.instanceColor &&
                                                            (i =
                                                                t.instanceColor)),
                                                    void 0 === n)
                                                )
                                                    return !0;
                                                if (n.attribute !== i)
                                                    return !0;
                                                if (i && n.data !== i.data)
                                                    return !0;
                                                o++;
                                            }
                                        return (
                                            c.attributesNum !== o ||
                                            c.index !== i
                                        );
                                    })(r, x, d, y)),
                                    M &&
                                        (function (t, e, n, i) {
                                            const r = {},
                                                a = e.attributes;
                                            let o = 0;
                                            const s = n.getAttributes();
                                            for (const e in s)
                                                if (s[e].location >= 0) {
                                                    let n = a[e];
                                                    void 0 === n &&
                                                        ('instanceMatrix' ===
                                                            e &&
                                                            t.instanceMatrix &&
                                                            (n =
                                                                t.instanceMatrix),
                                                        'instanceColor' === e &&
                                                            t.instanceColor &&
                                                            (n =
                                                                t.instanceColor));
                                                    const i = {};
                                                    (i.attribute = n),
                                                        n &&
                                                            n.data &&
                                                            (i.data = n.data),
                                                        (r[e] = i),
                                                        o++;
                                                }
                                            (c.attributes = r),
                                                (c.attributesNum = o),
                                                (c.index = i);
                                        })(r, x, d, y);
                            } else {
                                const t = !0 === l.wireframe;
                                (c.geometry === x.id &&
                                    c.program === d.id &&
                                    c.wireframe === t) ||
                                    ((c.geometry = x.id),
                                    (c.program = d.id),
                                    (c.wireframe = t),
                                    (M = !0));
                            }
                            null !== y && n.update(y, t.ELEMENT_ARRAY_BUFFER),
                                (M || u) &&
                                    ((u = !1),
                                    (function (r, a, o, s) {
                                        if (
                                            !1 === i.isWebGL2 &&
                                            (r.isInstancedMesh ||
                                                s.isInstancedBufferGeometry) &&
                                            null ===
                                                e.get('ANGLE_instanced_arrays')
                                        )
                                            return;
                                        f();
                                        const l = s.attributes,
                                            c = o.getAttributes(),
                                            u = a.defaultAttributeValues;
                                        for (const e in c) {
                                            const i = c[e];
                                            if (i.location >= 0) {
                                                let a = l[e];
                                                if (
                                                    (void 0 === a &&
                                                        ('instanceMatrix' ===
                                                            e &&
                                                            r.instanceMatrix &&
                                                            (a =
                                                                r.instanceMatrix),
                                                        'instanceColor' === e &&
                                                            r.instanceColor &&
                                                            (a =
                                                                r.instanceColor)),
                                                    void 0 !== a)
                                                ) {
                                                    const e = a.normalized,
                                                        o = a.itemSize,
                                                        l = n.get(a);
                                                    if (void 0 === l) continue;
                                                    const c = l.buffer,
                                                        u = l.type,
                                                        h = l.bytesPerElement;
                                                    if (
                                                        a.isInterleavedBufferAttribute
                                                    ) {
                                                        const n = a.data,
                                                            l = n.stride,
                                                            d = a.offset;
                                                        if (
                                                            n.isInstancedInterleavedBuffer
                                                        ) {
                                                            for (
                                                                let t = 0;
                                                                t <
                                                                i.locationSize;
                                                                t++
                                                            )
                                                                g(
                                                                    i.location +
                                                                        t,
                                                                    n.meshPerAttribute
                                                                );
                                                            !0 !==
                                                                r.isInstancedMesh &&
                                                                void 0 ===
                                                                    s._maxInstanceCount &&
                                                                (s._maxInstanceCount =
                                                                    n.meshPerAttribute *
                                                                    n.count);
                                                        } else
                                                            for (
                                                                let t = 0;
                                                                t <
                                                                i.locationSize;
                                                                t++
                                                            )
                                                                m(
                                                                    i.location +
                                                                        t
                                                                );
                                                        t.bindBuffer(
                                                            t.ARRAY_BUFFER,
                                                            c
                                                        );
                                                        for (
                                                            let t = 0;
                                                            t < i.locationSize;
                                                            t++
                                                        )
                                                            _(
                                                                i.location + t,
                                                                o /
                                                                    i.locationSize,
                                                                u,
                                                                e,
                                                                l * h,
                                                                (d +
                                                                    (o /
                                                                        i.locationSize) *
                                                                        t) *
                                                                    h
                                                            );
                                                    } else {
                                                        if (
                                                            a.isInstancedBufferAttribute
                                                        ) {
                                                            for (
                                                                let t = 0;
                                                                t <
                                                                i.locationSize;
                                                                t++
                                                            )
                                                                g(
                                                                    i.location +
                                                                        t,
                                                                    a.meshPerAttribute
                                                                );
                                                            !0 !==
                                                                r.isInstancedMesh &&
                                                                void 0 ===
                                                                    s._maxInstanceCount &&
                                                                (s._maxInstanceCount =
                                                                    a.meshPerAttribute *
                                                                    a.count);
                                                        } else
                                                            for (
                                                                let t = 0;
                                                                t <
                                                                i.locationSize;
                                                                t++
                                                            )
                                                                m(
                                                                    i.location +
                                                                        t
                                                                );
                                                        t.bindBuffer(
                                                            t.ARRAY_BUFFER,
                                                            c
                                                        );
                                                        for (
                                                            let t = 0;
                                                            t < i.locationSize;
                                                            t++
                                                        )
                                                            _(
                                                                i.location + t,
                                                                o /
                                                                    i.locationSize,
                                                                u,
                                                                e,
                                                                o * h,
                                                                (o /
                                                                    i.locationSize) *
                                                                    t *
                                                                    h
                                                            );
                                                    }
                                                } else if (void 0 !== u) {
                                                    const n = u[e];
                                                    if (void 0 !== n)
                                                        switch (n.length) {
                                                            case 2:
                                                                t.vertexAttrib2fv(
                                                                    i.location,
                                                                    n
                                                                );
                                                                break;
                                                            case 3:
                                                                t.vertexAttrib3fv(
                                                                    i.location,
                                                                    n
                                                                );
                                                                break;
                                                            case 4:
                                                                t.vertexAttrib4fv(
                                                                    i.location,
                                                                    n
                                                                );
                                                                break;
                                                            default:
                                                                t.vertexAttrib1fv(
                                                                    i.location,
                                                                    n
                                                                );
                                                        }
                                                }
                                            }
                                        }
                                        v();
                                    })(r, l, d, x),
                                    null !== y &&
                                        t.bindBuffer(
                                            t.ELEMENT_ARRAY_BUFFER,
                                            n.get(y).buffer
                                        ));
                        },
                        reset: x,
                        resetDefaultState: y,
                        dispose: function () {
                            x();
                            for (const t in s) {
                                const e = s[t];
                                for (const t in e) {
                                    const n = e[t];
                                    for (const t in n)
                                        d(n[t].object), delete n[t];
                                    delete e[t];
                                }
                                delete s[t];
                            }
                        },
                        releaseStatesOfGeometry: function (t) {
                            if (void 0 === s[t.id]) return;
                            const e = s[t.id];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) d(n[t].object), delete n[t];
                                delete e[t];
                            }
                            delete s[t.id];
                        },
                        releaseStatesOfProgram: function (t) {
                            for (const e in s) {
                                const n = s[e];
                                if (void 0 === n[t.id]) continue;
                                const i = n[t.id];
                                for (const t in i) d(i[t].object), delete i[t];
                                delete n[t.id];
                            }
                        },
                        initAttributes: f,
                        enableAttribute: m,
                        disableUnusedAttributes: v,
                    };
                }
                function ni(t, e, n, i) {
                    const r = i.isWebGL2;
                    let a;
                    (this.setMode = function (t) {
                        a = t;
                    }),
                        (this.render = function (e, i) {
                            t.drawArrays(a, e, i), n.update(i, a, 1);
                        }),
                        (this.renderInstances = function (i, o, s) {
                            if (0 === s) return;
                            let l, c;
                            if (r) (l = t), (c = 'drawArraysInstanced');
                            else if (
                                ((l = e.get('ANGLE_instanced_arrays')),
                                (c = 'drawArraysInstancedANGLE'),
                                null === l)
                            )
                                return void console.error(
                                    'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
                                );
                            l[c](a, i, o, s), n.update(o, a, s);
                        });
                }
                function ii(t, e, n) {
                    let i;
                    function r(e) {
                        if ('highp' === e) {
                            if (
                                t.getShaderPrecisionFormat(
                                    t.VERTEX_SHADER,
                                    t.HIGH_FLOAT
                                ).precision > 0 &&
                                t.getShaderPrecisionFormat(
                                    t.FRAGMENT_SHADER,
                                    t.HIGH_FLOAT
                                ).precision > 0
                            )
                                return 'highp';
                            e = 'mediump';
                        }
                        return 'mediump' === e &&
                            t.getShaderPrecisionFormat(
                                t.VERTEX_SHADER,
                                t.MEDIUM_FLOAT
                            ).precision > 0 &&
                            t.getShaderPrecisionFormat(
                                t.FRAGMENT_SHADER,
                                t.MEDIUM_FLOAT
                            ).precision > 0
                            ? 'mediump'
                            : 'lowp';
                    }
                    const a =
                        'undefined' != typeof WebGL2RenderingContext &&
                        'WebGL2RenderingContext' === t.constructor.name;
                    let o = void 0 !== n.precision ? n.precision : 'highp';
                    const s = r(o);
                    s !== o &&
                        (console.warn(
                            'THREE.WebGLRenderer:',
                            o,
                            'not supported, using',
                            s,
                            'instead.'
                        ),
                        (o = s));
                    const l = a || e.has('WEBGL_draw_buffers'),
                        c = !0 === n.logarithmicDepthBuffer,
                        u = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                        h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                        d = t.getParameter(t.MAX_TEXTURE_SIZE),
                        p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                        f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                        m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                        g = t.getParameter(t.MAX_VARYING_VECTORS),
                        v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                        _ = h > 0,
                        x = a || e.has('OES_texture_float');
                    return {
                        isWebGL2: a,
                        drawBuffers: l,
                        getMaxAnisotropy: function () {
                            if (void 0 !== i) return i;
                            if (
                                !0 === e.has('EXT_texture_filter_anisotropic')
                            ) {
                                const n = e.get(
                                    'EXT_texture_filter_anisotropic'
                                );
                                i = t.getParameter(
                                    n.MAX_TEXTURE_MAX_ANISOTROPY_EXT
                                );
                            } else i = 0;
                            return i;
                        },
                        getMaxPrecision: r,
                        precision: o,
                        logarithmicDepthBuffer: c,
                        maxTextures: u,
                        maxVertexTextures: h,
                        maxTextureSize: d,
                        maxCubemapSize: p,
                        maxAttributes: f,
                        maxVertexUniforms: m,
                        maxVaryings: g,
                        maxFragmentUniforms: v,
                        vertexTextures: _,
                        floatFragmentTextures: x,
                        floatVertexTextures: _ && x,
                        maxSamples: a ? t.getParameter(t.MAX_SAMPLES) : 0,
                    };
                }
                function ri(t) {
                    const e = this;
                    let n = null,
                        i = 0,
                        r = !1,
                        a = !1;
                    const o = new Vn(),
                        s = new et(),
                        l = { value: null, needsUpdate: !1 };
                    function c(t, n, i, r) {
                        const a = null !== t ? t.length : 0;
                        let c = null;
                        if (0 !== a) {
                            if (((c = l.value), !0 !== r || null === c)) {
                                const e = i + 4 * a,
                                    r = n.matrixWorldInverse;
                                s.getNormalMatrix(r),
                                    (null === c || c.length < e) &&
                                        (c = new Float32Array(e));
                                for (let e = 0, n = i; e !== a; ++e, n += 4)
                                    o.copy(t[e]).applyMatrix4(r, s),
                                        o.normal.toArray(c, n),
                                        (c[n + 3] = o.constant);
                            }
                            (l.value = c), (l.needsUpdate = !0);
                        }
                        return (e.numPlanes = a), (e.numIntersection = 0), c;
                    }
                    (this.uniform = l),
                        (this.numPlanes = 0),
                        (this.numIntersection = 0),
                        (this.init = function (t, e) {
                            const n = 0 !== t.length || e || 0 !== i || r;
                            return (r = e), (i = t.length), n;
                        }),
                        (this.beginShadows = function () {
                            (a = !0), c(null);
                        }),
                        (this.endShadows = function () {
                            a = !1;
                        }),
                        (this.setGlobalState = function (t, e) {
                            n = c(t, e, 0);
                        }),
                        (this.setState = function (o, s, u) {
                            const h = o.clippingPlanes,
                                d = o.clipIntersection,
                                p = o.clipShadows,
                                f = t.get(o);
                            if (!r || null === h || 0 === h.length || (a && !p))
                                a
                                    ? c(null)
                                    : (l.value !== n &&
                                          ((l.value = n),
                                          (l.needsUpdate = i > 0)),
                                      (e.numPlanes = i),
                                      (e.numIntersection = 0));
                            else {
                                const t = a ? 0 : i,
                                    e = 4 * t;
                                let r = f.clippingState || null;
                                (l.value = r), (r = c(h, s, e, u));
                                for (let t = 0; t !== e; ++t) r[t] = n[t];
                                (f.clippingState = r),
                                    (this.numIntersection = d
                                        ? this.numPlanes
                                        : 0),
                                    (this.numPlanes += t);
                            }
                        });
                }
                function ai(t) {
                    let e = new WeakMap();
                    function n(t, e) {
                        return (
                            303 === e
                                ? (t.mapping = c)
                                : 304 === e && (t.mapping = u),
                            t
                        );
                    }
                    function i(t) {
                        const n = t.target;
                        n.removeEventListener('dispose', i);
                        const r = e.get(n);
                        void 0 !== r && (e.delete(n), r.dispose());
                    }
                    return {
                        get: function (r) {
                            if (
                                r &&
                                r.isTexture &&
                                !1 === r.isRenderTargetTexture
                            ) {
                                const a = r.mapping;
                                if (303 === a || 304 === a) {
                                    if (e.has(r))
                                        return n(e.get(r).texture, r.mapping);
                                    {
                                        const a = r.image;
                                        if (a && a.height > 0) {
                                            const o = new Bn(a.height / 2);
                                            return (
                                                o.fromEquirectangularTexture(
                                                    t,
                                                    r
                                                ),
                                                e.set(r, o),
                                                r.addEventListener(
                                                    'dispose',
                                                    i
                                                ),
                                                n(o.texture, r.mapping)
                                            );
                                        }
                                        return null;
                                    }
                                }
                            }
                            return r;
                        },
                        dispose: function () {
                            e = new WeakMap();
                        },
                    };
                }
                class oi extends Un {
                    constructor(
                        t = -1,
                        e = 1,
                        n = 1,
                        i = -1,
                        r = 0.1,
                        a = 2e3
                    ) {
                        super(),
                            (this.isOrthographicCamera = !0),
                            (this.type = 'OrthographicCamera'),
                            (this.zoom = 1),
                            (this.view = null),
                            (this.left = t),
                            (this.right = e),
                            (this.top = n),
                            (this.bottom = i),
                            (this.near = r),
                            (this.far = a),
                            this.updateProjectionMatrix();
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            (this.left = t.left),
                            (this.right = t.right),
                            (this.top = t.top),
                            (this.bottom = t.bottom),
                            (this.near = t.near),
                            (this.far = t.far),
                            (this.zoom = t.zoom),
                            (this.view =
                                null === t.view
                                    ? null
                                    : Object.assign({}, t.view)),
                            this
                        );
                    }
                    setViewOffset(t, e, n, i, r, a) {
                        null === this.view &&
                            (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1,
                            }),
                            (this.view.enabled = !0),
                            (this.view.fullWidth = t),
                            (this.view.fullHeight = e),
                            (this.view.offsetX = n),
                            (this.view.offsetY = i),
                            (this.view.width = r),
                            (this.view.height = a),
                            this.updateProjectionMatrix();
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1),
                            this.updateProjectionMatrix();
                    }
                    updateProjectionMatrix() {
                        const t = (this.right - this.left) / (2 * this.zoom),
                            e = (this.top - this.bottom) / (2 * this.zoom),
                            n = (this.right + this.left) / 2,
                            i = (this.top + this.bottom) / 2;
                        let r = n - t,
                            a = n + t,
                            o = i + e,
                            s = i - e;
                        if (null !== this.view && this.view.enabled) {
                            const t =
                                    (this.right - this.left) /
                                    this.view.fullWidth /
                                    this.zoom,
                                e =
                                    (this.top - this.bottom) /
                                    this.view.fullHeight /
                                    this.zoom;
                            (r += t * this.view.offsetX),
                                (a = r + t * this.view.width),
                                (o -= e * this.view.offsetY),
                                (s = o - e * this.view.height);
                        }
                        this.projectionMatrix.makeOrthographic(
                            r,
                            a,
                            o,
                            s,
                            this.near,
                            this.far
                        ),
                            this.projectionMatrixInverse
                                .copy(this.projectionMatrix)
                                .invert();
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (
                            (e.object.zoom = this.zoom),
                            (e.object.left = this.left),
                            (e.object.right = this.right),
                            (e.object.top = this.top),
                            (e.object.bottom = this.bottom),
                            (e.object.near = this.near),
                            (e.object.far = this.far),
                            null !== this.view &&
                                (e.object.view = Object.assign({}, this.view)),
                            e
                        );
                    }
                }
                const si = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
                    li = new oi(),
                    ci = new je();
                let ui = null;
                const hi = (1 + Math.sqrt(5)) / 2,
                    di = 1 / hi,
                    pi = [
                        new Tt(1, 1, 1),
                        new Tt(-1, 1, 1),
                        new Tt(1, 1, -1),
                        new Tt(-1, 1, -1),
                        new Tt(0, hi, di),
                        new Tt(0, hi, -di),
                        new Tt(di, 0, hi),
                        new Tt(-di, 0, hi),
                        new Tt(hi, di, 0),
                        new Tt(-hi, di, 0),
                    ];
                class fi {
                    constructor(t) {
                        (this._renderer = t),
                            (this._pingPongRenderTarget = null),
                            (this._lodMax = 0),
                            (this._cubeSize = 0),
                            (this._lodPlanes = []),
                            (this._sizeLods = []),
                            (this._sigmas = []),
                            (this._blurMaterial = null),
                            (this._cubemapMaterial = null),
                            (this._equirectMaterial = null),
                            this._compileMaterial(this._blurMaterial);
                    }
                    fromScene(t, e = 0, n = 0.1, i = 100) {
                        (ui = this._renderer.getRenderTarget()),
                            this._setSize(256);
                        const r = this._allocateTargets();
                        return (
                            (r.depthBuffer = !0),
                            this._sceneToCubeUV(t, n, i, r),
                            e > 0 && this._blur(r, 0, 0, e),
                            this._applyPMREM(r),
                            this._cleanup(r),
                            r
                        );
                    }
                    fromEquirectangular(t, e = null) {
                        return this._fromTexture(t, e);
                    }
                    fromCubemap(t, e = null) {
                        return this._fromTexture(t, e);
                    }
                    compileCubemapShader() {
                        null === this._cubemapMaterial &&
                            ((this._cubemapMaterial = _i()),
                            this._compileMaterial(this._cubemapMaterial));
                    }
                    compileEquirectangularShader() {
                        null === this._equirectMaterial &&
                            ((this._equirectMaterial = vi()),
                            this._compileMaterial(this._equirectMaterial));
                    }
                    dispose() {
                        this._dispose(),
                            null !== this._cubemapMaterial &&
                                this._cubemapMaterial.dispose(),
                            null !== this._equirectMaterial &&
                                this._equirectMaterial.dispose();
                    }
                    _setSize(t) {
                        (this._lodMax = Math.floor(Math.log2(t))),
                            (this._cubeSize = Math.pow(2, this._lodMax));
                    }
                    _dispose() {
                        null !== this._blurMaterial &&
                            this._blurMaterial.dispose(),
                            null !== this._pingPongRenderTarget &&
                                this._pingPongRenderTarget.dispose();
                        for (let t = 0; t < this._lodPlanes.length; t++)
                            this._lodPlanes[t].dispose();
                    }
                    _cleanup(t) {
                        this._renderer.setRenderTarget(ui),
                            (t.scissorTest = !1),
                            gi(t, 0, 0, t.width, t.height);
                    }
                    _fromTexture(t, e) {
                        t.mapping === c || t.mapping === u
                            ? this._setSize(
                                  0 === t.image.length
                                      ? 16
                                      : t.image[0].width ||
                                            t.image[0].image.width
                              )
                            : this._setSize(t.image.width / 4),
                            (ui = this._renderer.getRenderTarget());
                        const n = e || this._allocateTargets();
                        return (
                            this._textureToCubeUV(t, n),
                            this._applyPMREM(n),
                            this._cleanup(n),
                            n
                        );
                    }
                    _allocateTargets() {
                        const t = 3 * Math.max(this._cubeSize, 112),
                            e = 4 * this._cubeSize,
                            n = {
                                magFilter: v,
                                minFilter: v,
                                generateMipmaps: !1,
                                type: b,
                                format: S,
                                colorSpace: z,
                                depthBuffer: !1,
                            },
                            i = mi(t, e, n);
                        if (
                            null === this._pingPongRenderTarget ||
                            this._pingPongRenderTarget.width !== t ||
                            this._pingPongRenderTarget.height !== e
                        ) {
                            null !== this._pingPongRenderTarget &&
                                this._dispose(),
                                (this._pingPongRenderTarget = mi(t, e, n));
                            const { _lodMax: i } = this;
                            ({
                                sizeLods: this._sizeLods,
                                lodPlanes: this._lodPlanes,
                                sigmas: this._sigmas,
                            } = (function (t) {
                                const e = [],
                                    n = [],
                                    i = [];
                                let r = t;
                                const a = t - 4 + 1 + si.length;
                                for (let o = 0; o < a; o++) {
                                    const a = Math.pow(2, r);
                                    n.push(a);
                                    let s = 1 / a;
                                    o > t - 4
                                        ? (s = si[o - t + 4 - 1])
                                        : 0 === o && (s = 0),
                                        i.push(s);
                                    const l = 1 / (a - 2),
                                        c = -l,
                                        u = 1 + l,
                                        h = [
                                            c,
                                            c,
                                            u,
                                            c,
                                            u,
                                            u,
                                            c,
                                            c,
                                            u,
                                            u,
                                            c,
                                            u,
                                        ],
                                        d = 6,
                                        p = 6,
                                        f = 3,
                                        m = 2,
                                        g = 1,
                                        v = new Float32Array(f * p * d),
                                        _ = new Float32Array(m * p * d),
                                        x = new Float32Array(g * p * d);
                                    for (let t = 0; t < d; t++) {
                                        const e = ((t % 3) * 2) / 3 - 1,
                                            n = t > 2 ? 0 : -1,
                                            i = [
                                                e,
                                                n,
                                                0,
                                                e + 2 / 3,
                                                n,
                                                0,
                                                e + 2 / 3,
                                                n + 1,
                                                0,
                                                e,
                                                n,
                                                0,
                                                e + 2 / 3,
                                                n + 1,
                                                0,
                                                e,
                                                n + 1,
                                                0,
                                            ];
                                        v.set(i, f * p * t),
                                            _.set(h, m * p * t);
                                        const r = [t, t, t, t, t, t];
                                        x.set(r, g * p * t);
                                    }
                                    const y = new ln();
                                    y.setAttribute('position', new Ze(v, f)),
                                        y.setAttribute('uv', new Ze(_, m)),
                                        y.setAttribute(
                                            'faceIndex',
                                            new Ze(x, g)
                                        ),
                                        e.push(y),
                                        r > 4 && r--;
                                }
                                return { lodPlanes: e, sizeLods: n, sigmas: i };
                            })(i)),
                                (this._blurMaterial = (function (t, e, n) {
                                    const i = new Float32Array(20),
                                        r = new Tt(0, 1, 0);
                                    return new In({
                                        name: 'SphericalGaussianBlur',
                                        defines: {
                                            n: 20,
                                            CUBEUV_TEXEL_WIDTH: 1 / e,
                                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                                            CUBEUV_MAX_MIP: `${t}.0`,
                                        },
                                        uniforms: {
                                            envMap: { value: null },
                                            samples: { value: 1 },
                                            weights: { value: i },
                                            latitudinal: { value: !1 },
                                            dTheta: { value: 0 },
                                            mipInt: { value: 0 },
                                            poleAxis: { value: r },
                                        },
                                        vertexShader:
                                            '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
                                        fragmentShader:
                                            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                        blending: 0,
                                        depthTest: !1,
                                        depthWrite: !1,
                                    });
                                })(i, t, e));
                        }
                        return i;
                    }
                    _compileMaterial(t) {
                        const e = new wn(this._lodPlanes[0], t);
                        this._renderer.compile(e, li);
                    }
                    _sceneToCubeUV(t, e, n, i) {
                        const r = new On(90, 1, e, n),
                            a = [1, -1, 1, 1, 1, 1],
                            s = [1, 1, 1, -1, -1, -1],
                            l = this._renderer,
                            c = l.autoClear,
                            u = l.toneMapping;
                        l.getClearColor(ci),
                            (l.toneMapping = 0),
                            (l.autoClear = !1);
                        const h = new Ye({
                                name: 'PMREM.Background',
                                side: o,
                                depthWrite: !1,
                                depthTest: !1,
                            }),
                            d = new wn(new Cn(), h);
                        let p = !1;
                        const f = t.background;
                        f
                            ? f.isColor &&
                              (h.color.copy(f), (t.background = null), (p = !0))
                            : (h.color.copy(ci), (p = !0));
                        for (let e = 0; e < 6; e++) {
                            const n = e % 3;
                            0 === n
                                ? (r.up.set(0, a[e], 0), r.lookAt(s[e], 0, 0))
                                : 1 === n
                                  ? (r.up.set(0, 0, a[e]), r.lookAt(0, s[e], 0))
                                  : (r.up.set(0, a[e], 0),
                                    r.lookAt(0, 0, s[e]));
                            const o = this._cubeSize;
                            gi(i, n * o, e > 2 ? o : 0, o, o),
                                l.setRenderTarget(i),
                                p && l.render(d, r),
                                l.render(t, r);
                        }
                        d.geometry.dispose(),
                            d.material.dispose(),
                            (l.toneMapping = u),
                            (l.autoClear = c),
                            (t.background = f);
                    }
                    _textureToCubeUV(t, e) {
                        const n = this._renderer,
                            i = t.mapping === c || t.mapping === u;
                        i
                            ? (null === this._cubemapMaterial &&
                                  (this._cubemapMaterial = _i()),
                              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                                  !1 === t.isRenderTargetTexture ? -1 : 1))
                            : null === this._equirectMaterial &&
                              (this._equirectMaterial = vi());
                        const r = i
                                ? this._cubemapMaterial
                                : this._equirectMaterial,
                            a = new wn(this._lodPlanes[0], r);
                        r.uniforms.envMap.value = t;
                        const o = this._cubeSize;
                        gi(e, 0, 0, 3 * o, 2 * o),
                            n.setRenderTarget(e),
                            n.render(a, li);
                    }
                    _applyPMREM(t) {
                        const e = this._renderer,
                            n = e.autoClear;
                        e.autoClear = !1;
                        for (let e = 1; e < this._lodPlanes.length; e++) {
                            const n = Math.sqrt(
                                    this._sigmas[e] * this._sigmas[e] -
                                        this._sigmas[e - 1] *
                                            this._sigmas[e - 1]
                                ),
                                i = pi[(e - 1) % pi.length];
                            this._blur(t, e - 1, e, n, i);
                        }
                        e.autoClear = n;
                    }
                    _blur(t, e, n, i, r) {
                        const a = this._pingPongRenderTarget;
                        this._halfBlur(t, a, e, n, i, 'latitudinal', r),
                            this._halfBlur(a, t, n, n, i, 'longitudinal', r);
                    }
                    _halfBlur(t, e, n, i, r, a, o) {
                        const s = this._renderer,
                            l = this._blurMaterial;
                        'latitudinal' !== a &&
                            'longitudinal' !== a &&
                            console.error(
                                'blur direction must be either latitudinal or longitudinal!'
                            );
                        const c = new wn(this._lodPlanes[i], l),
                            u = l.uniforms,
                            h = this._sizeLods[n] - 1,
                            d = isFinite(r)
                                ? Math.PI / (2 * h)
                                : (2 * Math.PI) / 39,
                            p = r / d,
                            f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                        f > 20 &&
                            console.warn(
                                `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
                            );
                        const m = [];
                        let g = 0;
                        for (let t = 0; t < 20; ++t) {
                            const e = t / p,
                                n = Math.exp((-e * e) / 2);
                            m.push(n),
                                0 === t ? (g += n) : t < f && (g += 2 * n);
                        }
                        for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
                        (u.envMap.value = t.texture),
                            (u.samples.value = f),
                            (u.weights.value = m),
                            (u.latitudinal.value = 'latitudinal' === a),
                            o && (u.poleAxis.value = o);
                        const { _lodMax: v } = this;
                        (u.dTheta.value = d), (u.mipInt.value = v - n);
                        const _ = this._sizeLods[i];
                        gi(
                            e,
                            3 * _ * (i > v - 4 ? i - v + 4 : 0),
                            4 * (this._cubeSize - _),
                            3 * _,
                            2 * _
                        ),
                            s.setRenderTarget(e),
                            s.render(c, li);
                    }
                }
                function mi(t, e, n) {
                    const i = new Mt(t, e, n);
                    return (
                        (i.texture.mapping = h),
                        (i.texture.name = 'PMREM.cubeUv'),
                        (i.scissorTest = !0),
                        i
                    );
                }
                function gi(t, e, n, i, r) {
                    t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
                }
                function vi() {
                    return new In({
                        name: 'EquirectangularToCubeUV',
                        uniforms: { envMap: { value: null } },
                        vertexShader:
                            '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
                        fragmentShader:
                            '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t',
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1,
                    });
                }
                function _i() {
                    return new In({
                        name: 'CubemapToCubeUV',
                        uniforms: {
                            envMap: { value: null },
                            flipEnvMap: { value: -1 },
                        },
                        vertexShader:
                            '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
                        fragmentShader:
                            '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t',
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1,
                    });
                }
                function xi(t) {
                    let e = new WeakMap(),
                        n = null;
                    function i(t) {
                        const n = t.target;
                        n.removeEventListener('dispose', i);
                        const r = e.get(n);
                        void 0 !== r && (e.delete(n), r.dispose());
                    }
                    return {
                        get: function (r) {
                            if (r && r.isTexture) {
                                const a = r.mapping,
                                    o = 303 === a || 304 === a,
                                    s = a === c || a === u;
                                if (o || s) {
                                    if (
                                        r.isRenderTargetTexture &&
                                        !0 === r.needsPMREMUpdate
                                    ) {
                                        r.needsPMREMUpdate = !1;
                                        let i = e.get(r);
                                        return (
                                            null === n && (n = new fi(t)),
                                            (i = o
                                                ? n.fromEquirectangular(r, i)
                                                : n.fromCubemap(r, i)),
                                            e.set(r, i),
                                            i.texture
                                        );
                                    }
                                    if (e.has(r)) return e.get(r).texture;
                                    {
                                        const a = r.image;
                                        if (
                                            (o && a && a.height > 0) ||
                                            (s &&
                                                a &&
                                                (function (t) {
                                                    let e = 0;
                                                    for (let n = 0; n < 6; n++)
                                                        void 0 !== t[n] && e++;
                                                    return 6 === e;
                                                })(a))
                                        ) {
                                            null === n && (n = new fi(t));
                                            const a = o
                                                ? n.fromEquirectangular(r)
                                                : n.fromCubemap(r);
                                            return (
                                                e.set(r, a),
                                                r.addEventListener(
                                                    'dispose',
                                                    i
                                                ),
                                                a.texture
                                            );
                                        }
                                        return null;
                                    }
                                }
                            }
                            return r;
                        },
                        dispose: function () {
                            (e = new WeakMap()),
                                null !== n && (n.dispose(), (n = null));
                        },
                    };
                }
                function yi(t) {
                    const e = {};
                    function n(n) {
                        if (void 0 !== e[n]) return e[n];
                        let i;
                        switch (n) {
                            case 'WEBGL_depth_texture':
                                i =
                                    t.getExtension('WEBGL_depth_texture') ||
                                    t.getExtension('MOZ_WEBGL_depth_texture') ||
                                    t.getExtension(
                                        'WEBKIT_WEBGL_depth_texture'
                                    );
                                break;
                            case 'EXT_texture_filter_anisotropic':
                                i =
                                    t.getExtension(
                                        'EXT_texture_filter_anisotropic'
                                    ) ||
                                    t.getExtension(
                                        'MOZ_EXT_texture_filter_anisotropic'
                                    ) ||
                                    t.getExtension(
                                        'WEBKIT_EXT_texture_filter_anisotropic'
                                    );
                                break;
                            case 'WEBGL_compressed_texture_s3tc':
                                i =
                                    t.getExtension(
                                        'WEBGL_compressed_texture_s3tc'
                                    ) ||
                                    t.getExtension(
                                        'MOZ_WEBGL_compressed_texture_s3tc'
                                    ) ||
                                    t.getExtension(
                                        'WEBKIT_WEBGL_compressed_texture_s3tc'
                                    );
                                break;
                            case 'WEBGL_compressed_texture_pvrtc':
                                i =
                                    t.getExtension(
                                        'WEBGL_compressed_texture_pvrtc'
                                    ) ||
                                    t.getExtension(
                                        'WEBKIT_WEBGL_compressed_texture_pvrtc'
                                    );
                                break;
                            default:
                                i = t.getExtension(n);
                        }
                        return (e[n] = i), i;
                    }
                    return {
                        has: function (t) {
                            return null !== n(t);
                        },
                        init: function (t) {
                            t.isWebGL2
                                ? n('EXT_color_buffer_float')
                                : (n('WEBGL_depth_texture'),
                                  n('OES_texture_float'),
                                  n('OES_texture_half_float'),
                                  n('OES_texture_half_float_linear'),
                                  n('OES_standard_derivatives'),
                                  n('OES_element_index_uint'),
                                  n('OES_vertex_array_object'),
                                  n('ANGLE_instanced_arrays')),
                                n('OES_texture_float_linear'),
                                n('EXT_color_buffer_half_float'),
                                n('WEBGL_multisampled_render_to_texture');
                        },
                        get: function (t) {
                            const e = n(t);
                            return (
                                null === e &&
                                    console.warn(
                                        'THREE.WebGLRenderer: ' +
                                            t +
                                            ' extension not supported.'
                                    ),
                                e
                            );
                        },
                    };
                }
                function Mi(t, e, n, i) {
                    const r = {},
                        a = new WeakMap();
                    function o(t) {
                        const s = t.target;
                        null !== s.index && e.remove(s.index);
                        for (const t in s.attributes) e.remove(s.attributes[t]);
                        s.removeEventListener('dispose', o), delete r[s.id];
                        const l = a.get(s);
                        l && (e.remove(l), a.delete(s)),
                            i.releaseStatesOfGeometry(s),
                            !0 === s.isInstancedBufferGeometry &&
                                delete s._maxInstanceCount,
                            n.memory.geometries--;
                    }
                    function s(t) {
                        const n = [],
                            i = t.index,
                            r = t.attributes.position;
                        let o = 0;
                        if (null !== i) {
                            const t = i.array;
                            o = i.version;
                            for (let e = 0, i = t.length; e < i; e += 3) {
                                const i = t[e + 0],
                                    r = t[e + 1],
                                    a = t[e + 2];
                                n.push(i, r, r, a, a, i);
                            }
                        } else {
                            const t = r.array;
                            o = r.version;
                            for (
                                let e = 0, i = t.length / 3 - 1;
                                e < i;
                                e += 3
                            ) {
                                const t = e + 0,
                                    i = e + 1,
                                    r = e + 2;
                                n.push(t, i, i, r, r, t);
                            }
                        }
                        const s = new (it(n) ? Qe : Je)(n, 1);
                        s.version = o;
                        const l = a.get(t);
                        l && e.remove(l), a.set(t, s);
                    }
                    return {
                        get: function (t, e) {
                            return (
                                !0 === r[e.id] ||
                                    (e.addEventListener('dispose', o),
                                    (r[e.id] = !0),
                                    n.memory.geometries++),
                                e
                            );
                        },
                        update: function (n) {
                            const i = n.attributes;
                            for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
                            const r = n.morphAttributes;
                            for (const n in r) {
                                const i = r[n];
                                for (let n = 0, r = i.length; n < r; n++)
                                    e.update(i[n], t.ARRAY_BUFFER);
                            }
                        },
                        getWireframeAttribute: function (t) {
                            const e = a.get(t);
                            if (e) {
                                const n = t.index;
                                null !== n && e.version < n.version && s(t);
                            } else s(t);
                            return a.get(t);
                        },
                    };
                }
                function bi(t, e, n, i) {
                    const r = i.isWebGL2;
                    let a, o, s;
                    (this.setMode = function (t) {
                        a = t;
                    }),
                        (this.setIndex = function (t) {
                            (o = t.type), (s = t.bytesPerElement);
                        }),
                        (this.render = function (e, i) {
                            t.drawElements(a, i, o, e * s), n.update(i, a, 1);
                        }),
                        (this.renderInstances = function (i, l, c) {
                            if (0 === c) return;
                            let u, h;
                            if (r) (u = t), (h = 'drawElementsInstanced');
                            else if (
                                ((u = e.get('ANGLE_instanced_arrays')),
                                (h = 'drawElementsInstancedANGLE'),
                                null === u)
                            )
                                return void console.error(
                                    'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
                                );
                            u[h](a, l, o, i * s, c), n.update(l, a, c);
                        });
                }
                function Ei(t) {
                    const e = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0,
                    };
                    return {
                        memory: { geometries: 0, textures: 0 },
                        render: e,
                        programs: null,
                        autoReset: !0,
                        reset: function () {
                            e.frame++,
                                (e.calls = 0),
                                (e.triangles = 0),
                                (e.points = 0),
                                (e.lines = 0);
                        },
                        update: function (n, i, r) {
                            switch ((e.calls++, i)) {
                                case t.TRIANGLES:
                                    e.triangles += r * (n / 3);
                                    break;
                                case t.LINES:
                                    e.lines += r * (n / 2);
                                    break;
                                case t.LINE_STRIP:
                                    e.lines += r * (n - 1);
                                    break;
                                case t.LINE_LOOP:
                                    e.lines += r * n;
                                    break;
                                case t.POINTS:
                                    e.points += r * n;
                                    break;
                                default:
                                    console.error(
                                        'THREE.WebGLInfo: Unknown draw mode:',
                                        i
                                    );
                            }
                        },
                    };
                }
                function Si(t, e) {
                    return t[0] - e[0];
                }
                function Ti(t, e) {
                    return Math.abs(e[1]) - Math.abs(t[1]);
                }
                function wi(t, e, n) {
                    const i = {},
                        r = new Float32Array(8),
                        a = new WeakMap(),
                        o = new yt(),
                        s = [];
                    for (let t = 0; t < 8; t++) s[t] = [t, 0];
                    return {
                        update: function (l, c, u) {
                            const h = l.morphTargetInfluences;
                            if (!0 === e.isWebGL2) {
                                const d =
                                        c.morphAttributes.position ||
                                        c.morphAttributes.normal ||
                                        c.morphAttributes.color,
                                    p = void 0 !== d ? d.length : 0;
                                let f = a.get(c);
                                if (void 0 === f || f.count !== p) {
                                    void 0 !== f && f.texture.dispose();
                                    const v =
                                            void 0 !==
                                            c.morphAttributes.position,
                                        _ = void 0 !== c.morphAttributes.normal,
                                        x = void 0 !== c.morphAttributes.color,
                                        y = c.morphAttributes.position || [],
                                        b = c.morphAttributes.normal || [],
                                        E = c.morphAttributes.color || [];
                                    let S = 0;
                                    !0 === v && (S = 1),
                                        !0 === _ && (S = 2),
                                        !0 === x && (S = 3);
                                    let T = c.attributes.position.count * S,
                                        w = 1;
                                    T > e.maxTextureSize &&
                                        ((w = Math.ceil(T / e.maxTextureSize)),
                                        (T = e.maxTextureSize));
                                    const A = new Float32Array(T * w * 4 * p),
                                        C = new bt(A, T, w, p);
                                    (C.type = M), (C.needsUpdate = !0);
                                    const R = 4 * S;
                                    for (let P = 0; P < p; P++) {
                                        const D = y[P],
                                            I = b[P],
                                            U = E[P],
                                            O = T * w * 4 * P;
                                        for (let N = 0; N < D.count; N++) {
                                            const F = N * R;
                                            !0 === v &&
                                                (o.fromBufferAttribute(D, N),
                                                (A[O + F + 0] = o.x),
                                                (A[O + F + 1] = o.y),
                                                (A[O + F + 2] = o.z),
                                                (A[O + F + 3] = 0)),
                                                !0 === _ &&
                                                    (o.fromBufferAttribute(
                                                        I,
                                                        N
                                                    ),
                                                    (A[O + F + 4] = o.x),
                                                    (A[O + F + 5] = o.y),
                                                    (A[O + F + 6] = o.z),
                                                    (A[O + F + 7] = 0)),
                                                !0 === x &&
                                                    (o.fromBufferAttribute(
                                                        U,
                                                        N
                                                    ),
                                                    (A[O + F + 8] = o.x),
                                                    (A[O + F + 9] = o.y),
                                                    (A[O + F + 10] = o.z),
                                                    (A[O + F + 11] =
                                                        4 === U.itemSize
                                                            ? o.w
                                                            : 1));
                                        }
                                    }
                                    function L() {
                                        C.dispose(),
                                            a.delete(c),
                                            c.removeEventListener('dispose', L);
                                    }
                                    (f = {
                                        count: p,
                                        texture: C,
                                        size: new tt(T, w),
                                    }),
                                        a.set(c, f),
                                        c.addEventListener('dispose', L);
                                }
                                let m = 0;
                                for (let z = 0; z < h.length; z++) m += h[z];
                                const g = c.morphTargetsRelative ? 1 : 1 - m;
                                u
                                    .getUniforms()
                                    .setValue(t, 'morphTargetBaseInfluence', g),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            t,
                                            'morphTargetInfluences',
                                            h
                                        ),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            t,
                                            'morphTargetsTexture',
                                            f.texture,
                                            n
                                        ),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            t,
                                            'morphTargetsTextureSize',
                                            f.size
                                        );
                            } else {
                                const B = void 0 === h ? 0 : h.length;
                                let k = i[c.id];
                                if (void 0 === k || k.length !== B) {
                                    k = [];
                                    for (let j = 0; j < B; j++) k[j] = [j, 0];
                                    i[c.id] = k;
                                }
                                for (let X = 0; X < B; X++) {
                                    const Y = k[X];
                                    (Y[0] = X), (Y[1] = h[X]);
                                }
                                k.sort(Ti);
                                for (let q = 0; q < 8; q++)
                                    q < B && k[q][1]
                                        ? ((s[q][0] = k[q][0]),
                                          (s[q][1] = k[q][1]))
                                        : ((s[q][0] = Number.MAX_SAFE_INTEGER),
                                          (s[q][1] = 0));
                                s.sort(Si);
                                const H = c.morphAttributes.position,
                                    G = c.morphAttributes.normal;
                                let V = 0;
                                for (let K = 0; K < 8; K++) {
                                    const Z = s[K],
                                        J = Z[0],
                                        Q = Z[1];
                                    J !== Number.MAX_SAFE_INTEGER && Q
                                        ? (H &&
                                              c.getAttribute(
                                                  'morphTarget' + K
                                              ) !== H[J] &&
                                              c.setAttribute(
                                                  'morphTarget' + K,
                                                  H[J]
                                              ),
                                          G &&
                                              c.getAttribute(
                                                  'morphNormal' + K
                                              ) !== G[J] &&
                                              c.setAttribute(
                                                  'morphNormal' + K,
                                                  G[J]
                                              ),
                                          (r[K] = Q),
                                          (V += Q))
                                        : (H &&
                                              !0 ===
                                                  c.hasAttribute(
                                                      'morphTarget' + K
                                                  ) &&
                                              c.deleteAttribute(
                                                  'morphTarget' + K
                                              ),
                                          G &&
                                              !0 ===
                                                  c.hasAttribute(
                                                      'morphNormal' + K
                                                  ) &&
                                              c.deleteAttribute(
                                                  'morphNormal' + K
                                              ),
                                          (r[K] = 0));
                                }
                                const W = c.morphTargetsRelative ? 1 : 1 - V;
                                u
                                    .getUniforms()
                                    .setValue(t, 'morphTargetBaseInfluence', W),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            t,
                                            'morphTargetInfluences',
                                            r
                                        );
                            }
                        },
                    };
                }
                function Ai(t, e, n, i) {
                    let r = new WeakMap();
                    function a(t) {
                        const e = t.target;
                        e.removeEventListener('dispose', a),
                            n.remove(e.instanceMatrix),
                            null !== e.instanceColor &&
                                n.remove(e.instanceColor);
                    }
                    return {
                        update: function (o) {
                            const s = i.render.frame,
                                l = o.geometry,
                                c = e.get(o, l);
                            return (
                                r.get(c) !== s && (e.update(c), r.set(c, s)),
                                o.isInstancedMesh &&
                                    (!1 === o.hasEventListener('dispose', a) &&
                                        o.addEventListener('dispose', a),
                                    n.update(o.instanceMatrix, t.ARRAY_BUFFER),
                                    null !== o.instanceColor &&
                                        n.update(
                                            o.instanceColor,
                                            t.ARRAY_BUFFER
                                        )),
                                c
                            );
                        },
                        dispose: function () {
                            r = new WeakMap();
                        },
                    };
                }
                const Ci = new xt(),
                    Ri = new bt(),
                    Li = new Et(),
                    Pi = new zn(),
                    Di = [],
                    Ii = [],
                    Ui = new Float32Array(16),
                    Oi = new Float32Array(9),
                    Ni = new Float32Array(4);
                function Fi(t, e, n) {
                    const i = t[0];
                    if (i <= 0 || i > 0) return t;
                    const r = e * n;
                    let a = Di[r];
                    if (
                        (void 0 === a &&
                            ((a = new Float32Array(r)), (Di[r] = a)),
                        0 !== e)
                    ) {
                        i.toArray(a, 0);
                        for (let i = 1, r = 0; i !== e; ++i)
                            (r += n), t[i].toArray(a, r);
                    }
                    return a;
                }
                function zi(t, e) {
                    if (t.length !== e.length) return !1;
                    for (let n = 0, i = t.length; n < i; n++)
                        if (t[n] !== e[n]) return !1;
                    return !0;
                }
                function Bi(t, e) {
                    for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
                }
                function ki(t, e) {
                    let n = Ii[e];
                    void 0 === n && ((n = new Int32Array(e)), (Ii[e] = n));
                    for (let i = 0; i !== e; ++i)
                        n[i] = t.allocateTextureUnit();
                    return n;
                }
                function Hi(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
                }
                function Gi(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y) ||
                            (t.uniform2f(this.addr, e.x, e.y),
                            (n[0] = e.x),
                            (n[1] = e.y));
                    else {
                        if (zi(n, e)) return;
                        t.uniform2fv(this.addr, e), Bi(n, e);
                    }
                }
                function Vi(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                            (t.uniform3f(this.addr, e.x, e.y, e.z),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z));
                    else if (void 0 !== e.r)
                        (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
                            (t.uniform3f(this.addr, e.r, e.g, e.b),
                            (n[0] = e.r),
                            (n[1] = e.g),
                            (n[2] = e.b));
                    else {
                        if (zi(n, e)) return;
                        t.uniform3fv(this.addr, e), Bi(n, e);
                    }
                }
                function Wi(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x &&
                            n[1] === e.y &&
                            n[2] === e.z &&
                            n[3] === e.w) ||
                            (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z),
                            (n[3] = e.w));
                    else {
                        if (zi(n, e)) return;
                        t.uniform4fv(this.addr, e), Bi(n, e);
                    }
                }
                function ji(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (zi(n, e)) return;
                        t.uniformMatrix2fv(this.addr, !1, e), Bi(n, e);
                    } else {
                        if (zi(n, i)) return;
                        Ni.set(i),
                            t.uniformMatrix2fv(this.addr, !1, Ni),
                            Bi(n, i);
                    }
                }
                function Xi(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (zi(n, e)) return;
                        t.uniformMatrix3fv(this.addr, !1, e), Bi(n, e);
                    } else {
                        if (zi(n, i)) return;
                        Oi.set(i),
                            t.uniformMatrix3fv(this.addr, !1, Oi),
                            Bi(n, i);
                    }
                }
                function Yi(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (zi(n, e)) return;
                        t.uniformMatrix4fv(this.addr, !1, e), Bi(n, e);
                    } else {
                        if (zi(n, i)) return;
                        Ui.set(i),
                            t.uniformMatrix4fv(this.addr, !1, Ui),
                            Bi(n, i);
                    }
                }
                function qi(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
                }
                function Ki(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y) ||
                            (t.uniform2i(this.addr, e.x, e.y),
                            (n[0] = e.x),
                            (n[1] = e.y));
                    else {
                        if (zi(n, e)) return;
                        t.uniform2iv(this.addr, e), Bi(n, e);
                    }
                }
                function Zi(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                            (t.uniform3i(this.addr, e.x, e.y, e.z),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z));
                    else {
                        if (zi(n, e)) return;
                        t.uniform3iv(this.addr, e), Bi(n, e);
                    }
                }
                function Ji(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x &&
                            n[1] === e.y &&
                            n[2] === e.z &&
                            n[3] === e.w) ||
                            (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z),
                            (n[3] = e.w));
                    else {
                        if (zi(n, e)) return;
                        t.uniform4iv(this.addr, e), Bi(n, e);
                    }
                }
                function Qi(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
                }
                function $i(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y) ||
                            (t.uniform2ui(this.addr, e.x, e.y),
                            (n[0] = e.x),
                            (n[1] = e.y));
                    else {
                        if (zi(n, e)) return;
                        t.uniform2uiv(this.addr, e), Bi(n, e);
                    }
                }
                function tr(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                            (t.uniform3ui(this.addr, e.x, e.y, e.z),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z));
                    else {
                        if (zi(n, e)) return;
                        t.uniform3uiv(this.addr, e), Bi(n, e);
                    }
                }
                function er(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x)
                        (n[0] === e.x &&
                            n[1] === e.y &&
                            n[2] === e.z &&
                            n[3] === e.w) ||
                            (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
                            (n[0] = e.x),
                            (n[1] = e.y),
                            (n[2] = e.z),
                            (n[3] = e.w));
                    else {
                        if (zi(n, e)) return;
                        t.uniform4uiv(this.addr, e), Bi(n, e);
                    }
                }
                function nr(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
                        n.setTexture2D(e || Ci, r);
                }
                function ir(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
                        n.setTexture3D(e || Li, r);
                }
                function rr(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
                        n.setTextureCube(e || Pi, r);
                }
                function ar(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
                        n.setTexture2DArray(e || Ri, r);
                }
                function or(t, e) {
                    t.uniform1fv(this.addr, e);
                }
                function sr(t, e) {
                    const n = Fi(e, this.size, 2);
                    t.uniform2fv(this.addr, n);
                }
                function lr(t, e) {
                    const n = Fi(e, this.size, 3);
                    t.uniform3fv(this.addr, n);
                }
                function cr(t, e) {
                    const n = Fi(e, this.size, 4);
                    t.uniform4fv(this.addr, n);
                }
                function ur(t, e) {
                    const n = Fi(e, this.size, 4);
                    t.uniformMatrix2fv(this.addr, !1, n);
                }
                function hr(t, e) {
                    const n = Fi(e, this.size, 9);
                    t.uniformMatrix3fv(this.addr, !1, n);
                }
                function dr(t, e) {
                    const n = Fi(e, this.size, 16);
                    t.uniformMatrix4fv(this.addr, !1, n);
                }
                function pr(t, e) {
                    t.uniform1iv(this.addr, e);
                }
                function fr(t, e) {
                    t.uniform2iv(this.addr, e);
                }
                function mr(t, e) {
                    t.uniform3iv(this.addr, e);
                }
                function gr(t, e) {
                    t.uniform4iv(this.addr, e);
                }
                function vr(t, e) {
                    t.uniform1uiv(this.addr, e);
                }
                function _r(t, e) {
                    t.uniform2uiv(this.addr, e);
                }
                function xr(t, e) {
                    t.uniform3uiv(this.addr, e);
                }
                function yr(t, e) {
                    t.uniform4uiv(this.addr, e);
                }
                function Mr(t, e, n) {
                    const i = this.cache,
                        r = e.length,
                        a = ki(n, r);
                    zi(i, a) || (t.uniform1iv(this.addr, a), Bi(i, a));
                    for (let t = 0; t !== r; ++t)
                        n.setTexture2D(e[t] || Ci, a[t]);
                }
                function br(t, e, n) {
                    const i = this.cache,
                        r = e.length,
                        a = ki(n, r);
                    zi(i, a) || (t.uniform1iv(this.addr, a), Bi(i, a));
                    for (let t = 0; t !== r; ++t)
                        n.setTexture3D(e[t] || Li, a[t]);
                }
                function Er(t, e, n) {
                    const i = this.cache,
                        r = e.length,
                        a = ki(n, r);
                    zi(i, a) || (t.uniform1iv(this.addr, a), Bi(i, a));
                    for (let t = 0; t !== r; ++t)
                        n.setTextureCube(e[t] || Pi, a[t]);
                }
                function Sr(t, e, n) {
                    const i = this.cache,
                        r = e.length,
                        a = ki(n, r);
                    zi(i, a) || (t.uniform1iv(this.addr, a), Bi(i, a));
                    for (let t = 0; t !== r; ++t)
                        n.setTexture2DArray(e[t] || Ri, a[t]);
                }
                class Tr {
                    constructor(t, e, n) {
                        (this.id = t),
                            (this.addr = n),
                            (this.cache = []),
                            (this.setValue = (function (t) {
                                switch (t) {
                                    case 5126:
                                        return Hi;
                                    case 35664:
                                        return Gi;
                                    case 35665:
                                        return Vi;
                                    case 35666:
                                        return Wi;
                                    case 35674:
                                        return ji;
                                    case 35675:
                                        return Xi;
                                    case 35676:
                                        return Yi;
                                    case 5124:
                                    case 35670:
                                        return qi;
                                    case 35667:
                                    case 35671:
                                        return Ki;
                                    case 35668:
                                    case 35672:
                                        return Zi;
                                    case 35669:
                                    case 35673:
                                        return Ji;
                                    case 5125:
                                        return Qi;
                                    case 36294:
                                        return $i;
                                    case 36295:
                                        return tr;
                                    case 36296:
                                        return er;
                                    case 35678:
                                    case 36198:
                                    case 36298:
                                    case 36306:
                                    case 35682:
                                        return nr;
                                    case 35679:
                                    case 36299:
                                    case 36307:
                                        return ir;
                                    case 35680:
                                    case 36300:
                                    case 36308:
                                    case 36293:
                                        return rr;
                                    case 36289:
                                    case 36303:
                                    case 36311:
                                    case 36292:
                                        return ar;
                                }
                            })(e.type));
                    }
                }
                class wr {
                    constructor(t, e, n) {
                        (this.id = t),
                            (this.addr = n),
                            (this.cache = []),
                            (this.size = e.size),
                            (this.setValue = (function (t) {
                                switch (t) {
                                    case 5126:
                                        return or;
                                    case 35664:
                                        return sr;
                                    case 35665:
                                        return lr;
                                    case 35666:
                                        return cr;
                                    case 35674:
                                        return ur;
                                    case 35675:
                                        return hr;
                                    case 35676:
                                        return dr;
                                    case 5124:
                                    case 35670:
                                        return pr;
                                    case 35667:
                                    case 35671:
                                        return fr;
                                    case 35668:
                                    case 35672:
                                        return mr;
                                    case 35669:
                                    case 35673:
                                        return gr;
                                    case 5125:
                                        return vr;
                                    case 36294:
                                        return _r;
                                    case 36295:
                                        return xr;
                                    case 36296:
                                        return yr;
                                    case 35678:
                                    case 36198:
                                    case 36298:
                                    case 36306:
                                    case 35682:
                                        return Mr;
                                    case 35679:
                                    case 36299:
                                    case 36307:
                                        return br;
                                    case 35680:
                                    case 36300:
                                    case 36308:
                                    case 36293:
                                        return Er;
                                    case 36289:
                                    case 36303:
                                    case 36311:
                                    case 36292:
                                        return Sr;
                                }
                            })(e.type));
                    }
                }
                class Ar {
                    constructor(t) {
                        (this.id = t), (this.seq = []), (this.map = {});
                    }
                    setValue(t, e, n) {
                        const i = this.seq;
                        for (let r = 0, a = i.length; r !== a; ++r) {
                            const a = i[r];
                            a.setValue(t, e[a.id], n);
                        }
                    }
                }
                const Cr = /(\w+)(\])?(\[|\.)?/g;
                function Rr(t, e) {
                    t.seq.push(e), (t.map[e.id] = e);
                }
                function Lr(t, e, n) {
                    const i = t.name,
                        r = i.length;
                    for (Cr.lastIndex = 0; ; ) {
                        const a = Cr.exec(i),
                            o = Cr.lastIndex;
                        let s = a[1];
                        const l = ']' === a[2],
                            c = a[3];
                        if (
                            (l && (s |= 0),
                            void 0 === c || ('[' === c && o + 2 === r))
                        ) {
                            Rr(
                                n,
                                void 0 === c ? new Tr(s, t, e) : new wr(s, t, e)
                            );
                            break;
                        }
                        {
                            let t = n.map[s];
                            void 0 === t && ((t = new Ar(s)), Rr(n, t)),
                                (n = t);
                        }
                    }
                }
                class Pr {
                    constructor(t, e) {
                        (this.seq = []), (this.map = {});
                        const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                        for (let i = 0; i < n; ++i) {
                            const n = t.getActiveUniform(e, i);
                            Lr(n, t.getUniformLocation(e, n.name), this);
                        }
                    }
                    setValue(t, e, n, i) {
                        const r = this.map[e];
                        void 0 !== r && r.setValue(t, n, i);
                    }
                    setOptional(t, e, n) {
                        const i = e[n];
                        void 0 !== i && this.setValue(t, n, i);
                    }
                    static upload(t, e, n, i) {
                        for (let r = 0, a = e.length; r !== a; ++r) {
                            const a = e[r],
                                o = n[a.id];
                            !1 !== o.needsUpdate && a.setValue(t, o.value, i);
                        }
                    }
                    static seqWithValue(t, e) {
                        const n = [];
                        for (let i = 0, r = t.length; i !== r; ++i) {
                            const r = t[i];
                            r.id in e && n.push(r);
                        }
                        return n;
                    }
                }
                function Dr(t, e, n) {
                    const i = t.createShader(e);
                    return t.shaderSource(i, n), t.compileShader(i), i;
                }
                let Ir = 0;
                function Ur(t, e, n) {
                    const i = t.getShaderParameter(e, t.COMPILE_STATUS),
                        r = t.getShaderInfoLog(e).trim();
                    if (i && '' === r) return '';
                    const a = /ERROR: 0:(\d+)/.exec(r);
                    if (a) {
                        const i = parseInt(a[1]);
                        return (
                            n.toUpperCase() +
                            '\n\n' +
                            r +
                            '\n\n' +
                            (function (t, e) {
                                const n = t.split('\n'),
                                    i = [],
                                    r = Math.max(e - 6, 0),
                                    a = Math.min(e + 6, n.length);
                                for (let t = r; t < a; t++) {
                                    const r = t + 1;
                                    i.push(
                                        `${r === e ? '>' : ' '} ${r}: ${n[t]}`
                                    );
                                }
                                return i.join('\n');
                            })(t.getShaderSource(e), i)
                        );
                    }
                    return r;
                }
                function Or(t, e) {
                    const n = (function (t) {
                        switch (t) {
                            case z:
                                return ['Linear', '( value )'];
                            case F:
                                return ['sRGB', '( value )'];
                            default:
                                return (
                                    console.warn(
                                        'THREE.WebGLProgram: Unsupported color space:',
                                        t
                                    ),
                                    ['Linear', '( value )']
                                );
                        }
                    })(e);
                    return (
                        'vec4 ' +
                        t +
                        '( vec4 value ) { return LinearTo' +
                        n[0] +
                        n[1] +
                        '; }'
                    );
                }
                function Nr(t, e) {
                    let n;
                    switch (e) {
                        case 1:
                            n = 'Linear';
                            break;
                        case 2:
                            n = 'Reinhard';
                            break;
                        case 3:
                            n = 'OptimizedCineon';
                            break;
                        case 4:
                            n = 'ACESFilmic';
                            break;
                        case 5:
                            n = 'Custom';
                            break;
                        default:
                            console.warn(
                                'THREE.WebGLProgram: Unsupported toneMapping:',
                                e
                            ),
                                (n = 'Linear');
                    }
                    return (
                        'vec3 ' +
                        t +
                        '( vec3 color ) { return ' +
                        n +
                        'ToneMapping( color ); }'
                    );
                }
                function Fr(t) {
                    return '' !== t;
                }
                function zr(t, e) {
                    const n =
                        e.numSpotLightShadows +
                        e.numSpotLightMaps -
                        e.numSpotLightShadowsWithMaps;
                    return t
                        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
                        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
                        .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
                        .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
                        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
                        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
                        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
                        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
                        .replace(
                            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
                            e.numSpotLightShadowsWithMaps
                        )
                        .replace(
                            /NUM_SPOT_LIGHT_SHADOWS/g,
                            e.numSpotLightShadows
                        )
                        .replace(
                            /NUM_POINT_LIGHT_SHADOWS/g,
                            e.numPointLightShadows
                        );
                }
                function Br(t, e) {
                    return t
                        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
                        .replace(
                            /UNION_CLIPPING_PLANES/g,
                            e.numClippingPlanes - e.numClipIntersection
                        );
                }
                const kr = /^[ \t]*#include +<([\w\d./]+)>/gm;
                function Hr(t) {
                    return t.replace(kr, Gr);
                }
                function Gr(t, e) {
                    const n = Zn[e];
                    if (void 0 === n)
                        throw new Error('Can not resolve #include <' + e + '>');
                    return Hr(n);
                }
                const Vr =
                    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                function Wr(t) {
                    return t.replace(Vr, jr);
                }
                function jr(t, e, n, i) {
                    let r = '';
                    for (let t = parseInt(e); t < parseInt(n); t++)
                        r += i
                            .replace(/\[\s*i\s*\]/g, '[ ' + t + ' ]')
                            .replace(/UNROLLED_LOOP_INDEX/g, t);
                    return r;
                }
                function Xr(t) {
                    let e =
                        'precision ' +
                        t.precision +
                        ' float;\nprecision ' +
                        t.precision +
                        ' int;';
                    return (
                        'highp' === t.precision
                            ? (e += '\n#define HIGH_PRECISION')
                            : 'mediump' === t.precision
                              ? (e += '\n#define MEDIUM_PRECISION')
                              : 'lowp' === t.precision &&
                                (e += '\n#define LOW_PRECISION'),
                        e
                    );
                }
                function Yr(t, e, n, i) {
                    const r = t.getContext(),
                        a = n.defines;
                    let o = n.vertexShader,
                        s = n.fragmentShader;
                    const l = (function (t) {
                            let e = 'SHADOWMAP_TYPE_BASIC';
                            return (
                                1 === t.shadowMapType
                                    ? (e = 'SHADOWMAP_TYPE_PCF')
                                    : 2 === t.shadowMapType
                                      ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
                                      : 3 === t.shadowMapType &&
                                        (e = 'SHADOWMAP_TYPE_VSM'),
                                e
                            );
                        })(n),
                        d = (function (t) {
                            let e = 'ENVMAP_TYPE_CUBE';
                            if (t.envMap)
                                switch (t.envMapMode) {
                                    case c:
                                    case u:
                                        e = 'ENVMAP_TYPE_CUBE';
                                        break;
                                    case h:
                                        e = 'ENVMAP_TYPE_CUBE_UV';
                                }
                            return e;
                        })(n),
                        p = (function (t) {
                            let e = 'ENVMAP_MODE_REFLECTION';
                            return (
                                t.envMap &&
                                    t.envMapMode === u &&
                                    (e = 'ENVMAP_MODE_REFRACTION'),
                                e
                            );
                        })(n),
                        f = (function (t) {
                            let e = 'ENVMAP_BLENDING_NONE';
                            if (t.envMap)
                                switch (t.combine) {
                                    case 0:
                                        e = 'ENVMAP_BLENDING_MULTIPLY';
                                        break;
                                    case 1:
                                        e = 'ENVMAP_BLENDING_MIX';
                                        break;
                                    case 2:
                                        e = 'ENVMAP_BLENDING_ADD';
                                }
                            return e;
                        })(n),
                        m = (function (t) {
                            const e = t.envMapCubeUVHeight;
                            if (null === e) return null;
                            const n = Math.log2(e) - 2,
                                i = 1 / e;
                            return {
                                texelWidth:
                                    1 / (3 * Math.max(Math.pow(2, n), 112)),
                                texelHeight: i,
                                maxMip: n,
                            };
                        })(n),
                        g = n.isWebGL2
                            ? ''
                            : (function (t) {
                                  return [
                                      t.extensionDerivatives ||
                                      t.envMapCubeUVHeight ||
                                      t.bumpMap ||
                                      t.normalMapTangentSpace ||
                                      t.clearcoatNormalMap ||
                                      t.flatShading ||
                                      'physical' === t.shaderID
                                          ? '#extension GL_OES_standard_derivatives : enable'
                                          : '',
                                      (t.extensionFragDepth ||
                                          t.logarithmicDepthBuffer) &&
                                      t.rendererExtensionFragDepth
                                          ? '#extension GL_EXT_frag_depth : enable'
                                          : '',
                                      t.extensionDrawBuffers &&
                                      t.rendererExtensionDrawBuffers
                                          ? '#extension GL_EXT_draw_buffers : require'
                                          : '',
                                      (t.extensionShaderTextureLOD ||
                                          t.envMap ||
                                          t.transmission) &&
                                      t.rendererExtensionShaderTextureLod
                                          ? '#extension GL_EXT_shader_texture_lod : enable'
                                          : '',
                                  ]
                                      .filter(Fr)
                                      .join('\n');
                              })(n),
                        v = (function (t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                !1 !== i && e.push('#define ' + n + ' ' + i);
                            }
                            return e.join('\n');
                        })(a),
                        _ = r.createProgram();
                    let x,
                        y,
                        M = n.glslVersion
                            ? '#version ' + n.glslVersion + '\n'
                            : '';
                    n.isRawShaderMaterial
                        ? ((x = [v].filter(Fr).join('\n')),
                          x.length > 0 && (x += '\n'),
                          (y = [g, v].filter(Fr).join('\n')),
                          y.length > 0 && (y += '\n'))
                        : ((x = [
                              Xr(n),
                              '#define SHADER_NAME ' + n.shaderName,
                              v,
                              n.instancing ? '#define USE_INSTANCING' : '',
                              n.instancingColor
                                  ? '#define USE_INSTANCING_COLOR'
                                  : '',
                              n.useFog && n.fog ? '#define USE_FOG' : '',
                              n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                              n.map ? '#define USE_MAP' : '',
                              n.envMap ? '#define USE_ENVMAP' : '',
                              n.envMap ? '#define ' + p : '',
                              n.lightMap ? '#define USE_LIGHTMAP' : '',
                              n.aoMap ? '#define USE_AOMAP' : '',
                              n.bumpMap ? '#define USE_BUMPMAP' : '',
                              n.normalMap ? '#define USE_NORMALMAP' : '',
                              n.normalMapObjectSpace
                                  ? '#define USE_NORMALMAP_OBJECTSPACE'
                                  : '',
                              n.normalMapTangentSpace
                                  ? '#define USE_NORMALMAP_TANGENTSPACE'
                                  : '',
                              n.displacementMap
                                  ? '#define USE_DISPLACEMENTMAP'
                                  : '',
                              n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                              n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                              n.clearcoatRoughnessMap
                                  ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                                  : '',
                              n.clearcoatNormalMap
                                  ? '#define USE_CLEARCOAT_NORMALMAP'
                                  : '',
                              n.iridescenceMap
                                  ? '#define USE_IRIDESCENCEMAP'
                                  : '',
                              n.iridescenceThicknessMap
                                  ? '#define USE_IRIDESCENCE_THICKNESSMAP'
                                  : '',
                              n.specularMap ? '#define USE_SPECULARMAP' : '',
                              n.specularColorMap
                                  ? '#define USE_SPECULAR_COLORMAP'
                                  : '',
                              n.specularIntensityMap
                                  ? '#define USE_SPECULAR_INTENSITYMAP'
                                  : '',
                              n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                              n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                              n.alphaMap ? '#define USE_ALPHAMAP' : '',
                              n.transmission ? '#define USE_TRANSMISSION' : '',
                              n.transmissionMap
                                  ? '#define USE_TRANSMISSIONMAP'
                                  : '',
                              n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
                              n.sheenColorMap
                                  ? '#define USE_SHEEN_COLORMAP'
                                  : '',
                              n.sheenRoughnessMap
                                  ? '#define USE_SHEEN_ROUGHNESSMAP'
                                  : '',
                              n.mapUv ? '#define MAP_UV ' + n.mapUv : '',
                              n.alphaMapUv
                                  ? '#define ALPHAMAP_UV ' + n.alphaMapUv
                                  : '',
                              n.lightMapUv
                                  ? '#define LIGHTMAP_UV ' + n.lightMapUv
                                  : '',
                              n.aoMapUv ? '#define AOMAP_UV ' + n.aoMapUv : '',
                              n.emissiveMapUv
                                  ? '#define EMISSIVEMAP_UV ' + n.emissiveMapUv
                                  : '',
                              n.bumpMapUv
                                  ? '#define BUMPMAP_UV ' + n.bumpMapUv
                                  : '',
                              n.normalMapUv
                                  ? '#define NORMALMAP_UV ' + n.normalMapUv
                                  : '',
                              n.displacementMapUv
                                  ? '#define DISPLACEMENTMAP_UV ' +
                                    n.displacementMapUv
                                  : '',
                              n.metalnessMapUv
                                  ? '#define METALNESSMAP_UV ' +
                                    n.metalnessMapUv
                                  : '',
                              n.roughnessMapUv
                                  ? '#define ROUGHNESSMAP_UV ' +
                                    n.roughnessMapUv
                                  : '',
                              n.clearcoatMapUv
                                  ? '#define CLEARCOATMAP_UV ' +
                                    n.clearcoatMapUv
                                  : '',
                              n.clearcoatNormalMapUv
                                  ? '#define CLEARCOAT_NORMALMAP_UV ' +
                                    n.clearcoatNormalMapUv
                                  : '',
                              n.clearcoatRoughnessMapUv
                                  ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' +
                                    n.clearcoatRoughnessMapUv
                                  : '',
                              n.iridescenceMapUv
                                  ? '#define IRIDESCENCEMAP_UV ' +
                                    n.iridescenceMapUv
                                  : '',
                              n.iridescenceThicknessMapUv
                                  ? '#define IRIDESCENCE_THICKNESSMAP_UV ' +
                                    n.iridescenceThicknessMapUv
                                  : '',
                              n.sheenColorMapUv
                                  ? '#define SHEEN_COLORMAP_UV ' +
                                    n.sheenColorMapUv
                                  : '',
                              n.sheenRoughnessMapUv
                                  ? '#define SHEEN_ROUGHNESSMAP_UV ' +
                                    n.sheenRoughnessMapUv
                                  : '',
                              n.specularMapUv
                                  ? '#define SPECULARMAP_UV ' + n.specularMapUv
                                  : '',
                              n.specularColorMapUv
                                  ? '#define SPECULAR_COLORMAP_UV ' +
                                    n.specularColorMapUv
                                  : '',
                              n.specularIntensityMapUv
                                  ? '#define SPECULAR_INTENSITYMAP_UV ' +
                                    n.specularIntensityMapUv
                                  : '',
                              n.transmissionMapUv
                                  ? '#define TRANSMISSIONMAP_UV ' +
                                    n.transmissionMapUv
                                  : '',
                              n.thicknessMapUv
                                  ? '#define THICKNESSMAP_UV ' +
                                    n.thicknessMapUv
                                  : '',
                              n.vertexTangents ? '#define USE_TANGENT' : '',
                              n.vertexColors ? '#define USE_COLOR' : '',
                              n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                              n.vertexUv1s ? '#define USE_UV1' : '',
                              n.vertexUv2s ? '#define USE_UV2' : '',
                              n.vertexUv3s ? '#define USE_UV3' : '',
                              n.pointsUvs ? '#define USE_POINTS_UV' : '',
                              n.flatShading ? '#define FLAT_SHADED' : '',
                              n.skinning ? '#define USE_SKINNING' : '',
                              n.morphTargets ? '#define USE_MORPHTARGETS' : '',
                              n.morphNormals && !1 === n.flatShading
                                  ? '#define USE_MORPHNORMALS'
                                  : '',
                              n.morphColors && n.isWebGL2
                                  ? '#define USE_MORPHCOLORS'
                                  : '',
                              n.morphTargetsCount > 0 && n.isWebGL2
                                  ? '#define MORPHTARGETS_TEXTURE'
                                  : '',
                              n.morphTargetsCount > 0 && n.isWebGL2
                                  ? '#define MORPHTARGETS_TEXTURE_STRIDE ' +
                                    n.morphTextureStride
                                  : '',
                              n.morphTargetsCount > 0 && n.isWebGL2
                                  ? '#define MORPHTARGETS_COUNT ' +
                                    n.morphTargetsCount
                                  : '',
                              n.doubleSided ? '#define DOUBLE_SIDED' : '',
                              n.flipSided ? '#define FLIP_SIDED' : '',
                              n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                              n.shadowMapEnabled ? '#define ' + l : '',
                              n.sizeAttenuation
                                  ? '#define USE_SIZEATTENUATION'
                                  : '',
                              n.logarithmicDepthBuffer
                                  ? '#define USE_LOGDEPTHBUF'
                                  : '',
                              n.logarithmicDepthBuffer &&
                              n.rendererExtensionFragDepth
                                  ? '#define USE_LOGDEPTHBUF_EXT'
                                  : '',
                              'uniform mat4 modelMatrix;',
                              'uniform mat4 modelViewMatrix;',
                              'uniform mat4 projectionMatrix;',
                              'uniform mat4 viewMatrix;',
                              'uniform mat3 normalMatrix;',
                              'uniform vec3 cameraPosition;',
                              'uniform bool isOrthographic;',
                              '#ifdef USE_INSTANCING',
                              '\tattribute mat4 instanceMatrix;',
                              '#endif',
                              '#ifdef USE_INSTANCING_COLOR',
                              '\tattribute vec3 instanceColor;',
                              '#endif',
                              'attribute vec3 position;',
                              'attribute vec3 normal;',
                              'attribute vec2 uv;',
                              '#ifdef USE_UV1',
                              '\tattribute vec2 uv1;',
                              '#endif',
                              '#ifdef USE_UV2',
                              '\tattribute vec2 uv2;',
                              '#endif',
                              '#ifdef USE_UV3',
                              '\tattribute vec2 uv3;',
                              '#endif',
                              '#ifdef USE_TANGENT',
                              '\tattribute vec4 tangent;',
                              '#endif',
                              '#if defined( USE_COLOR_ALPHA )',
                              '\tattribute vec4 color;',
                              '#elif defined( USE_COLOR )',
                              '\tattribute vec3 color;',
                              '#endif',
                              '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
                              '\tattribute vec3 morphTarget0;',
                              '\tattribute vec3 morphTarget1;',
                              '\tattribute vec3 morphTarget2;',
                              '\tattribute vec3 morphTarget3;',
                              '\t#ifdef USE_MORPHNORMALS',
                              '\t\tattribute vec3 morphNormal0;',
                              '\t\tattribute vec3 morphNormal1;',
                              '\t\tattribute vec3 morphNormal2;',
                              '\t\tattribute vec3 morphNormal3;',
                              '\t#else',
                              '\t\tattribute vec3 morphTarget4;',
                              '\t\tattribute vec3 morphTarget5;',
                              '\t\tattribute vec3 morphTarget6;',
                              '\t\tattribute vec3 morphTarget7;',
                              '\t#endif',
                              '#endif',
                              '#ifdef USE_SKINNING',
                              '\tattribute vec4 skinIndex;',
                              '\tattribute vec4 skinWeight;',
                              '#endif',
                              '\n',
                          ]
                              .filter(Fr)
                              .join('\n')),
                          (y = [
                              g,
                              Xr(n),
                              '#define SHADER_NAME ' + n.shaderName,
                              v,
                              n.useFog && n.fog ? '#define USE_FOG' : '',
                              n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                              n.map ? '#define USE_MAP' : '',
                              n.matcap ? '#define USE_MATCAP' : '',
                              n.envMap ? '#define USE_ENVMAP' : '',
                              n.envMap ? '#define ' + d : '',
                              n.envMap ? '#define ' + p : '',
                              n.envMap ? '#define ' + f : '',
                              m
                                  ? '#define CUBEUV_TEXEL_WIDTH ' + m.texelWidth
                                  : '',
                              m
                                  ? '#define CUBEUV_TEXEL_HEIGHT ' +
                                    m.texelHeight
                                  : '',
                              m
                                  ? '#define CUBEUV_MAX_MIP ' + m.maxMip + '.0'
                                  : '',
                              n.lightMap ? '#define USE_LIGHTMAP' : '',
                              n.aoMap ? '#define USE_AOMAP' : '',
                              n.bumpMap ? '#define USE_BUMPMAP' : '',
                              n.normalMap ? '#define USE_NORMALMAP' : '',
                              n.normalMapObjectSpace
                                  ? '#define USE_NORMALMAP_OBJECTSPACE'
                                  : '',
                              n.normalMapTangentSpace
                                  ? '#define USE_NORMALMAP_TANGENTSPACE'
                                  : '',
                              n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                              n.clearcoat ? '#define USE_CLEARCOAT' : '',
                              n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                              n.clearcoatRoughnessMap
                                  ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                                  : '',
                              n.clearcoatNormalMap
                                  ? '#define USE_CLEARCOAT_NORMALMAP'
                                  : '',
                              n.iridescence ? '#define USE_IRIDESCENCE' : '',
                              n.iridescenceMap
                                  ? '#define USE_IRIDESCENCEMAP'
                                  : '',
                              n.iridescenceThicknessMap
                                  ? '#define USE_IRIDESCENCE_THICKNESSMAP'
                                  : '',
                              n.specularMap ? '#define USE_SPECULARMAP' : '',
                              n.specularColorMap
                                  ? '#define USE_SPECULAR_COLORMAP'
                                  : '',
                              n.specularIntensityMap
                                  ? '#define USE_SPECULAR_INTENSITYMAP'
                                  : '',
                              n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                              n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                              n.alphaMap ? '#define USE_ALPHAMAP' : '',
                              n.alphaTest ? '#define USE_ALPHATEST' : '',
                              n.sheen ? '#define USE_SHEEN' : '',
                              n.sheenColorMap
                                  ? '#define USE_SHEEN_COLORMAP'
                                  : '',
                              n.sheenRoughnessMap
                                  ? '#define USE_SHEEN_ROUGHNESSMAP'
                                  : '',
                              n.transmission ? '#define USE_TRANSMISSION' : '',
                              n.transmissionMap
                                  ? '#define USE_TRANSMISSIONMAP'
                                  : '',
                              n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
                              n.vertexTangents ? '#define USE_TANGENT' : '',
                              n.vertexColors || n.instancingColor
                                  ? '#define USE_COLOR'
                                  : '',
                              n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                              n.vertexUv1s ? '#define USE_UV1' : '',
                              n.vertexUv2s ? '#define USE_UV2' : '',
                              n.vertexUv3s ? '#define USE_UV3' : '',
                              n.pointsUvs ? '#define USE_POINTS_UV' : '',
                              n.gradientMap ? '#define USE_GRADIENTMAP' : '',
                              n.flatShading ? '#define FLAT_SHADED' : '',
                              n.doubleSided ? '#define DOUBLE_SIDED' : '',
                              n.flipSided ? '#define FLIP_SIDED' : '',
                              n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                              n.shadowMapEnabled ? '#define ' + l : '',
                              n.premultipliedAlpha
                                  ? '#define PREMULTIPLIED_ALPHA'
                                  : '',
                              n.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
                              n.logarithmicDepthBuffer
                                  ? '#define USE_LOGDEPTHBUF'
                                  : '',
                              n.logarithmicDepthBuffer &&
                              n.rendererExtensionFragDepth
                                  ? '#define USE_LOGDEPTHBUF_EXT'
                                  : '',
                              'uniform mat4 viewMatrix;',
                              'uniform vec3 cameraPosition;',
                              'uniform bool isOrthographic;',
                              0 !== n.toneMapping ? '#define TONE_MAPPING' : '',
                              0 !== n.toneMapping
                                  ? Zn.tonemapping_pars_fragment
                                  : '',
                              0 !== n.toneMapping
                                  ? Nr('toneMapping', n.toneMapping)
                                  : '',
                              n.dithering ? '#define DITHERING' : '',
                              n.opaque ? '#define OPAQUE' : '',
                              Zn.encodings_pars_fragment,
                              Or('linearToOutputTexel', n.outputColorSpace),
                              n.useDepthPacking
                                  ? '#define DEPTH_PACKING ' + n.depthPacking
                                  : '',
                              '\n',
                          ]
                              .filter(Fr)
                              .join('\n'))),
                        (o = Hr(o)),
                        (o = zr(o, n)),
                        (o = Br(o, n)),
                        (s = Hr(s)),
                        (s = zr(s, n)),
                        (s = Br(s, n)),
                        (o = Wr(o)),
                        (s = Wr(s)),
                        n.isWebGL2 &&
                            !0 !== n.isRawShaderMaterial &&
                            ((M = '#version 300 es\n'),
                            (x =
                                [
                                    'precision mediump sampler2DArray;',
                                    '#define attribute in',
                                    '#define varying out',
                                    '#define texture2D texture',
                                ].join('\n') +
                                '\n' +
                                x),
                            (y =
                                [
                                    '#define varying in',
                                    n.glslVersion === H
                                        ? ''
                                        : 'layout(location = 0) out highp vec4 pc_fragColor;',
                                    n.glslVersion === H
                                        ? ''
                                        : '#define gl_FragColor pc_fragColor',
                                    '#define gl_FragDepthEXT gl_FragDepth',
                                    '#define texture2D texture',
                                    '#define textureCube texture',
                                    '#define texture2DProj textureProj',
                                    '#define texture2DLodEXT textureLod',
                                    '#define texture2DProjLodEXT textureProjLod',
                                    '#define textureCubeLodEXT textureLod',
                                    '#define texture2DGradEXT textureGrad',
                                    '#define texture2DProjGradEXT textureProjGrad',
                                    '#define textureCubeGradEXT textureGrad',
                                ].join('\n') +
                                '\n' +
                                y));
                    const b = M + x + o,
                        E = M + y + s,
                        S = Dr(r, r.VERTEX_SHADER, b),
                        T = Dr(r, r.FRAGMENT_SHADER, E);
                    if (
                        (r.attachShader(_, S),
                        r.attachShader(_, T),
                        void 0 !== n.index0AttributeName
                            ? r.bindAttribLocation(_, 0, n.index0AttributeName)
                            : !0 === n.morphTargets &&
                              r.bindAttribLocation(_, 0, 'position'),
                        r.linkProgram(_),
                        t.debug.checkShaderErrors)
                    ) {
                        const e = r.getProgramInfoLog(_).trim(),
                            n = r.getShaderInfoLog(S).trim(),
                            i = r.getShaderInfoLog(T).trim();
                        let a = !0,
                            o = !0;
                        if (!1 === r.getProgramParameter(_, r.LINK_STATUS))
                            if (
                                ((a = !1),
                                'function' == typeof t.debug.onShaderError)
                            )
                                t.debug.onShaderError(r, _, S, T);
                            else {
                                const t = Ur(r, S, 'vertex'),
                                    n = Ur(r, T, 'fragment');
                                console.error(
                                    'THREE.WebGLProgram: Shader Error ' +
                                        r.getError() +
                                        ' - VALIDATE_STATUS ' +
                                        r.getProgramParameter(
                                            _,
                                            r.VALIDATE_STATUS
                                        ) +
                                        '\n\nProgram Info Log: ' +
                                        e +
                                        '\n' +
                                        t +
                                        '\n' +
                                        n
                                );
                            }
                        else
                            '' !== e
                                ? console.warn(
                                      'THREE.WebGLProgram: Program Info Log:',
                                      e
                                  )
                                : ('' !== n && '' !== i) || (o = !1);
                        o &&
                            (this.diagnostics = {
                                runnable: a,
                                programLog: e,
                                vertexShader: { log: n, prefix: x },
                                fragmentShader: { log: i, prefix: y },
                            });
                    }
                    let w, A;
                    return (
                        r.deleteShader(S),
                        r.deleteShader(T),
                        (this.getUniforms = function () {
                            return void 0 === w && (w = new Pr(r, _)), w;
                        }),
                        (this.getAttributes = function () {
                            return (
                                void 0 === A &&
                                    (A = (function (t, e) {
                                        const n = {},
                                            i = t.getProgramParameter(
                                                e,
                                                t.ACTIVE_ATTRIBUTES
                                            );
                                        for (let r = 0; r < i; r++) {
                                            const i = t.getActiveAttrib(e, r),
                                                a = i.name;
                                            let o = 1;
                                            i.type === t.FLOAT_MAT2 && (o = 2),
                                                i.type === t.FLOAT_MAT3 &&
                                                    (o = 3),
                                                i.type === t.FLOAT_MAT4 &&
                                                    (o = 4),
                                                (n[a] = {
                                                    type: i.type,
                                                    location:
                                                        t.getAttribLocation(
                                                            e,
                                                            a
                                                        ),
                                                    locationSize: o,
                                                });
                                        }
                                        return n;
                                    })(r, _)),
                                A
                            );
                        }),
                        (this.destroy = function () {
                            i.releaseStatesOfProgram(this),
                                r.deleteProgram(_),
                                (this.program = void 0);
                        }),
                        (this.name = n.shaderName),
                        (this.id = Ir++),
                        (this.cacheKey = e),
                        (this.usedTimes = 1),
                        (this.program = _),
                        (this.vertexShader = S),
                        (this.fragmentShader = T),
                        this
                    );
                }
                let qr = 0;
                class Kr {
                    constructor() {
                        (this.shaderCache = new Map()),
                            (this.materialCache = new Map());
                    }
                    update(t) {
                        const e = t.vertexShader,
                            n = t.fragmentShader,
                            i = this._getShaderStage(e),
                            r = this._getShaderStage(n),
                            a = this._getShaderCacheForMaterial(t);
                        return (
                            !1 === a.has(i) && (a.add(i), i.usedTimes++),
                            !1 === a.has(r) && (a.add(r), r.usedTimes++),
                            this
                        );
                    }
                    remove(t) {
                        const e = this.materialCache.get(t);
                        for (const t of e)
                            t.usedTimes--,
                                0 === t.usedTimes &&
                                    this.shaderCache.delete(t.code);
                        return this.materialCache.delete(t), this;
                    }
                    getVertexShaderID(t) {
                        return this._getShaderStage(t.vertexShader).id;
                    }
                    getFragmentShaderID(t) {
                        return this._getShaderStage(t.fragmentShader).id;
                    }
                    dispose() {
                        this.shaderCache.clear(), this.materialCache.clear();
                    }
                    _getShaderCacheForMaterial(t) {
                        const e = this.materialCache;
                        let n = e.get(t);
                        return (
                            void 0 === n && ((n = new Set()), e.set(t, n)), n
                        );
                    }
                    _getShaderStage(t) {
                        const e = this.shaderCache;
                        let n = e.get(t);
                        return (
                            void 0 === n && ((n = new Zr(t)), e.set(t, n)), n
                        );
                    }
                }
                class Zr {
                    constructor(t) {
                        (this.id = qr++), (this.code = t), (this.usedTimes = 0);
                    }
                }
                function Jr(t, e, n, i, r, a, l) {
                    const c = new de(),
                        u = new Kr(),
                        d = [],
                        p = r.isWebGL2,
                        f = r.logarithmicDepthBuffer,
                        m = r.vertexTextures;
                    let g = r.precision;
                    const v = {
                        MeshDepthMaterial: 'depth',
                        MeshDistanceMaterial: 'distanceRGBA',
                        MeshNormalMaterial: 'normal',
                        MeshBasicMaterial: 'basic',
                        MeshLambertMaterial: 'lambert',
                        MeshPhongMaterial: 'phong',
                        MeshToonMaterial: 'toon',
                        MeshStandardMaterial: 'physical',
                        MeshPhysicalMaterial: 'physical',
                        MeshMatcapMaterial: 'matcap',
                        LineBasicMaterial: 'basic',
                        LineDashedMaterial: 'dashed',
                        PointsMaterial: 'points',
                        ShadowMaterial: 'shadow',
                        SpriteMaterial: 'sprite',
                    };
                    function _(t) {
                        return 1 === t
                            ? 'uv1'
                            : 2 === t
                              ? 'uv2'
                              : 3 === t
                                ? 'uv3'
                                : 'uv';
                    }
                    return {
                        getParameters: function (a, c, d, x, y) {
                            const M = x.fog,
                                b = y.geometry,
                                E = a.isMeshStandardMaterial
                                    ? x.environment
                                    : null,
                                S = (a.isMeshStandardMaterial ? n : e).get(
                                    a.envMap || E
                                ),
                                T =
                                    S && S.mapping === h
                                        ? S.image.height
                                        : null,
                                w = v[a.type];
                            null !== a.precision &&
                                ((g = r.getMaxPrecision(a.precision)),
                                g !== a.precision &&
                                    console.warn(
                                        'THREE.WebGLProgram.getParameters:',
                                        a.precision,
                                        'not supported, using',
                                        g,
                                        'instead.'
                                    ));
                            const A =
                                    b.morphAttributes.position ||
                                    b.morphAttributes.normal ||
                                    b.morphAttributes.color,
                                C = void 0 !== A ? A.length : 0;
                            let R,
                                L,
                                P,
                                D,
                                I = 0;
                            if (
                                (void 0 !== b.morphAttributes.position &&
                                    (I = 1),
                                void 0 !== b.morphAttributes.normal && (I = 2),
                                void 0 !== b.morphAttributes.color && (I = 3),
                                w)
                            ) {
                                const t = Qn[w];
                                (R = t.vertexShader), (L = t.fragmentShader);
                            } else
                                (R = a.vertexShader),
                                    (L = a.fragmentShader),
                                    u.update(a),
                                    (P = u.getVertexShaderID(a)),
                                    (D = u.getFragmentShaderID(a));
                            const U = t.getRenderTarget(),
                                O = !0 === y.isInstancedMesh,
                                N = !!a.map,
                                F = !!a.matcap,
                                B = !!S,
                                k = !!a.aoMap,
                                H = !!a.lightMap,
                                G = !!a.bumpMap,
                                V = !!a.normalMap,
                                W = !!a.displacementMap,
                                j = !!a.emissiveMap,
                                X = !!a.metalnessMap,
                                Y = !!a.roughnessMap,
                                q = a.clearcoat > 0,
                                K = a.iridescence > 0,
                                Z = a.sheen > 0,
                                J = a.transmission > 0,
                                Q = q && !!a.clearcoatMap,
                                $ = q && !!a.clearcoatNormalMap,
                                tt = q && !!a.clearcoatRoughnessMap,
                                et = K && !!a.iridescenceMap,
                                nt = K && !!a.iridescenceThicknessMap,
                                it = Z && !!a.sheenColorMap,
                                rt = Z && !!a.sheenRoughnessMap,
                                at = !!a.specularMap,
                                ot = !!a.specularColorMap,
                                st = !!a.specularIntensityMap,
                                lt = J && !!a.transmissionMap,
                                ct = J && !!a.thicknessMap,
                                ut = !!a.gradientMap,
                                ht = !!a.alphaMap,
                                dt = a.alphaTest > 0,
                                pt = !!a.extensions,
                                ft = !!b.attributes.uv1,
                                mt = !!b.attributes.uv2,
                                gt = !!b.attributes.uv3;
                            return {
                                isWebGL2: p,
                                shaderID: w,
                                shaderName: a.type,
                                vertexShader: R,
                                fragmentShader: L,
                                defines: a.defines,
                                customVertexShaderID: P,
                                customFragmentShaderID: D,
                                isRawShaderMaterial:
                                    !0 === a.isRawShaderMaterial,
                                glslVersion: a.glslVersion,
                                precision: g,
                                instancing: O,
                                instancingColor: O && null !== y.instanceColor,
                                supportsVertexTextures: m,
                                outputColorSpace:
                                    null === U
                                        ? t.outputColorSpace
                                        : !0 === U.isXRRenderTarget
                                          ? U.texture.colorSpace
                                          : z,
                                map: N,
                                matcap: F,
                                envMap: B,
                                envMapMode: B && S.mapping,
                                envMapCubeUVHeight: T,
                                aoMap: k,
                                lightMap: H,
                                bumpMap: G,
                                normalMap: V,
                                displacementMap: m && W,
                                emissiveMap: j,
                                normalMapObjectSpace:
                                    V && 1 === a.normalMapType,
                                normalMapTangentSpace:
                                    V && 0 === a.normalMapType,
                                metalnessMap: X,
                                roughnessMap: Y,
                                clearcoat: q,
                                clearcoatMap: Q,
                                clearcoatNormalMap: $,
                                clearcoatRoughnessMap: tt,
                                iridescence: K,
                                iridescenceMap: et,
                                iridescenceThicknessMap: nt,
                                sheen: Z,
                                sheenColorMap: it,
                                sheenRoughnessMap: rt,
                                specularMap: at,
                                specularColorMap: ot,
                                specularIntensityMap: st,
                                transmission: J,
                                transmissionMap: lt,
                                thicknessMap: ct,
                                gradientMap: ut,
                                opaque:
                                    !1 === a.transparent && 1 === a.blending,
                                alphaMap: ht,
                                alphaTest: dt,
                                combine: a.combine,
                                mapUv: N && _(a.map.channel),
                                aoMapUv: k && _(a.aoMap.channel),
                                lightMapUv: H && _(a.lightMap.channel),
                                bumpMapUv: G && _(a.bumpMap.channel),
                                normalMapUv: V && _(a.normalMap.channel),
                                displacementMapUv:
                                    W && _(a.displacementMap.channel),
                                emissiveMapUv: j && _(a.emissiveMap.channel),
                                metalnessMapUv: X && _(a.metalnessMap.channel),
                                roughnessMapUv: Y && _(a.roughnessMap.channel),
                                clearcoatMapUv: Q && _(a.clearcoatMap.channel),
                                clearcoatNormalMapUv:
                                    $ && _(a.clearcoatNormalMap.channel),
                                clearcoatRoughnessMapUv:
                                    tt && _(a.clearcoatRoughnessMap.channel),
                                iridescenceMapUv:
                                    et && _(a.iridescenceMap.channel),
                                iridescenceThicknessMapUv:
                                    nt && _(a.iridescenceThicknessMap.channel),
                                sheenColorMapUv:
                                    it && _(a.sheenColorMap.channel),
                                sheenRoughnessMapUv:
                                    rt && _(a.sheenRoughnessMap.channel),
                                specularMapUv: at && _(a.specularMap.channel),
                                specularColorMapUv:
                                    ot && _(a.specularColorMap.channel),
                                specularIntensityMapUv:
                                    st && _(a.specularIntensityMap.channel),
                                transmissionMapUv:
                                    lt && _(a.transmissionMap.channel),
                                thicknessMapUv: ct && _(a.thicknessMap.channel),
                                alphaMapUv: ht && _(a.alphaMap.channel),
                                vertexTangents: V && !!b.attributes.tangent,
                                vertexColors: a.vertexColors,
                                vertexAlphas:
                                    !0 === a.vertexColors &&
                                    !!b.attributes.color &&
                                    4 === b.attributes.color.itemSize,
                                vertexUv1s: ft,
                                vertexUv2s: mt,
                                vertexUv3s: gt,
                                pointsUvs:
                                    !0 === y.isPoints &&
                                    !!b.attributes.uv &&
                                    (N || ht),
                                fog: !!M,
                                useFog: !0 === a.fog,
                                fogExp2: M && M.isFogExp2,
                                flatShading: !0 === a.flatShading,
                                sizeAttenuation: !0 === a.sizeAttenuation,
                                logarithmicDepthBuffer: f,
                                skinning: !0 === y.isSkinnedMesh,
                                morphTargets:
                                    void 0 !== b.morphAttributes.position,
                                morphNormals:
                                    void 0 !== b.morphAttributes.normal,
                                morphColors: void 0 !== b.morphAttributes.color,
                                morphTargetsCount: C,
                                morphTextureStride: I,
                                numDirLights: c.directional.length,
                                numPointLights: c.point.length,
                                numSpotLights: c.spot.length,
                                numSpotLightMaps: c.spotLightMap.length,
                                numRectAreaLights: c.rectArea.length,
                                numHemiLights: c.hemi.length,
                                numDirLightShadows:
                                    c.directionalShadowMap.length,
                                numPointLightShadows: c.pointShadowMap.length,
                                numSpotLightShadows: c.spotShadowMap.length,
                                numSpotLightShadowsWithMaps:
                                    c.numSpotLightShadowsWithMaps,
                                numClippingPlanes: l.numPlanes,
                                numClipIntersection: l.numIntersection,
                                dithering: a.dithering,
                                shadowMapEnabled:
                                    t.shadowMap.enabled && d.length > 0,
                                shadowMapType: t.shadowMap.type,
                                toneMapping: a.toneMapped ? t.toneMapping : 0,
                                useLegacyLights: t.useLegacyLights,
                                premultipliedAlpha: a.premultipliedAlpha,
                                doubleSided: a.side === s,
                                flipSided: a.side === o,
                                useDepthPacking: a.depthPacking >= 0,
                                depthPacking: a.depthPacking || 0,
                                index0AttributeName: a.index0AttributeName,
                                extensionDerivatives:
                                    pt && !0 === a.extensions.derivatives,
                                extensionFragDepth:
                                    pt && !0 === a.extensions.fragDepth,
                                extensionDrawBuffers:
                                    pt && !0 === a.extensions.drawBuffers,
                                extensionShaderTextureLOD:
                                    pt && !0 === a.extensions.shaderTextureLOD,
                                rendererExtensionFragDepth:
                                    p || i.has('EXT_frag_depth'),
                                rendererExtensionDrawBuffers:
                                    p || i.has('WEBGL_draw_buffers'),
                                rendererExtensionShaderTextureLod:
                                    p || i.has('EXT_shader_texture_lod'),
                                customProgramCacheKey:
                                    a.customProgramCacheKey(),
                            };
                        },
                        getProgramCacheKey: function (e) {
                            const n = [];
                            if (
                                (e.shaderID
                                    ? n.push(e.shaderID)
                                    : (n.push(e.customVertexShaderID),
                                      n.push(e.customFragmentShaderID)),
                                void 0 !== e.defines)
                            )
                                for (const t in e.defines)
                                    n.push(t), n.push(e.defines[t]);
                            return (
                                !1 === e.isRawShaderMaterial &&
                                    ((function (t, e) {
                                        t.push(e.precision),
                                            t.push(e.outputColorSpace),
                                            t.push(e.envMapMode),
                                            t.push(e.envMapCubeUVHeight),
                                            t.push(e.mapUv),
                                            t.push(e.alphaMapUv),
                                            t.push(e.lightMapUv),
                                            t.push(e.aoMapUv),
                                            t.push(e.bumpMapUv),
                                            t.push(e.normalMapUv),
                                            t.push(e.displacementMapUv),
                                            t.push(e.emissiveMapUv),
                                            t.push(e.metalnessMapUv),
                                            t.push(e.roughnessMapUv),
                                            t.push(e.clearcoatMapUv),
                                            t.push(e.clearcoatNormalMapUv),
                                            t.push(e.clearcoatRoughnessMapUv),
                                            t.push(e.iridescenceMapUv),
                                            t.push(e.iridescenceThicknessMapUv),
                                            t.push(e.sheenColorMapUv),
                                            t.push(e.sheenRoughnessMapUv),
                                            t.push(e.specularMapUv),
                                            t.push(e.specularColorMapUv),
                                            t.push(e.specularIntensityMapUv),
                                            t.push(e.transmissionMapUv),
                                            t.push(e.thicknessMapUv),
                                            t.push(e.combine),
                                            t.push(e.fogExp2),
                                            t.push(e.sizeAttenuation),
                                            t.push(e.morphTargetsCount),
                                            t.push(e.morphAttributeCount),
                                            t.push(e.numDirLights),
                                            t.push(e.numPointLights),
                                            t.push(e.numSpotLights),
                                            t.push(e.numSpotLightMaps),
                                            t.push(e.numHemiLights),
                                            t.push(e.numRectAreaLights),
                                            t.push(e.numDirLightShadows),
                                            t.push(e.numPointLightShadows),
                                            t.push(e.numSpotLightShadows),
                                            t.push(
                                                e.numSpotLightShadowsWithMaps
                                            ),
                                            t.push(e.shadowMapType),
                                            t.push(e.toneMapping),
                                            t.push(e.numClippingPlanes),
                                            t.push(e.numClipIntersection),
                                            t.push(e.depthPacking);
                                    })(n, e),
                                    (function (t, e) {
                                        c.disableAll(),
                                            e.isWebGL2 && c.enable(0),
                                            e.supportsVertexTextures &&
                                                c.enable(1),
                                            e.instancing && c.enable(2),
                                            e.instancingColor && c.enable(3),
                                            e.matcap && c.enable(4),
                                            e.envMap && c.enable(5),
                                            e.normalMapObjectSpace &&
                                                c.enable(6),
                                            e.normalMapTangentSpace &&
                                                c.enable(7),
                                            e.clearcoat && c.enable(8),
                                            e.iridescence && c.enable(9),
                                            e.alphaTest && c.enable(10),
                                            e.vertexColors && c.enable(11),
                                            e.vertexAlphas && c.enable(12),
                                            e.vertexUv1s && c.enable(13),
                                            e.vertexUv2s && c.enable(14),
                                            e.vertexUv3s && c.enable(15),
                                            e.vertexTangents && c.enable(16),
                                            t.push(c.mask),
                                            c.disableAll(),
                                            e.fog && c.enable(0),
                                            e.useFog && c.enable(1),
                                            e.flatShading && c.enable(2),
                                            e.logarithmicDepthBuffer &&
                                                c.enable(3),
                                            e.skinning && c.enable(4),
                                            e.morphTargets && c.enable(5),
                                            e.morphNormals && c.enable(6),
                                            e.morphColors && c.enable(7),
                                            e.premultipliedAlpha && c.enable(8),
                                            e.shadowMapEnabled && c.enable(9),
                                            e.useLegacyLights && c.enable(10),
                                            e.doubleSided && c.enable(11),
                                            e.flipSided && c.enable(12),
                                            e.useDepthPacking && c.enable(13),
                                            e.dithering && c.enable(14),
                                            e.transmission && c.enable(15),
                                            e.sheen && c.enable(16),
                                            e.opaque && c.enable(17),
                                            e.pointsUvs && c.enable(18),
                                            t.push(c.mask);
                                    })(n, e),
                                    n.push(t.outputColorSpace)),
                                n.push(e.customProgramCacheKey),
                                n.join()
                            );
                        },
                        getUniforms: function (t) {
                            const e = v[t.type];
                            let n;
                            if (e) {
                                const t = Qn[e];
                                n = Dn.clone(t.uniforms);
                            } else n = t.uniforms;
                            return n;
                        },
                        acquireProgram: function (e, n) {
                            let i;
                            for (let t = 0, e = d.length; t < e; t++) {
                                const e = d[t];
                                if (e.cacheKey === n) {
                                    (i = e), ++i.usedTimes;
                                    break;
                                }
                            }
                            return (
                                void 0 === i &&
                                    ((i = new Yr(t, n, e, a)), d.push(i)),
                                i
                            );
                        },
                        releaseProgram: function (t) {
                            if (0 == --t.usedTimes) {
                                const e = d.indexOf(t);
                                (d[e] = d[d.length - 1]), d.pop(), t.destroy();
                            }
                        },
                        releaseShaderCache: function (t) {
                            u.remove(t);
                        },
                        programs: d,
                        dispose: function () {
                            u.dispose();
                        },
                    };
                }
                function Qr() {
                    let t = new WeakMap();
                    return {
                        get: function (e) {
                            let n = t.get(e);
                            return void 0 === n && ((n = {}), t.set(e, n)), n;
                        },
                        remove: function (e) {
                            t.delete(e);
                        },
                        update: function (e, n, i) {
                            t.get(e)[n] = i;
                        },
                        dispose: function () {
                            t = new WeakMap();
                        },
                    };
                }
                function $r(t, e) {
                    return t.groupOrder !== e.groupOrder
                        ? t.groupOrder - e.groupOrder
                        : t.renderOrder !== e.renderOrder
                          ? t.renderOrder - e.renderOrder
                          : t.material.id !== e.material.id
                            ? t.material.id - e.material.id
                            : t.z !== e.z
                              ? t.z - e.z
                              : t.id - e.id;
                }
                function ta(t, e) {
                    return t.groupOrder !== e.groupOrder
                        ? t.groupOrder - e.groupOrder
                        : t.renderOrder !== e.renderOrder
                          ? t.renderOrder - e.renderOrder
                          : t.z !== e.z
                            ? e.z - t.z
                            : t.id - e.id;
                }
                function ea() {
                    const t = [];
                    let e = 0;
                    const n = [],
                        i = [],
                        r = [];
                    function a(n, i, r, a, o, s) {
                        let l = t[e];
                        return (
                            void 0 === l
                                ? ((l = {
                                      id: n.id,
                                      object: n,
                                      geometry: i,
                                      material: r,
                                      groupOrder: a,
                                      renderOrder: n.renderOrder,
                                      z: o,
                                      group: s,
                                  }),
                                  (t[e] = l))
                                : ((l.id = n.id),
                                  (l.object = n),
                                  (l.geometry = i),
                                  (l.material = r),
                                  (l.groupOrder = a),
                                  (l.renderOrder = n.renderOrder),
                                  (l.z = o),
                                  (l.group = s)),
                            e++,
                            l
                        );
                    }
                    return {
                        opaque: n,
                        transmissive: i,
                        transparent: r,
                        init: function () {
                            (e = 0),
                                (n.length = 0),
                                (i.length = 0),
                                (r.length = 0);
                        },
                        push: function (t, e, o, s, l, c) {
                            const u = a(t, e, o, s, l, c);
                            o.transmission > 0
                                ? i.push(u)
                                : !0 === o.transparent
                                  ? r.push(u)
                                  : n.push(u);
                        },
                        unshift: function (t, e, o, s, l, c) {
                            const u = a(t, e, o, s, l, c);
                            o.transmission > 0
                                ? i.unshift(u)
                                : !0 === o.transparent
                                  ? r.unshift(u)
                                  : n.unshift(u);
                        },
                        finish: function () {
                            for (let n = e, i = t.length; n < i; n++) {
                                const e = t[n];
                                if (null === e.id) break;
                                (e.id = null),
                                    (e.object = null),
                                    (e.geometry = null),
                                    (e.material = null),
                                    (e.group = null);
                            }
                        },
                        sort: function (t, e) {
                            n.length > 1 && n.sort(t || $r),
                                i.length > 1 && i.sort(e || ta),
                                r.length > 1 && r.sort(e || ta);
                        },
                    };
                }
                function na() {
                    let t = new WeakMap();
                    return {
                        get: function (e, n) {
                            const i = t.get(e);
                            let r;
                            return (
                                void 0 === i
                                    ? ((r = new ea()), t.set(e, [r]))
                                    : n >= i.length
                                      ? ((r = new ea()), i.push(r))
                                      : (r = i[n]),
                                r
                            );
                        },
                        dispose: function () {
                            t = new WeakMap();
                        },
                    };
                }
                function ia() {
                    const t = {};
                    return {
                        get: function (e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case 'DirectionalLight':
                                    n = {
                                        direction: new Tt(),
                                        color: new je(),
                                    };
                                    break;
                                case 'SpotLight':
                                    n = {
                                        position: new Tt(),
                                        direction: new Tt(),
                                        color: new je(),
                                        distance: 0,
                                        coneCos: 0,
                                        penumbraCos: 0,
                                        decay: 0,
                                    };
                                    break;
                                case 'PointLight':
                                    n = {
                                        position: new Tt(),
                                        color: new je(),
                                        distance: 0,
                                        decay: 0,
                                    };
                                    break;
                                case 'HemisphereLight':
                                    n = {
                                        direction: new Tt(),
                                        skyColor: new je(),
                                        groundColor: new je(),
                                    };
                                    break;
                                case 'RectAreaLight':
                                    n = {
                                        color: new je(),
                                        position: new Tt(),
                                        halfWidth: new Tt(),
                                        halfHeight: new Tt(),
                                    };
                            }
                            return (t[e.id] = n), n;
                        },
                    };
                }
                let ra = 0;
                function aa(t, e) {
                    return (
                        (e.castShadow ? 2 : 0) -
                        (t.castShadow ? 2 : 0) +
                        (e.map ? 1 : 0) -
                        (t.map ? 1 : 0)
                    );
                }
                function oa(t, e) {
                    const n = new ia(),
                        i = (function () {
                            const t = {};
                            return {
                                get: function (e) {
                                    if (void 0 !== t[e.id]) return t[e.id];
                                    let n;
                                    switch (e.type) {
                                        case 'DirectionalLight':
                                        case 'SpotLight':
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new tt(),
                                            };
                                            break;
                                        case 'PointLight':
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new tt(),
                                                shadowCameraNear: 1,
                                                shadowCameraFar: 1e3,
                                            };
                                    }
                                    return (t[e.id] = n), n;
                                },
                            };
                        })(),
                        r = {
                            version: 0,
                            hash: {
                                directionalLength: -1,
                                pointLength: -1,
                                spotLength: -1,
                                rectAreaLength: -1,
                                hemiLength: -1,
                                numDirectionalShadows: -1,
                                numPointShadows: -1,
                                numSpotShadows: -1,
                                numSpotMaps: -1,
                            },
                            ambient: [0, 0, 0],
                            probe: [],
                            directional: [],
                            directionalShadow: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotLightMap: [],
                            spotShadow: [],
                            spotShadowMap: [],
                            spotLightMatrix: [],
                            rectArea: [],
                            rectAreaLTC1: null,
                            rectAreaLTC2: null,
                            point: [],
                            pointShadow: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: [],
                            numSpotLightShadowsWithMaps: 0,
                        };
                    for (let t = 0; t < 9; t++) r.probe.push(new Tt());
                    const a = new Tt(),
                        o = new ee(),
                        s = new ee();
                    return {
                        setup: function (a, o) {
                            let s = 0,
                                l = 0,
                                c = 0;
                            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                            let u = 0,
                                h = 0,
                                d = 0,
                                p = 0,
                                f = 0,
                                m = 0,
                                g = 0,
                                v = 0,
                                _ = 0,
                                x = 0;
                            a.sort(aa);
                            const y = !0 === o ? Math.PI : 1;
                            for (let t = 0, e = a.length; t < e; t++) {
                                const e = a[t],
                                    o = e.color,
                                    M = e.intensity,
                                    b = e.distance,
                                    E =
                                        e.shadow && e.shadow.map
                                            ? e.shadow.map.texture
                                            : null;
                                if (e.isAmbientLight)
                                    (s += o.r * M * y),
                                        (l += o.g * M * y),
                                        (c += o.b * M * y);
                                else if (e.isLightProbe)
                                    for (let t = 0; t < 9; t++)
                                        r.probe[t].addScaledVector(
                                            e.sh.coefficients[t],
                                            M
                                        );
                                else if (e.isDirectionalLight) {
                                    const t = n.get(e);
                                    if (
                                        (t.color
                                            .copy(e.color)
                                            .multiplyScalar(e.intensity * y),
                                        e.castShadow)
                                    ) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        (n.shadowBias = t.bias),
                                            (n.shadowNormalBias = t.normalBias),
                                            (n.shadowRadius = t.radius),
                                            (n.shadowMapSize = t.mapSize),
                                            (r.directionalShadow[u] = n),
                                            (r.directionalShadowMap[u] = E),
                                            (r.directionalShadowMatrix[u] =
                                                e.shadow.matrix),
                                            m++;
                                    }
                                    (r.directional[u] = t), u++;
                                } else if (e.isSpotLight) {
                                    const t = n.get(e);
                                    t.position.setFromMatrixPosition(
                                        e.matrixWorld
                                    ),
                                        t.color.copy(o).multiplyScalar(M * y),
                                        (t.distance = b),
                                        (t.coneCos = Math.cos(e.angle)),
                                        (t.penumbraCos = Math.cos(
                                            e.angle * (1 - e.penumbra)
                                        )),
                                        (t.decay = e.decay),
                                        (r.spot[d] = t);
                                    const a = e.shadow;
                                    if (
                                        (e.map &&
                                            ((r.spotLightMap[_] = e.map),
                                            _++,
                                            a.updateMatrices(e),
                                            e.castShadow && x++),
                                        (r.spotLightMatrix[d] = a.matrix),
                                        e.castShadow)
                                    ) {
                                        const t = i.get(e);
                                        (t.shadowBias = a.bias),
                                            (t.shadowNormalBias = a.normalBias),
                                            (t.shadowRadius = a.radius),
                                            (t.shadowMapSize = a.mapSize),
                                            (r.spotShadow[d] = t),
                                            (r.spotShadowMap[d] = E),
                                            v++;
                                    }
                                    d++;
                                } else if (e.isRectAreaLight) {
                                    const t = n.get(e);
                                    t.color.copy(o).multiplyScalar(M),
                                        t.halfWidth.set(0.5 * e.width, 0, 0),
                                        t.halfHeight.set(0, 0.5 * e.height, 0),
                                        (r.rectArea[p] = t),
                                        p++;
                                } else if (e.isPointLight) {
                                    const t = n.get(e);
                                    if (
                                        (t.color
                                            .copy(e.color)
                                            .multiplyScalar(e.intensity * y),
                                        (t.distance = e.distance),
                                        (t.decay = e.decay),
                                        e.castShadow)
                                    ) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        (n.shadowBias = t.bias),
                                            (n.shadowNormalBias = t.normalBias),
                                            (n.shadowRadius = t.radius),
                                            (n.shadowMapSize = t.mapSize),
                                            (n.shadowCameraNear =
                                                t.camera.near),
                                            (n.shadowCameraFar = t.camera.far),
                                            (r.pointShadow[h] = n),
                                            (r.pointShadowMap[h] = E),
                                            (r.pointShadowMatrix[h] =
                                                e.shadow.matrix),
                                            g++;
                                    }
                                    (r.point[h] = t), h++;
                                } else if (e.isHemisphereLight) {
                                    const t = n.get(e);
                                    t.skyColor
                                        .copy(e.color)
                                        .multiplyScalar(M * y),
                                        t.groundColor
                                            .copy(e.groundColor)
                                            .multiplyScalar(M * y),
                                        (r.hemi[f] = t),
                                        f++;
                                }
                            }
                            p > 0 &&
                                (e.isWebGL2 ||
                                !0 === t.has('OES_texture_float_linear')
                                    ? ((r.rectAreaLTC1 = Jn.LTC_FLOAT_1),
                                      (r.rectAreaLTC2 = Jn.LTC_FLOAT_2))
                                    : !0 ===
                                        t.has('OES_texture_half_float_linear')
                                      ? ((r.rectAreaLTC1 = Jn.LTC_HALF_1),
                                        (r.rectAreaLTC2 = Jn.LTC_HALF_2))
                                      : console.error(
                                            'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.'
                                        )),
                                (r.ambient[0] = s),
                                (r.ambient[1] = l),
                                (r.ambient[2] = c);
                            const M = r.hash;
                            (M.directionalLength === u &&
                                M.pointLength === h &&
                                M.spotLength === d &&
                                M.rectAreaLength === p &&
                                M.hemiLength === f &&
                                M.numDirectionalShadows === m &&
                                M.numPointShadows === g &&
                                M.numSpotShadows === v &&
                                M.numSpotMaps === _) ||
                                ((r.directional.length = u),
                                (r.spot.length = d),
                                (r.rectArea.length = p),
                                (r.point.length = h),
                                (r.hemi.length = f),
                                (r.directionalShadow.length = m),
                                (r.directionalShadowMap.length = m),
                                (r.pointShadow.length = g),
                                (r.pointShadowMap.length = g),
                                (r.spotShadow.length = v),
                                (r.spotShadowMap.length = v),
                                (r.directionalShadowMatrix.length = m),
                                (r.pointShadowMatrix.length = g),
                                (r.spotLightMatrix.length = v + _ - x),
                                (r.spotLightMap.length = _),
                                (r.numSpotLightShadowsWithMaps = x),
                                (M.directionalLength = u),
                                (M.pointLength = h),
                                (M.spotLength = d),
                                (M.rectAreaLength = p),
                                (M.hemiLength = f),
                                (M.numDirectionalShadows = m),
                                (M.numPointShadows = g),
                                (M.numSpotShadows = v),
                                (M.numSpotMaps = _),
                                (r.version = ra++));
                        },
                        setupView: function (t, e) {
                            let n = 0,
                                i = 0,
                                l = 0,
                                c = 0,
                                u = 0;
                            const h = e.matrixWorldInverse;
                            for (let e = 0, d = t.length; e < d; e++) {
                                const d = t[e];
                                if (d.isDirectionalLight) {
                                    const t = r.directional[n];
                                    t.direction.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        a.setFromMatrixPosition(
                                            d.target.matrixWorld
                                        ),
                                        t.direction.sub(a),
                                        t.direction.transformDirection(h),
                                        n++;
                                } else if (d.isSpotLight) {
                                    const t = r.spot[l];
                                    t.position.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        t.position.applyMatrix4(h),
                                        t.direction.setFromMatrixPosition(
                                            d.matrixWorld
                                        ),
                                        a.setFromMatrixPosition(
                                            d.target.matrixWorld
                                        ),
                                        t.direction.sub(a),
                                        t.direction.transformDirection(h),
                                        l++;
                                } else if (d.isRectAreaLight) {
                                    const t = r.rectArea[c];
                                    t.position.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        t.position.applyMatrix4(h),
                                        s.identity(),
                                        o.copy(d.matrixWorld),
                                        o.premultiply(h),
                                        s.extractRotation(o),
                                        t.halfWidth.set(0.5 * d.width, 0, 0),
                                        t.halfHeight.set(0, 0.5 * d.height, 0),
                                        t.halfWidth.applyMatrix4(s),
                                        t.halfHeight.applyMatrix4(s),
                                        c++;
                                } else if (d.isPointLight) {
                                    const t = r.point[i];
                                    t.position.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        t.position.applyMatrix4(h),
                                        i++;
                                } else if (d.isHemisphereLight) {
                                    const t = r.hemi[u];
                                    t.direction.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        t.direction.transformDirection(h),
                                        u++;
                                }
                            }
                        },
                        state: r,
                    };
                }
                function sa(t, e) {
                    const n = new oa(t, e),
                        i = [],
                        r = [];
                    return {
                        init: function () {
                            (i.length = 0), (r.length = 0);
                        },
                        state: { lightsArray: i, shadowsArray: r, lights: n },
                        setupLights: function (t) {
                            n.setup(i, t);
                        },
                        setupLightsView: function (t) {
                            n.setupView(i, t);
                        },
                        pushLight: function (t) {
                            i.push(t);
                        },
                        pushShadow: function (t) {
                            r.push(t);
                        },
                    };
                }
                function la(t, e) {
                    let n = new WeakMap();
                    return {
                        get: function (i, r = 0) {
                            const a = n.get(i);
                            let o;
                            return (
                                void 0 === a
                                    ? ((o = new sa(t, e)), n.set(i, [o]))
                                    : r >= a.length
                                      ? ((o = new sa(t, e)), a.push(o))
                                      : (o = a[r]),
                                o
                            );
                        },
                        dispose: function () {
                            n = new WeakMap();
                        },
                    };
                }
                class ca extends ke {
                    constructor(t) {
                        super(),
                            (this.isMeshDepthMaterial = !0),
                            (this.type = 'MeshDepthMaterial'),
                            (this.depthPacking = 3200),
                            (this.map = null),
                            (this.alphaMap = null),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.depthPacking = t.depthPacking),
                            (this.map = t.map),
                            (this.alphaMap = t.alphaMap),
                            (this.displacementMap = t.displacementMap),
                            (this.displacementScale = t.displacementScale),
                            (this.displacementBias = t.displacementBias),
                            (this.wireframe = t.wireframe),
                            (this.wireframeLinewidth = t.wireframeLinewidth),
                            this
                        );
                    }
                }
                class ua extends ke {
                    constructor(t) {
                        super(),
                            (this.isMeshDistanceMaterial = !0),
                            (this.type = 'MeshDistanceMaterial'),
                            (this.map = null),
                            (this.alphaMap = null),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            (this.map = t.map),
                            (this.alphaMap = t.alphaMap),
                            (this.displacementMap = t.displacementMap),
                            (this.displacementScale = t.displacementScale),
                            (this.displacementBias = t.displacementBias),
                            this
                        );
                    }
                }
                function ha(t, e, n) {
                    let i = new Xn();
                    const r = new tt(),
                        a = new tt(),
                        l = new yt(),
                        c = new ca({ depthPacking: 3201 }),
                        u = new ua(),
                        h = {},
                        d = n.maxTextureSize,
                        p = { 0: o, [o]: 0, [s]: s },
                        f = new In({
                            defines: { VSM_SAMPLES: 8 },
                            uniforms: {
                                shadow_pass: { value: null },
                                resolution: { value: new tt() },
                                radius: { value: 4 },
                            },
                            vertexShader:
                                'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
                            fragmentShader:
                                'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}',
                        }),
                        g = f.clone();
                    g.defines.HORIZONTAL_PASS = 1;
                    const v = new ln();
                    v.setAttribute(
                        'position',
                        new Ze(
                            new Float32Array([
                                -1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5,
                            ]),
                            3
                        )
                    );
                    const _ = new wn(v, f),
                        x = this;
                    (this.enabled = !1),
                        (this.autoUpdate = !0),
                        (this.needsUpdate = !1),
                        (this.type = 1);
                    let y = this.type;
                    function M(n, i) {
                        const a = e.update(_);
                        f.defines.VSM_SAMPLES !== n.blurSamples &&
                            ((f.defines.VSM_SAMPLES = n.blurSamples),
                            (g.defines.VSM_SAMPLES = n.blurSamples),
                            (f.needsUpdate = !0),
                            (g.needsUpdate = !0)),
                            null === n.mapPass &&
                                (n.mapPass = new Mt(r.x, r.y)),
                            (f.uniforms.shadow_pass.value = n.map.texture),
                            (f.uniforms.resolution.value = n.mapSize),
                            (f.uniforms.radius.value = n.radius),
                            t.setRenderTarget(n.mapPass),
                            t.clear(),
                            t.renderBufferDirect(i, null, a, f, _, null),
                            (g.uniforms.shadow_pass.value = n.mapPass.texture),
                            (g.uniforms.resolution.value = n.mapSize),
                            (g.uniforms.radius.value = n.radius),
                            t.setRenderTarget(n.map),
                            t.clear(),
                            t.renderBufferDirect(i, null, a, g, _, null);
                    }
                    function b(e, n, i, r) {
                        let a = null;
                        const o =
                            !0 === i.isPointLight
                                ? e.customDistanceMaterial
                                : e.customDepthMaterial;
                        if (void 0 !== o) a = o;
                        else if (
                            ((a = !0 === i.isPointLight ? u : c),
                            (t.localClippingEnabled &&
                                !0 === n.clipShadows &&
                                Array.isArray(n.clippingPlanes) &&
                                0 !== n.clippingPlanes.length) ||
                                (n.displacementMap &&
                                    0 !== n.displacementScale) ||
                                (n.alphaMap && n.alphaTest > 0) ||
                                (n.map && n.alphaTest > 0))
                        ) {
                            const t = a.uuid,
                                e = n.uuid;
                            let i = h[t];
                            void 0 === i && ((i = {}), (h[t] = i));
                            let r = i[e];
                            void 0 === r && ((r = a.clone()), (i[e] = r)),
                                (a = r);
                        }
                        return (
                            (a.visible = n.visible),
                            (a.wireframe = n.wireframe),
                            (a.side =
                                3 === r
                                    ? null !== n.shadowSide
                                        ? n.shadowSide
                                        : n.side
                                    : null !== n.shadowSide
                                      ? n.shadowSide
                                      : p[n.side]),
                            (a.alphaMap = n.alphaMap),
                            (a.alphaTest = n.alphaTest),
                            (a.map = n.map),
                            (a.clipShadows = n.clipShadows),
                            (a.clippingPlanes = n.clippingPlanes),
                            (a.clipIntersection = n.clipIntersection),
                            (a.displacementMap = n.displacementMap),
                            (a.displacementScale = n.displacementScale),
                            (a.displacementBias = n.displacementBias),
                            (a.wireframeLinewidth = n.wireframeLinewidth),
                            (a.linewidth = n.linewidth),
                            !0 === i.isPointLight &&
                                !0 === a.isMeshDistanceMaterial &&
                                (t.properties.get(a).light = i),
                            a
                        );
                    }
                    function E(n, r, a, o, s) {
                        if (!1 === n.visible) return;
                        if (
                            n.layers.test(r.layers) &&
                            (n.isMesh || n.isLine || n.isPoints) &&
                            (n.castShadow || (n.receiveShadow && 3 === s)) &&
                            (!n.frustumCulled || i.intersectsObject(n))
                        ) {
                            n.modelViewMatrix.multiplyMatrices(
                                a.matrixWorldInverse,
                                n.matrixWorld
                            );
                            const i = e.update(n),
                                r = n.material;
                            if (Array.isArray(r)) {
                                const e = i.groups;
                                for (let l = 0, c = e.length; l < c; l++) {
                                    const c = e[l],
                                        u = r[c.materialIndex];
                                    if (u && u.visible) {
                                        const e = b(n, u, o, s);
                                        t.renderBufferDirect(
                                            a,
                                            null,
                                            i,
                                            e,
                                            n,
                                            c
                                        );
                                    }
                                }
                            } else if (r.visible) {
                                const e = b(n, r, o, s);
                                t.renderBufferDirect(a, null, i, e, n, null);
                            }
                        }
                        const l = n.children;
                        for (let t = 0, e = l.length; t < e; t++)
                            E(l[t], r, a, o, s);
                    }
                    this.render = function (e, n, o) {
                        if (!1 === x.enabled) return;
                        if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
                        if (0 === e.length) return;
                        const s = t.getRenderTarget(),
                            c = t.getActiveCubeFace(),
                            u = t.getActiveMipmapLevel(),
                            h = t.state;
                        h.setBlending(0),
                            h.buffers.color.setClear(1, 1, 1, 1),
                            h.buffers.depth.setTest(!0),
                            h.setScissorTest(!1);
                        const p = 3 !== y && 3 === this.type,
                            f = 3 === y && 3 !== this.type;
                        for (let s = 0, c = e.length; s < c; s++) {
                            const c = e[s],
                                u = c.shadow;
                            if (void 0 === u) {
                                console.warn(
                                    'THREE.WebGLShadowMap:',
                                    c,
                                    'has no shadow.'
                                );
                                continue;
                            }
                            if (!1 === u.autoUpdate && !1 === u.needsUpdate)
                                continue;
                            r.copy(u.mapSize);
                            const g = u.getFrameExtents();
                            if (
                                (r.multiply(g),
                                a.copy(u.mapSize),
                                (r.x > d || r.y > d) &&
                                    (r.x > d &&
                                        ((a.x = Math.floor(d / g.x)),
                                        (r.x = a.x * g.x),
                                        (u.mapSize.x = a.x)),
                                    r.y > d &&
                                        ((a.y = Math.floor(d / g.y)),
                                        (r.y = a.y * g.y),
                                        (u.mapSize.y = a.y))),
                                null === u.map || !0 === p || !0 === f)
                            ) {
                                const t =
                                    3 !== this.type
                                        ? { minFilter: m, magFilter: m }
                                        : {};
                                null !== u.map && u.map.dispose(),
                                    (u.map = new Mt(r.x, r.y, t)),
                                    (u.map.texture.name =
                                        c.name + '.shadowMap'),
                                    u.camera.updateProjectionMatrix();
                            }
                            t.setRenderTarget(u.map), t.clear();
                            const v = u.getViewportCount();
                            for (let t = 0; t < v; t++) {
                                const e = u.getViewport(t);
                                l.set(
                                    a.x * e.x,
                                    a.y * e.y,
                                    a.x * e.z,
                                    a.y * e.w
                                ),
                                    h.viewport(l),
                                    u.updateMatrices(c, t),
                                    (i = u.getFrustum()),
                                    E(n, o, u.camera, c, this.type);
                            }
                            !0 !== u.isPointLightShadow &&
                                3 === this.type &&
                                M(u, o),
                                (u.needsUpdate = !1);
                        }
                        (y = this.type),
                            (x.needsUpdate = !1),
                            t.setRenderTarget(s, c, u);
                    };
                }
                function da(t, e, n) {
                    const i = n.isWebGL2,
                        r = new (function () {
                            let e = !1;
                            const n = new yt();
                            let i = null;
                            const r = new yt(0, 0, 0, 0);
                            return {
                                setMask: function (n) {
                                    i === n ||
                                        e ||
                                        (t.colorMask(n, n, n, n), (i = n));
                                },
                                setLocked: function (t) {
                                    e = t;
                                },
                                setClear: function (e, i, a, o, s) {
                                    !0 === s && ((e *= o), (i *= o), (a *= o)),
                                        n.set(e, i, a, o),
                                        !1 === r.equals(n) &&
                                            (t.clearColor(e, i, a, o),
                                            r.copy(n));
                                },
                                reset: function () {
                                    (e = !1), (i = null), r.set(-1, 0, 0, 0);
                                },
                            };
                        })(),
                        a = new (function () {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null;
                            return {
                                setTest: function (e) {
                                    e ? V(t.DEPTH_TEST) : W(t.DEPTH_TEST);
                                },
                                setMask: function (i) {
                                    n === i || e || (t.depthMask(i), (n = i));
                                },
                                setFunc: function (e) {
                                    if (i !== e) {
                                        switch (e) {
                                            case 0:
                                                t.depthFunc(t.NEVER);
                                                break;
                                            case 1:
                                                t.depthFunc(t.ALWAYS);
                                                break;
                                            case 2:
                                                t.depthFunc(t.LESS);
                                                break;
                                            case 3:
                                            default:
                                                t.depthFunc(t.LEQUAL);
                                                break;
                                            case 4:
                                                t.depthFunc(t.EQUAL);
                                                break;
                                            case 5:
                                                t.depthFunc(t.GEQUAL);
                                                break;
                                            case 6:
                                                t.depthFunc(t.GREATER);
                                                break;
                                            case 7:
                                                t.depthFunc(t.NOTEQUAL);
                                        }
                                        i = e;
                                    }
                                },
                                setLocked: function (t) {
                                    e = t;
                                },
                                setClear: function (e) {
                                    r !== e && (t.clearDepth(e), (r = e));
                                },
                                reset: function () {
                                    (e = !1),
                                        (n = null),
                                        (i = null),
                                        (r = null);
                                },
                            };
                        })(),
                        c = new (function () {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null,
                                a = null,
                                o = null,
                                s = null,
                                l = null,
                                c = null;
                            return {
                                setTest: function (n) {
                                    e ||
                                        (n
                                            ? V(t.STENCIL_TEST)
                                            : W(t.STENCIL_TEST));
                                },
                                setMask: function (i) {
                                    n === i || e || (t.stencilMask(i), (n = i));
                                },
                                setFunc: function (e, n, o) {
                                    (i === e && r === n && a === o) ||
                                        (t.stencilFunc(e, n, o),
                                        (i = e),
                                        (r = n),
                                        (a = o));
                                },
                                setOp: function (e, n, i) {
                                    (o === e && s === n && l === i) ||
                                        (t.stencilOp(e, n, i),
                                        (o = e),
                                        (s = n),
                                        (l = i));
                                },
                                setLocked: function (t) {
                                    e = t;
                                },
                                setClear: function (e) {
                                    c !== e && (t.clearStencil(e), (c = e));
                                },
                                reset: function () {
                                    (e = !1),
                                        (n = null),
                                        (i = null),
                                        (r = null),
                                        (a = null),
                                        (o = null),
                                        (s = null),
                                        (l = null),
                                        (c = null);
                                },
                            };
                        })(),
                        u = new WeakMap(),
                        h = new WeakMap();
                    let d = {},
                        p = {},
                        f = new WeakMap(),
                        m = [],
                        g = null,
                        v = !1,
                        _ = null,
                        x = null,
                        y = null,
                        M = null,
                        b = null,
                        E = null,
                        S = null,
                        T = !1,
                        w = null,
                        A = null,
                        C = null,
                        R = null,
                        L = null;
                    const P = t.getParameter(
                        t.MAX_COMBINED_TEXTURE_IMAGE_UNITS
                    );
                    let D = !1,
                        I = 0;
                    const U = t.getParameter(t.VERSION);
                    -1 !== U.indexOf('WebGL')
                        ? ((I = parseFloat(/^WebGL (\d)/.exec(U)[1])),
                          (D = I >= 1))
                        : -1 !== U.indexOf('OpenGL ES') &&
                          ((I = parseFloat(/^OpenGL ES (\d)/.exec(U)[1])),
                          (D = I >= 2));
                    let O = null,
                        N = {};
                    const F = t.getParameter(t.SCISSOR_BOX),
                        z = t.getParameter(t.VIEWPORT),
                        B = new yt().fromArray(F),
                        k = new yt().fromArray(z);
                    function H(e, n, r, a) {
                        const o = new Uint8Array(4),
                            s = t.createTexture();
                        t.bindTexture(e, s),
                            t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
                            t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                        for (let s = 0; s < r; s++)
                            !i ||
                            (e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY)
                                ? t.texImage2D(
                                      n + s,
                                      0,
                                      t.RGBA,
                                      1,
                                      1,
                                      0,
                                      t.RGBA,
                                      t.UNSIGNED_BYTE,
                                      o
                                  )
                                : t.texImage3D(
                                      n,
                                      0,
                                      t.RGBA,
                                      1,
                                      1,
                                      a,
                                      0,
                                      t.RGBA,
                                      t.UNSIGNED_BYTE,
                                      o
                                  );
                        return s;
                    }
                    const G = {};
                    function V(e) {
                        !0 !== d[e] && (t.enable(e), (d[e] = !0));
                    }
                    function W(e) {
                        !1 !== d[e] && (t.disable(e), (d[e] = !1));
                    }
                    (G[t.TEXTURE_2D] = H(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
                        (G[t.TEXTURE_CUBE_MAP] = H(
                            t.TEXTURE_CUBE_MAP,
                            t.TEXTURE_CUBE_MAP_POSITIVE_X,
                            6
                        )),
                        i &&
                            ((G[t.TEXTURE_2D_ARRAY] = H(
                                t.TEXTURE_2D_ARRAY,
                                t.TEXTURE_2D_ARRAY,
                                1,
                                1
                            )),
                            (G[t.TEXTURE_3D] = H(
                                t.TEXTURE_3D,
                                t.TEXTURE_3D,
                                1,
                                1
                            ))),
                        r.setClear(0, 0, 0, 1),
                        a.setClear(1),
                        c.setClear(0),
                        V(t.DEPTH_TEST),
                        a.setFunc(3),
                        q(!1),
                        K(1),
                        V(t.CULL_FACE),
                        Y(0);
                    const j = {
                        [l]: t.FUNC_ADD,
                        101: t.FUNC_SUBTRACT,
                        102: t.FUNC_REVERSE_SUBTRACT,
                    };
                    if (i) (j[103] = t.MIN), (j[104] = t.MAX);
                    else {
                        const t = e.get('EXT_blend_minmax');
                        null !== t &&
                            ((j[103] = t.MIN_EXT), (j[104] = t.MAX_EXT));
                    }
                    const X = {
                        200: t.ZERO,
                        201: t.ONE,
                        202: t.SRC_COLOR,
                        204: t.SRC_ALPHA,
                        210: t.SRC_ALPHA_SATURATE,
                        208: t.DST_COLOR,
                        206: t.DST_ALPHA,
                        203: t.ONE_MINUS_SRC_COLOR,
                        205: t.ONE_MINUS_SRC_ALPHA,
                        209: t.ONE_MINUS_DST_COLOR,
                        207: t.ONE_MINUS_DST_ALPHA,
                    };
                    function Y(e, n, i, r, a, o, s, c) {
                        if (0 !== e) {
                            if ((!1 === v && (V(t.BLEND), (v = !0)), 5 === e))
                                (a = a || n),
                                    (o = o || i),
                                    (s = s || r),
                                    (n === x && a === b) ||
                                        (t.blendEquationSeparate(j[n], j[a]),
                                        (x = n),
                                        (b = a)),
                                    (i === y &&
                                        r === M &&
                                        o === E &&
                                        s === S) ||
                                        (t.blendFuncSeparate(
                                            X[i],
                                            X[r],
                                            X[o],
                                            X[s]
                                        ),
                                        (y = i),
                                        (M = r),
                                        (E = o),
                                        (S = s)),
                                    (_ = e),
                                    (T = !1);
                            else if (e !== _ || c !== T) {
                                if (
                                    ((x === l && b === l) ||
                                        (t.blendEquation(t.FUNC_ADD),
                                        (x = l),
                                        (b = l)),
                                    c)
                                )
                                    switch (e) {
                                        case 1:
                                            t.blendFuncSeparate(
                                                t.ONE,
                                                t.ONE_MINUS_SRC_ALPHA,
                                                t.ONE,
                                                t.ONE_MINUS_SRC_ALPHA
                                            );
                                            break;
                                        case 2:
                                            t.blendFunc(t.ONE, t.ONE);
                                            break;
                                        case 3:
                                            t.blendFuncSeparate(
                                                t.ZERO,
                                                t.ONE_MINUS_SRC_COLOR,
                                                t.ZERO,
                                                t.ONE
                                            );
                                            break;
                                        case 4:
                                            t.blendFuncSeparate(
                                                t.ZERO,
                                                t.SRC_COLOR,
                                                t.ZERO,
                                                t.SRC_ALPHA
                                            );
                                            break;
                                        default:
                                            console.error(
                                                'THREE.WebGLState: Invalid blending: ',
                                                e
                                            );
                                    }
                                else
                                    switch (e) {
                                        case 1:
                                            t.blendFuncSeparate(
                                                t.SRC_ALPHA,
                                                t.ONE_MINUS_SRC_ALPHA,
                                                t.ONE,
                                                t.ONE_MINUS_SRC_ALPHA
                                            );
                                            break;
                                        case 2:
                                            t.blendFunc(t.SRC_ALPHA, t.ONE);
                                            break;
                                        case 3:
                                            t.blendFuncSeparate(
                                                t.ZERO,
                                                t.ONE_MINUS_SRC_COLOR,
                                                t.ZERO,
                                                t.ONE
                                            );
                                            break;
                                        case 4:
                                            t.blendFunc(t.ZERO, t.SRC_COLOR);
                                            break;
                                        default:
                                            console.error(
                                                'THREE.WebGLState: Invalid blending: ',
                                                e
                                            );
                                    }
                                (y = null),
                                    (M = null),
                                    (E = null),
                                    (S = null),
                                    (_ = e),
                                    (T = c);
                            }
                        } else !0 === v && (W(t.BLEND), (v = !1));
                    }
                    function q(e) {
                        w !== e &&
                            (e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
                            (w = e));
                    }
                    function K(e) {
                        0 !== e
                            ? (V(t.CULL_FACE),
                              e !== A &&
                                  (1 === e
                                      ? t.cullFace(t.BACK)
                                      : 2 === e
                                        ? t.cullFace(t.FRONT)
                                        : t.cullFace(t.FRONT_AND_BACK)))
                            : W(t.CULL_FACE),
                            (A = e);
                    }
                    function Z(e, n, i) {
                        e
                            ? (V(t.POLYGON_OFFSET_FILL),
                              (R === n && L === i) ||
                                  (t.polygonOffset(n, i), (R = n), (L = i)))
                            : W(t.POLYGON_OFFSET_FILL);
                    }
                    return {
                        buffers: { color: r, depth: a, stencil: c },
                        enable: V,
                        disable: W,
                        bindFramebuffer: function (e, n) {
                            return (
                                p[e] !== n &&
                                (t.bindFramebuffer(e, n),
                                (p[e] = n),
                                i &&
                                    (e === t.DRAW_FRAMEBUFFER &&
                                        (p[t.FRAMEBUFFER] = n),
                                    e === t.FRAMEBUFFER &&
                                        (p[t.DRAW_FRAMEBUFFER] = n)),
                                !0)
                            );
                        },
                        drawBuffers: function (i, r) {
                            let a = m,
                                o = !1;
                            if (i)
                                if (
                                    ((a = f.get(r)),
                                    void 0 === a && ((a = []), f.set(r, a)),
                                    i.isWebGLMultipleRenderTargets)
                                ) {
                                    const e = i.texture;
                                    if (
                                        a.length !== e.length ||
                                        a[0] !== t.COLOR_ATTACHMENT0
                                    ) {
                                        for (
                                            let n = 0, i = e.length;
                                            n < i;
                                            n++
                                        )
                                            a[n] = t.COLOR_ATTACHMENT0 + n;
                                        (a.length = e.length), (o = !0);
                                    }
                                } else
                                    a[0] !== t.COLOR_ATTACHMENT0 &&
                                        ((a[0] = t.COLOR_ATTACHMENT0),
                                        (o = !0));
                            else a[0] !== t.BACK && ((a[0] = t.BACK), (o = !0));
                            o &&
                                (n.isWebGL2
                                    ? t.drawBuffers(a)
                                    : e
                                          .get('WEBGL_draw_buffers')
                                          .drawBuffersWEBGL(a));
                        },
                        useProgram: function (e) {
                            return g !== e && (t.useProgram(e), (g = e), !0);
                        },
                        setBlending: Y,
                        setMaterial: function (e, n) {
                            e.side === s ? W(t.CULL_FACE) : V(t.CULL_FACE);
                            let i = e.side === o;
                            n && (i = !i),
                                q(i),
                                1 === e.blending && !1 === e.transparent
                                    ? Y(0)
                                    : Y(
                                          e.blending,
                                          e.blendEquation,
                                          e.blendSrc,
                                          e.blendDst,
                                          e.blendEquationAlpha,
                                          e.blendSrcAlpha,
                                          e.blendDstAlpha,
                                          e.premultipliedAlpha
                                      ),
                                a.setFunc(e.depthFunc),
                                a.setTest(e.depthTest),
                                a.setMask(e.depthWrite),
                                r.setMask(e.colorWrite);
                            const l = e.stencilWrite;
                            c.setTest(l),
                                l &&
                                    (c.setMask(e.stencilWriteMask),
                                    c.setFunc(
                                        e.stencilFunc,
                                        e.stencilRef,
                                        e.stencilFuncMask
                                    ),
                                    c.setOp(
                                        e.stencilFail,
                                        e.stencilZFail,
                                        e.stencilZPass
                                    )),
                                Z(
                                    e.polygonOffset,
                                    e.polygonOffsetFactor,
                                    e.polygonOffsetUnits
                                ),
                                !0 === e.alphaToCoverage
                                    ? V(t.SAMPLE_ALPHA_TO_COVERAGE)
                                    : W(t.SAMPLE_ALPHA_TO_COVERAGE);
                        },
                        setFlipSided: q,
                        setCullFace: K,
                        setLineWidth: function (e) {
                            e !== C && (D && t.lineWidth(e), (C = e));
                        },
                        setPolygonOffset: Z,
                        setScissorTest: function (e) {
                            e ? V(t.SCISSOR_TEST) : W(t.SCISSOR_TEST);
                        },
                        activeTexture: function (e) {
                            void 0 === e && (e = t.TEXTURE0 + P - 1),
                                O !== e && (t.activeTexture(e), (O = e));
                        },
                        bindTexture: function (e, n, i) {
                            void 0 === i &&
                                (i = null === O ? t.TEXTURE0 + P - 1 : O);
                            let r = N[i];
                            void 0 === r &&
                                ((r = { type: void 0, texture: void 0 }),
                                (N[i] = r)),
                                (r.type === e && r.texture === n) ||
                                    (O !== i && (t.activeTexture(i), (O = i)),
                                    t.bindTexture(e, n || G[e]),
                                    (r.type = e),
                                    (r.texture = n));
                        },
                        unbindTexture: function () {
                            const e = N[O];
                            void 0 !== e &&
                                void 0 !== e.type &&
                                (t.bindTexture(e.type, null),
                                (e.type = void 0),
                                (e.texture = void 0));
                        },
                        compressedTexImage2D: function () {
                            try {
                                t.compressedTexImage2D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        compressedTexImage3D: function () {
                            try {
                                t.compressedTexImage3D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        texImage2D: function () {
                            try {
                                t.texImage2D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        texImage3D: function () {
                            try {
                                t.texImage3D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        updateUBOMapping: function (e, n) {
                            let i = h.get(n);
                            void 0 === i && ((i = new WeakMap()), h.set(n, i));
                            let r = i.get(e);
                            void 0 === r &&
                                ((r = t.getUniformBlockIndex(n, e.name)),
                                i.set(e, r));
                        },
                        uniformBlockBinding: function (e, n) {
                            const i = h.get(n).get(e);
                            u.get(n) !== i &&
                                (t.uniformBlockBinding(
                                    n,
                                    i,
                                    e.__bindingPointIndex
                                ),
                                u.set(n, i));
                        },
                        texStorage2D: function () {
                            try {
                                t.texStorage2D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        texStorage3D: function () {
                            try {
                                t.texStorage3D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        texSubImage2D: function () {
                            try {
                                t.texSubImage2D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        texSubImage3D: function () {
                            try {
                                t.texSubImage3D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        compressedTexSubImage2D: function () {
                            try {
                                t.compressedTexSubImage2D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        compressedTexSubImage3D: function () {
                            try {
                                t.compressedTexSubImage3D.apply(t, arguments);
                            } catch (t) {
                                console.error('THREE.WebGLState:', t);
                            }
                        },
                        scissor: function (e) {
                            !1 === B.equals(e) &&
                                (t.scissor(e.x, e.y, e.z, e.w), B.copy(e));
                        },
                        viewport: function (e) {
                            !1 === k.equals(e) &&
                                (t.viewport(e.x, e.y, e.z, e.w), k.copy(e));
                        },
                        reset: function () {
                            t.disable(t.BLEND),
                                t.disable(t.CULL_FACE),
                                t.disable(t.DEPTH_TEST),
                                t.disable(t.POLYGON_OFFSET_FILL),
                                t.disable(t.SCISSOR_TEST),
                                t.disable(t.STENCIL_TEST),
                                t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
                                t.blendEquation(t.FUNC_ADD),
                                t.blendFunc(t.ONE, t.ZERO),
                                t.blendFuncSeparate(
                                    t.ONE,
                                    t.ZERO,
                                    t.ONE,
                                    t.ZERO
                                ),
                                t.colorMask(!0, !0, !0, !0),
                                t.clearColor(0, 0, 0, 0),
                                t.depthMask(!0),
                                t.depthFunc(t.LESS),
                                t.clearDepth(1),
                                t.stencilMask(4294967295),
                                t.stencilFunc(t.ALWAYS, 0, 4294967295),
                                t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
                                t.clearStencil(0),
                                t.cullFace(t.BACK),
                                t.frontFace(t.CCW),
                                t.polygonOffset(0, 0),
                                t.activeTexture(t.TEXTURE0),
                                t.bindFramebuffer(t.FRAMEBUFFER, null),
                                !0 === i &&
                                    (t.bindFramebuffer(
                                        t.DRAW_FRAMEBUFFER,
                                        null
                                    ),
                                    t.bindFramebuffer(
                                        t.READ_FRAMEBUFFER,
                                        null
                                    )),
                                t.useProgram(null),
                                t.lineWidth(1),
                                t.scissor(
                                    0,
                                    0,
                                    t.canvas.width,
                                    t.canvas.height
                                ),
                                t.viewport(
                                    0,
                                    0,
                                    t.canvas.width,
                                    t.canvas.height
                                ),
                                (d = {}),
                                (O = null),
                                (N = {}),
                                (p = {}),
                                (f = new WeakMap()),
                                (m = []),
                                (g = null),
                                (v = !1),
                                (_ = null),
                                (x = null),
                                (y = null),
                                (M = null),
                                (b = null),
                                (E = null),
                                (S = null),
                                (T = !1),
                                (w = null),
                                (A = null),
                                (C = null),
                                (R = null),
                                (L = null),
                                B.set(0, 0, t.canvas.width, t.canvas.height),
                                k.set(0, 0, t.canvas.width, t.canvas.height),
                                r.reset(),
                                a.reset(),
                                c.reset();
                        },
                    };
                }
                function pa(t, e, n, i, r, a, o) {
                    const s = r.isWebGL2,
                        l = r.maxTextures,
                        c = r.maxCubemapSize,
                        u = r.maxTextureSize,
                        h = r.maxSamples,
                        A = e.has('WEBGL_multisampled_render_to_texture')
                            ? e.get('WEBGL_multisampled_render_to_texture')
                            : null,
                        C =
                            'undefined' != typeof navigator &&
                            /OculusBrowser/g.test(navigator.userAgent),
                        R = new WeakMap();
                    let L;
                    const P = new WeakMap();
                    let D = !1;
                    try {
                        D =
                            'undefined' != typeof OffscreenCanvas &&
                            null !== new OffscreenCanvas(1, 1).getContext('2d');
                    } catch (t) {}
                    function I(t, e) {
                        return D ? new OffscreenCanvas(t, e) : rt('canvas');
                    }
                    function U(t, e, n, i) {
                        let r = 1;
                        if (
                            ((t.width > i || t.height > i) &&
                                (r = i / Math.max(t.width, t.height)),
                            r < 1 || !0 === e)
                        ) {
                            if (
                                ('undefined' != typeof HTMLImageElement &&
                                    t instanceof HTMLImageElement) ||
                                ('undefined' != typeof HTMLCanvasElement &&
                                    t instanceof HTMLCanvasElement) ||
                                ('undefined' != typeof ImageBitmap &&
                                    t instanceof ImageBitmap)
                            ) {
                                const i = e ? J : Math.floor,
                                    a = i(r * t.width),
                                    o = i(r * t.height);
                                void 0 === L && (L = I(a, o));
                                const s = n ? I(a, o) : L;
                                return (
                                    (s.width = a),
                                    (s.height = o),
                                    s.getContext('2d').drawImage(t, 0, 0, a, o),
                                    console.warn(
                                        'THREE.WebGLRenderer: Texture has been resized from (' +
                                            t.width +
                                            'x' +
                                            t.height +
                                            ') to (' +
                                            a +
                                            'x' +
                                            o +
                                            ').'
                                    ),
                                    s
                                );
                            }
                            return (
                                'data' in t &&
                                    console.warn(
                                        'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                                            t.width +
                                            'x' +
                                            t.height +
                                            ').'
                                    ),
                                t
                            );
                        }
                        return t;
                    }
                    function O(t) {
                        return Z(t.width) && Z(t.height);
                    }
                    function N(t, e) {
                        return (
                            t.generateMipmaps &&
                            e &&
                            t.minFilter !== m &&
                            t.minFilter !== v
                        );
                    }
                    function B(e) {
                        t.generateMipmap(e);
                    }
                    function k(n, i, r, a, o = !1) {
                        if (!1 === s) return i;
                        if (null !== n) {
                            if (void 0 !== t[n]) return t[n];
                            console.warn(
                                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                                    n +
                                    "'"
                            );
                        }
                        let l = i;
                        return (
                            i === t.RED &&
                                (r === t.FLOAT && (l = t.R32F),
                                r === t.HALF_FLOAT && (l = t.R16F),
                                r === t.UNSIGNED_BYTE && (l = t.R8)),
                            i === t.RG &&
                                (r === t.FLOAT && (l = t.RG32F),
                                r === t.HALF_FLOAT && (l = t.RG16F),
                                r === t.UNSIGNED_BYTE && (l = t.RG8)),
                            i === t.RGBA &&
                                (r === t.FLOAT && (l = t.RGBA32F),
                                r === t.HALF_FLOAT && (l = t.RGBA16F),
                                r === t.UNSIGNED_BYTE &&
                                    (l =
                                        a === F && !1 === o
                                            ? t.SRGB8_ALPHA8
                                            : t.RGBA8),
                                r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4),
                                r === t.UNSIGNED_SHORT_5_5_5_1 &&
                                    (l = t.RGB5_A1)),
                            (l !== t.R16F &&
                                l !== t.R32F &&
                                l !== t.RG16F &&
                                l !== t.RG32F &&
                                l !== t.RGBA16F &&
                                l !== t.RGBA32F) ||
                                e.get('EXT_color_buffer_float'),
                            l
                        );
                    }
                    function H(t, e, n) {
                        return !0 === N(t, n) ||
                            (t.isFramebufferTexture &&
                                t.minFilter !== m &&
                                t.minFilter !== v)
                            ? Math.log2(Math.max(e.width, e.height)) + 1
                            : void 0 !== t.mipmaps && t.mipmaps.length > 0
                              ? t.mipmaps.length
                              : t.isCompressedTexture && Array.isArray(t.image)
                                ? e.mipmaps.length
                                : 1;
                    }
                    function V(e) {
                        return e === m || 1004 === e || e === g
                            ? t.NEAREST
                            : t.LINEAR;
                    }
                    function W(t) {
                        const e = t.target;
                        e.removeEventListener('dispose', W),
                            (function (t) {
                                const e = i.get(t);
                                if (void 0 === e.__webglInit) return;
                                const n = t.source,
                                    r = P.get(n);
                                if (r) {
                                    const i = r[e.__cacheKey];
                                    i.usedTimes--,
                                        0 === i.usedTimes && X(t),
                                        0 === Object.keys(r).length &&
                                            P.delete(n);
                                }
                                i.remove(t);
                            })(e),
                            e.isVideoTexture && R.delete(e);
                    }
                    function j(e) {
                        const n = e.target;
                        n.removeEventListener('dispose', j),
                            (function (e) {
                                const n = e.texture,
                                    r = i.get(e),
                                    a = i.get(n);
                                if (
                                    (void 0 !== a.__webglTexture &&
                                        (t.deleteTexture(a.__webglTexture),
                                        o.memory.textures--),
                                    e.depthTexture && e.depthTexture.dispose(),
                                    e.isWebGLCubeRenderTarget)
                                )
                                    for (let e = 0; e < 6; e++)
                                        t.deleteFramebuffer(
                                            r.__webglFramebuffer[e]
                                        ),
                                            r.__webglDepthbuffer &&
                                                t.deleteRenderbuffer(
                                                    r.__webglDepthbuffer[e]
                                                );
                                else {
                                    if (
                                        (t.deleteFramebuffer(
                                            r.__webglFramebuffer
                                        ),
                                        r.__webglDepthbuffer &&
                                            t.deleteRenderbuffer(
                                                r.__webglDepthbuffer
                                            ),
                                        r.__webglMultisampledFramebuffer &&
                                            t.deleteFramebuffer(
                                                r.__webglMultisampledFramebuffer
                                            ),
                                        r.__webglColorRenderbuffer)
                                    )
                                        for (
                                            let e = 0;
                                            e <
                                            r.__webglColorRenderbuffer.length;
                                            e++
                                        )
                                            r.__webglColorRenderbuffer[e] &&
                                                t.deleteRenderbuffer(
                                                    r.__webglColorRenderbuffer[
                                                        e
                                                    ]
                                                );
                                    r.__webglDepthRenderbuffer &&
                                        t.deleteRenderbuffer(
                                            r.__webglDepthRenderbuffer
                                        );
                                }
                                if (e.isWebGLMultipleRenderTargets)
                                    for (let e = 0, r = n.length; e < r; e++) {
                                        const r = i.get(n[e]);
                                        r.__webglTexture &&
                                            (t.deleteTexture(r.__webglTexture),
                                            o.memory.textures--),
                                            i.remove(n[e]);
                                    }
                                i.remove(n), i.remove(e);
                            })(n);
                    }
                    function X(e) {
                        const n = i.get(e);
                        t.deleteTexture(n.__webglTexture);
                        const r = e.source;
                        delete P.get(r)[n.__cacheKey], o.memory.textures--;
                    }
                    let Y = 0;
                    function q(e, r) {
                        const a = i.get(e);
                        if (
                            (e.isVideoTexture &&
                                (function (t) {
                                    const e = o.render.frame;
                                    R.get(t) !== e && (R.set(t, e), t.update());
                                })(e),
                            !1 === e.isRenderTargetTexture &&
                                e.version > 0 &&
                                a.__version !== e.version)
                        ) {
                            const t = e.image;
                            if (null === t)
                                console.warn(
                                    'THREE.WebGLRenderer: Texture marked for update but no image data found.'
                                );
                            else {
                                if (!1 !== t.complete) return void et(a, e, r);
                                console.warn(
                                    'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
                                );
                            }
                        }
                        n.bindTexture(
                            t.TEXTURE_2D,
                            a.__webglTexture,
                            t.TEXTURE0 + r
                        );
                    }
                    const K = {
                            [d]: t.REPEAT,
                            [p]: t.CLAMP_TO_EDGE,
                            [f]: t.MIRRORED_REPEAT,
                        },
                        Q = {
                            [m]: t.NEAREST,
                            1004: t.NEAREST_MIPMAP_NEAREST,
                            [g]: t.NEAREST_MIPMAP_LINEAR,
                            [v]: t.LINEAR,
                            1007: t.LINEAR_MIPMAP_NEAREST,
                            [_]: t.LINEAR_MIPMAP_LINEAR,
                        };
                    function $(n, a, o) {
                        if (
                            (o
                                ? (t.texParameteri(
                                      n,
                                      t.TEXTURE_WRAP_S,
                                      K[a.wrapS]
                                  ),
                                  t.texParameteri(
                                      n,
                                      t.TEXTURE_WRAP_T,
                                      K[a.wrapT]
                                  ),
                                  (n !== t.TEXTURE_3D &&
                                      n !== t.TEXTURE_2D_ARRAY) ||
                                      t.texParameteri(
                                          n,
                                          t.TEXTURE_WRAP_R,
                                          K[a.wrapR]
                                      ),
                                  t.texParameteri(
                                      n,
                                      t.TEXTURE_MAG_FILTER,
                                      Q[a.magFilter]
                                  ),
                                  t.texParameteri(
                                      n,
                                      t.TEXTURE_MIN_FILTER,
                                      Q[a.minFilter]
                                  ))
                                : (t.texParameteri(
                                      n,
                                      t.TEXTURE_WRAP_S,
                                      t.CLAMP_TO_EDGE
                                  ),
                                  t.texParameteri(
                                      n,
                                      t.TEXTURE_WRAP_T,
                                      t.CLAMP_TO_EDGE
                                  ),
                                  (n !== t.TEXTURE_3D &&
                                      n !== t.TEXTURE_2D_ARRAY) ||
                                      t.texParameteri(
                                          n,
                                          t.TEXTURE_WRAP_R,
                                          t.CLAMP_TO_EDGE
                                      ),
                                  (a.wrapS === p && a.wrapT === p) ||
                                      console.warn(
                                          'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
                                      ),
                                  t.texParameteri(
                                      n,
                                      t.TEXTURE_MAG_FILTER,
                                      V(a.magFilter)
                                  ),
                                  t.texParameteri(
                                      n,
                                      t.TEXTURE_MIN_FILTER,
                                      V(a.minFilter)
                                  ),
                                  a.minFilter !== m &&
                                      a.minFilter !== v &&
                                      console.warn(
                                          'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
                                      )),
                            !0 === e.has('EXT_texture_filter_anisotropic'))
                        ) {
                            const o = e.get('EXT_texture_filter_anisotropic');
                            if (a.magFilter === m) return;
                            if (a.minFilter !== g && a.minFilter !== _) return;
                            if (
                                a.type === M &&
                                !1 === e.has('OES_texture_float_linear')
                            )
                                return;
                            if (
                                !1 === s &&
                                a.type === b &&
                                !1 === e.has('OES_texture_half_float_linear')
                            )
                                return;
                            (a.anisotropy > 1 ||
                                i.get(a).__currentAnisotropy) &&
                                (t.texParameterf(
                                    n,
                                    o.TEXTURE_MAX_ANISOTROPY_EXT,
                                    Math.min(a.anisotropy, r.getMaxAnisotropy())
                                ),
                                (i.get(a).__currentAnisotropy = a.anisotropy));
                        }
                    }
                    function tt(e, n) {
                        let i = !1;
                        void 0 === e.__webglInit &&
                            ((e.__webglInit = !0),
                            n.addEventListener('dispose', W));
                        const r = n.source;
                        let a = P.get(r);
                        void 0 === a && ((a = {}), P.set(r, a));
                        const s = (function (t) {
                            const e = [];
                            return (
                                e.push(t.wrapS),
                                e.push(t.wrapT),
                                e.push(t.wrapR || 0),
                                e.push(t.magFilter),
                                e.push(t.minFilter),
                                e.push(t.anisotropy),
                                e.push(t.internalFormat),
                                e.push(t.format),
                                e.push(t.type),
                                e.push(t.generateMipmaps),
                                e.push(t.premultiplyAlpha),
                                e.push(t.flipY),
                                e.push(t.unpackAlignment),
                                e.push(t.colorSpace),
                                e.join()
                            );
                        })(n);
                        if (s !== e.__cacheKey) {
                            void 0 === a[s] &&
                                ((a[s] = {
                                    texture: t.createTexture(),
                                    usedTimes: 0,
                                }),
                                o.memory.textures++,
                                (i = !0)),
                                a[s].usedTimes++;
                            const r = a[e.__cacheKey];
                            void 0 !== r &&
                                (a[e.__cacheKey].usedTimes--,
                                0 === r.usedTimes && X(n)),
                                (e.__cacheKey = s),
                                (e.__webglTexture = a[s].texture);
                        }
                        return i;
                    }
                    function et(e, r, o) {
                        let l = t.TEXTURE_2D;
                        (r.isDataArrayTexture || r.isCompressedArrayTexture) &&
                            (l = t.TEXTURE_2D_ARRAY),
                            r.isData3DTexture && (l = t.TEXTURE_3D);
                        const c = tt(e, r),
                            h = r.source;
                        n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + o);
                        const d = i.get(h);
                        if (h.version !== d.__version || !0 === c) {
                            n.activeTexture(t.TEXTURE0 + o),
                                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                                t.pixelStorei(
                                    t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                                    r.premultiplyAlpha
                                ),
                                t.pixelStorei(
                                    t.UNPACK_ALIGNMENT,
                                    r.unpackAlignment
                                ),
                                t.pixelStorei(
                                    t.UNPACK_COLORSPACE_CONVERSION_WEBGL,
                                    t.NONE
                                );
                            const e =
                                (function (t) {
                                    return (
                                        !s &&
                                        (t.wrapS !== p ||
                                            t.wrapT !== p ||
                                            (t.minFilter !== m &&
                                                t.minFilter !== v))
                                    );
                                })(r) && !1 === O(r.image);
                            let i = U(r.image, e, !1, u);
                            i = lt(r, i);
                            const f = O(i) || s,
                                g = a.convert(r.format, r.colorSpace);
                            let _,
                                x = a.convert(r.type),
                                b = k(r.internalFormat, g, x, r.colorSpace);
                            $(l, r, f);
                            const A = r.mipmaps,
                                C = s && !0 !== r.isVideoTexture,
                                R = void 0 === d.__version || !0 === c,
                                L = H(r, i, f);
                            if (r.isDepthTexture)
                                (b = t.DEPTH_COMPONENT),
                                    s
                                        ? (b =
                                              r.type === M
                                                  ? t.DEPTH_COMPONENT32F
                                                  : r.type === y
                                                    ? t.DEPTH_COMPONENT24
                                                    : r.type === E
                                                      ? t.DEPTH24_STENCIL8
                                                      : t.DEPTH_COMPONENT16)
                                        : r.type === M &&
                                          console.error(
                                              'WebGLRenderer: Floating point depth texture requires WebGL2.'
                                          ),
                                    r.format === T &&
                                        b === t.DEPTH_COMPONENT &&
                                        1012 !== r.type &&
                                        r.type !== y &&
                                        (console.warn(
                                            'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
                                        ),
                                        (r.type = y),
                                        (x = a.convert(r.type))),
                                    r.format === w &&
                                        b === t.DEPTH_COMPONENT &&
                                        ((b = t.DEPTH_STENCIL),
                                        r.type !== E &&
                                            (console.warn(
                                                'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
                                            ),
                                            (r.type = E),
                                            (x = a.convert(r.type)))),
                                    R &&
                                        (C
                                            ? n.texStorage2D(
                                                  t.TEXTURE_2D,
                                                  1,
                                                  b,
                                                  i.width,
                                                  i.height
                                              )
                                            : n.texImage2D(
                                                  t.TEXTURE_2D,
                                                  0,
                                                  b,
                                                  i.width,
                                                  i.height,
                                                  0,
                                                  g,
                                                  x,
                                                  null
                                              ));
                            else if (r.isDataTexture)
                                if (A.length > 0 && f) {
                                    C &&
                                        R &&
                                        n.texStorage2D(
                                            t.TEXTURE_2D,
                                            L,
                                            b,
                                            A[0].width,
                                            A[0].height
                                        );
                                    for (let e = 0, i = A.length; e < i; e++)
                                        (_ = A[e]),
                                            C
                                                ? n.texSubImage2D(
                                                      t.TEXTURE_2D,
                                                      e,
                                                      0,
                                                      0,
                                                      _.width,
                                                      _.height,
                                                      g,
                                                      x,
                                                      _.data
                                                  )
                                                : n.texImage2D(
                                                      t.TEXTURE_2D,
                                                      e,
                                                      b,
                                                      _.width,
                                                      _.height,
                                                      0,
                                                      g,
                                                      x,
                                                      _.data
                                                  );
                                    r.generateMipmaps = !1;
                                } else
                                    C
                                        ? (R &&
                                              n.texStorage2D(
                                                  t.TEXTURE_2D,
                                                  L,
                                                  b,
                                                  i.width,
                                                  i.height
                                              ),
                                          n.texSubImage2D(
                                              t.TEXTURE_2D,
                                              0,
                                              0,
                                              0,
                                              i.width,
                                              i.height,
                                              g,
                                              x,
                                              i.data
                                          ))
                                        : n.texImage2D(
                                              t.TEXTURE_2D,
                                              0,
                                              b,
                                              i.width,
                                              i.height,
                                              0,
                                              g,
                                              x,
                                              i.data
                                          );
                            else if (r.isCompressedTexture)
                                if (r.isCompressedArrayTexture) {
                                    C &&
                                        R &&
                                        n.texStorage3D(
                                            t.TEXTURE_2D_ARRAY,
                                            L,
                                            b,
                                            A[0].width,
                                            A[0].height,
                                            i.depth
                                        );
                                    for (let e = 0, a = A.length; e < a; e++)
                                        (_ = A[e]),
                                            r.format !== S
                                                ? null !== g
                                                    ? C
                                                        ? n.compressedTexSubImage3D(
                                                              t.TEXTURE_2D_ARRAY,
                                                              e,
                                                              0,
                                                              0,
                                                              0,
                                                              _.width,
                                                              _.height,
                                                              i.depth,
                                                              g,
                                                              _.data,
                                                              0,
                                                              0
                                                          )
                                                        : n.compressedTexImage3D(
                                                              t.TEXTURE_2D_ARRAY,
                                                              e,
                                                              b,
                                                              _.width,
                                                              _.height,
                                                              i.depth,
                                                              0,
                                                              _.data,
                                                              0,
                                                              0
                                                          )
                                                    : console.warn(
                                                          'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                                                      )
                                                : C
                                                  ? n.texSubImage3D(
                                                        t.TEXTURE_2D_ARRAY,
                                                        e,
                                                        0,
                                                        0,
                                                        0,
                                                        _.width,
                                                        _.height,
                                                        i.depth,
                                                        g,
                                                        x,
                                                        _.data
                                                    )
                                                  : n.texImage3D(
                                                        t.TEXTURE_2D_ARRAY,
                                                        e,
                                                        b,
                                                        _.width,
                                                        _.height,
                                                        i.depth,
                                                        0,
                                                        g,
                                                        x,
                                                        _.data
                                                    );
                                } else {
                                    C &&
                                        R &&
                                        n.texStorage2D(
                                            t.TEXTURE_2D,
                                            L,
                                            b,
                                            A[0].width,
                                            A[0].height
                                        );
                                    for (let e = 0, i = A.length; e < i; e++)
                                        (_ = A[e]),
                                            r.format !== S
                                                ? null !== g
                                                    ? C
                                                        ? n.compressedTexSubImage2D(
                                                              t.TEXTURE_2D,
                                                              e,
                                                              0,
                                                              0,
                                                              _.width,
                                                              _.height,
                                                              g,
                                                              _.data
                                                          )
                                                        : n.compressedTexImage2D(
                                                              t.TEXTURE_2D,
                                                              e,
                                                              b,
                                                              _.width,
                                                              _.height,
                                                              0,
                                                              _.data
                                                          )
                                                    : console.warn(
                                                          'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                                                      )
                                                : C
                                                  ? n.texSubImage2D(
                                                        t.TEXTURE_2D,
                                                        e,
                                                        0,
                                                        0,
                                                        _.width,
                                                        _.height,
                                                        g,
                                                        x,
                                                        _.data
                                                    )
                                                  : n.texImage2D(
                                                        t.TEXTURE_2D,
                                                        e,
                                                        b,
                                                        _.width,
                                                        _.height,
                                                        0,
                                                        g,
                                                        x,
                                                        _.data
                                                    );
                                }
                            else if (r.isDataArrayTexture)
                                C
                                    ? (R &&
                                          n.texStorage3D(
                                              t.TEXTURE_2D_ARRAY,
                                              L,
                                              b,
                                              i.width,
                                              i.height,
                                              i.depth
                                          ),
                                      n.texSubImage3D(
                                          t.TEXTURE_2D_ARRAY,
                                          0,
                                          0,
                                          0,
                                          0,
                                          i.width,
                                          i.height,
                                          i.depth,
                                          g,
                                          x,
                                          i.data
                                      ))
                                    : n.texImage3D(
                                          t.TEXTURE_2D_ARRAY,
                                          0,
                                          b,
                                          i.width,
                                          i.height,
                                          i.depth,
                                          0,
                                          g,
                                          x,
                                          i.data
                                      );
                            else if (r.isData3DTexture)
                                C
                                    ? (R &&
                                          n.texStorage3D(
                                              t.TEXTURE_3D,
                                              L,
                                              b,
                                              i.width,
                                              i.height,
                                              i.depth
                                          ),
                                      n.texSubImage3D(
                                          t.TEXTURE_3D,
                                          0,
                                          0,
                                          0,
                                          0,
                                          i.width,
                                          i.height,
                                          i.depth,
                                          g,
                                          x,
                                          i.data
                                      ))
                                    : n.texImage3D(
                                          t.TEXTURE_3D,
                                          0,
                                          b,
                                          i.width,
                                          i.height,
                                          i.depth,
                                          0,
                                          g,
                                          x,
                                          i.data
                                      );
                            else if (r.isFramebufferTexture) {
                                if (R)
                                    if (C)
                                        n.texStorage2D(
                                            t.TEXTURE_2D,
                                            L,
                                            b,
                                            i.width,
                                            i.height
                                        );
                                    else {
                                        let e = i.width,
                                            r = i.height;
                                        for (let i = 0; i < L; i++)
                                            n.texImage2D(
                                                t.TEXTURE_2D,
                                                i,
                                                b,
                                                e,
                                                r,
                                                0,
                                                g,
                                                x,
                                                null
                                            ),
                                                (e >>= 1),
                                                (r >>= 1);
                                    }
                            } else if (A.length > 0 && f) {
                                C &&
                                    R &&
                                    n.texStorage2D(
                                        t.TEXTURE_2D,
                                        L,
                                        b,
                                        A[0].width,
                                        A[0].height
                                    );
                                for (let e = 0, i = A.length; e < i; e++)
                                    (_ = A[e]),
                                        C
                                            ? n.texSubImage2D(
                                                  t.TEXTURE_2D,
                                                  e,
                                                  0,
                                                  0,
                                                  g,
                                                  x,
                                                  _
                                              )
                                            : n.texImage2D(
                                                  t.TEXTURE_2D,
                                                  e,
                                                  b,
                                                  g,
                                                  x,
                                                  _
                                              );
                                r.generateMipmaps = !1;
                            } else
                                C
                                    ? (R &&
                                          n.texStorage2D(
                                              t.TEXTURE_2D,
                                              L,
                                              b,
                                              i.width,
                                              i.height
                                          ),
                                      n.texSubImage2D(
                                          t.TEXTURE_2D,
                                          0,
                                          0,
                                          0,
                                          g,
                                          x,
                                          i
                                      ))
                                    : n.texImage2D(t.TEXTURE_2D, 0, b, g, x, i);
                            N(r, f) && B(l),
                                (d.__version = h.version),
                                r.onUpdate && r.onUpdate(r);
                        }
                        e.__version = r.version;
                    }
                    function nt(e, r, o, s, l) {
                        const c = a.convert(o.format, o.colorSpace),
                            u = a.convert(o.type),
                            h = k(o.internalFormat, c, u, o.colorSpace);
                        i.get(r).__hasExternalTextures ||
                            (l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY
                                ? n.texImage3D(
                                      l,
                                      0,
                                      h,
                                      r.width,
                                      r.height,
                                      r.depth,
                                      0,
                                      c,
                                      u,
                                      null
                                  )
                                : n.texImage2D(
                                      l,
                                      0,
                                      h,
                                      r.width,
                                      r.height,
                                      0,
                                      c,
                                      u,
                                      null
                                  )),
                            n.bindFramebuffer(t.FRAMEBUFFER, e),
                            st(r)
                                ? A.framebufferTexture2DMultisampleEXT(
                                      t.FRAMEBUFFER,
                                      s,
                                      l,
                                      i.get(o).__webglTexture,
                                      0,
                                      ot(r)
                                  )
                                : (l === t.TEXTURE_2D ||
                                      (l >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
                                          l <=
                                              t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                                  t.framebufferTexture2D(
                                      t.FRAMEBUFFER,
                                      s,
                                      l,
                                      i.get(o).__webglTexture,
                                      0
                                  ),
                            n.bindFramebuffer(t.FRAMEBUFFER, null);
                    }
                    function it(e, n, i) {
                        if (
                            (t.bindRenderbuffer(t.RENDERBUFFER, e),
                            n.depthBuffer && !n.stencilBuffer)
                        ) {
                            let r = t.DEPTH_COMPONENT16;
                            if (i || st(n)) {
                                const e = n.depthTexture;
                                e &&
                                    e.isDepthTexture &&
                                    (e.type === M
                                        ? (r = t.DEPTH_COMPONENT32F)
                                        : e.type === y &&
                                          (r = t.DEPTH_COMPONENT24));
                                const i = ot(n);
                                st(n)
                                    ? A.renderbufferStorageMultisampleEXT(
                                          t.RENDERBUFFER,
                                          i,
                                          r,
                                          n.width,
                                          n.height
                                      )
                                    : t.renderbufferStorageMultisample(
                                          t.RENDERBUFFER,
                                          i,
                                          r,
                                          n.width,
                                          n.height
                                      );
                            } else
                                t.renderbufferStorage(
                                    t.RENDERBUFFER,
                                    r,
                                    n.width,
                                    n.height
                                );
                            t.framebufferRenderbuffer(
                                t.FRAMEBUFFER,
                                t.DEPTH_ATTACHMENT,
                                t.RENDERBUFFER,
                                e
                            );
                        } else if (n.depthBuffer && n.stencilBuffer) {
                            const r = ot(n);
                            i && !1 === st(n)
                                ? t.renderbufferStorageMultisample(
                                      t.RENDERBUFFER,
                                      r,
                                      t.DEPTH24_STENCIL8,
                                      n.width,
                                      n.height
                                  )
                                : st(n)
                                  ? A.renderbufferStorageMultisampleEXT(
                                        t.RENDERBUFFER,
                                        r,
                                        t.DEPTH24_STENCIL8,
                                        n.width,
                                        n.height
                                    )
                                  : t.renderbufferStorage(
                                        t.RENDERBUFFER,
                                        t.DEPTH_STENCIL,
                                        n.width,
                                        n.height
                                    ),
                                t.framebufferRenderbuffer(
                                    t.FRAMEBUFFER,
                                    t.DEPTH_STENCIL_ATTACHMENT,
                                    t.RENDERBUFFER,
                                    e
                                );
                        } else {
                            const e =
                                !0 === n.isWebGLMultipleRenderTargets
                                    ? n.texture
                                    : [n.texture];
                            for (let r = 0; r < e.length; r++) {
                                const o = e[r],
                                    s = a.convert(o.format, o.colorSpace),
                                    l = a.convert(o.type),
                                    c = k(o.internalFormat, s, l, o.colorSpace),
                                    u = ot(n);
                                i && !1 === st(n)
                                    ? t.renderbufferStorageMultisample(
                                          t.RENDERBUFFER,
                                          u,
                                          c,
                                          n.width,
                                          n.height
                                      )
                                    : st(n)
                                      ? A.renderbufferStorageMultisampleEXT(
                                            t.RENDERBUFFER,
                                            u,
                                            c,
                                            n.width,
                                            n.height
                                        )
                                      : t.renderbufferStorage(
                                            t.RENDERBUFFER,
                                            c,
                                            n.width,
                                            n.height
                                        );
                            }
                        }
                        t.bindRenderbuffer(t.RENDERBUFFER, null);
                    }
                    function at(e) {
                        const r = i.get(e),
                            a = !0 === e.isWebGLCubeRenderTarget;
                        if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                            if (a)
                                throw new Error(
                                    'target.depthTexture not supported in Cube render targets'
                                );
                            !(function (e, r) {
                                if (r && r.isWebGLCubeRenderTarget)
                                    throw new Error(
                                        'Depth Texture with cube render targets is not supported'
                                    );
                                if (
                                    (n.bindFramebuffer(t.FRAMEBUFFER, e),
                                    !r.depthTexture ||
                                        !r.depthTexture.isDepthTexture)
                                )
                                    throw new Error(
                                        'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
                                    );
                                (i.get(r.depthTexture).__webglTexture &&
                                    r.depthTexture.image.width === r.width &&
                                    r.depthTexture.image.height === r.height) ||
                                    ((r.depthTexture.image.width = r.width),
                                    (r.depthTexture.image.height = r.height),
                                    (r.depthTexture.needsUpdate = !0)),
                                    q(r.depthTexture, 0);
                                const a = i.get(r.depthTexture).__webglTexture,
                                    o = ot(r);
                                if (r.depthTexture.format === T)
                                    st(r)
                                        ? A.framebufferTexture2DMultisampleEXT(
                                              t.FRAMEBUFFER,
                                              t.DEPTH_ATTACHMENT,
                                              t.TEXTURE_2D,
                                              a,
                                              0,
                                              o
                                          )
                                        : t.framebufferTexture2D(
                                              t.FRAMEBUFFER,
                                              t.DEPTH_ATTACHMENT,
                                              t.TEXTURE_2D,
                                              a,
                                              0
                                          );
                                else {
                                    if (r.depthTexture.format !== w)
                                        throw new Error(
                                            'Unknown depthTexture format'
                                        );
                                    st(r)
                                        ? A.framebufferTexture2DMultisampleEXT(
                                              t.FRAMEBUFFER,
                                              t.DEPTH_STENCIL_ATTACHMENT,
                                              t.TEXTURE_2D,
                                              a,
                                              0,
                                              o
                                          )
                                        : t.framebufferTexture2D(
                                              t.FRAMEBUFFER,
                                              t.DEPTH_STENCIL_ATTACHMENT,
                                              t.TEXTURE_2D,
                                              a,
                                              0
                                          );
                                }
                            })(r.__webglFramebuffer, e);
                        } else if (a) {
                            r.__webglDepthbuffer = [];
                            for (let i = 0; i < 6; i++)
                                n.bindFramebuffer(
                                    t.FRAMEBUFFER,
                                    r.__webglFramebuffer[i]
                                ),
                                    (r.__webglDepthbuffer[i] =
                                        t.createRenderbuffer()),
                                    it(r.__webglDepthbuffer[i], e, !1);
                        } else
                            n.bindFramebuffer(
                                t.FRAMEBUFFER,
                                r.__webglFramebuffer
                            ),
                                (r.__webglDepthbuffer = t.createRenderbuffer()),
                                it(r.__webglDepthbuffer, e, !1);
                        n.bindFramebuffer(t.FRAMEBUFFER, null);
                    }
                    function ot(t) {
                        return Math.min(h, t.samples);
                    }
                    function st(t) {
                        const n = i.get(t);
                        return (
                            s &&
                            t.samples > 0 &&
                            !0 ===
                                e.has('WEBGL_multisampled_render_to_texture') &&
                            !1 !== n.__useRenderToTexture
                        );
                    }
                    function lt(t, n) {
                        const i = t.colorSpace,
                            r = t.format,
                            a = t.type;
                        return (
                            !0 === t.isCompressedTexture ||
                                t.format === G ||
                                (i !== z &&
                                    '' !== i &&
                                    (i === F
                                        ? !1 === s
                                            ? !0 === e.has('EXT_sRGB') &&
                                              r === S
                                                ? ((t.format = G),
                                                  (t.minFilter = v),
                                                  (t.generateMipmaps = !1))
                                                : (n = mt.sRGBToLinear(n))
                                            : (r === S && a === x) ||
                                              console.warn(
                                                  'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
                                              )
                                        : console.error(
                                              'THREE.WebGLTextures: Unsupported texture color space:',
                                              i
                                          ))),
                            n
                        );
                    }
                    (this.allocateTextureUnit = function () {
                        const t = Y;
                        return (
                            t >= l &&
                                console.warn(
                                    'THREE.WebGLTextures: Trying to use ' +
                                        t +
                                        ' texture units while this GPU supports only ' +
                                        l
                                ),
                            (Y += 1),
                            t
                        );
                    }),
                        (this.resetTextureUnits = function () {
                            Y = 0;
                        }),
                        (this.setTexture2D = q),
                        (this.setTexture2DArray = function (e, r) {
                            const a = i.get(e);
                            e.version > 0 && a.__version !== e.version
                                ? et(a, e, r)
                                : n.bindTexture(
                                      t.TEXTURE_2D_ARRAY,
                                      a.__webglTexture,
                                      t.TEXTURE0 + r
                                  );
                        }),
                        (this.setTexture3D = function (e, r) {
                            const a = i.get(e);
                            e.version > 0 && a.__version !== e.version
                                ? et(a, e, r)
                                : n.bindTexture(
                                      t.TEXTURE_3D,
                                      a.__webglTexture,
                                      t.TEXTURE0 + r
                                  );
                        }),
                        (this.setTextureCube = function (e, r) {
                            const o = i.get(e);
                            e.version > 0 && o.__version !== e.version
                                ? (function (e, r, o) {
                                      if (6 !== r.image.length) return;
                                      const l = tt(e, r),
                                          u = r.source;
                                      n.bindTexture(
                                          t.TEXTURE_CUBE_MAP,
                                          e.__webglTexture,
                                          t.TEXTURE0 + o
                                      );
                                      const h = i.get(u);
                                      if (
                                          u.version !== h.__version ||
                                          !0 === l
                                      ) {
                                          n.activeTexture(t.TEXTURE0 + o),
                                              t.pixelStorei(
                                                  t.UNPACK_FLIP_Y_WEBGL,
                                                  r.flipY
                                              ),
                                              t.pixelStorei(
                                                  t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                                                  r.premultiplyAlpha
                                              ),
                                              t.pixelStorei(
                                                  t.UNPACK_ALIGNMENT,
                                                  r.unpackAlignment
                                              ),
                                              t.pixelStorei(
                                                  t.UNPACK_COLORSPACE_CONVERSION_WEBGL,
                                                  t.NONE
                                              );
                                          const e =
                                                  r.isCompressedTexture ||
                                                  r.image[0]
                                                      .isCompressedTexture,
                                              i =
                                                  r.image[0] &&
                                                  r.image[0].isDataTexture,
                                              d = [];
                                          for (let t = 0; t < 6; t++)
                                              (d[t] =
                                                  e || i
                                                      ? i
                                                          ? r.image[t].image
                                                          : r.image[t]
                                                      : U(
                                                            r.image[t],
                                                            !1,
                                                            !0,
                                                            c
                                                        )),
                                                  (d[t] = lt(r, d[t]));
                                          const p = d[0],
                                              f = O(p) || s,
                                              m = a.convert(
                                                  r.format,
                                                  r.colorSpace
                                              ),
                                              g = a.convert(r.type),
                                              v = k(
                                                  r.internalFormat,
                                                  m,
                                                  g,
                                                  r.colorSpace
                                              ),
                                              _ = s && !0 !== r.isVideoTexture,
                                              x =
                                                  void 0 === h.__version ||
                                                  !0 === l;
                                          let y,
                                              M = H(r, p, f);
                                          if (
                                              ($(t.TEXTURE_CUBE_MAP, r, f), e)
                                          ) {
                                              _ &&
                                                  x &&
                                                  n.texStorage2D(
                                                      t.TEXTURE_CUBE_MAP,
                                                      M,
                                                      v,
                                                      p.width,
                                                      p.height
                                                  );
                                              for (let e = 0; e < 6; e++) {
                                                  y = d[e].mipmaps;
                                                  for (
                                                      let i = 0;
                                                      i < y.length;
                                                      i++
                                                  ) {
                                                      const a = y[i];
                                                      r.format !== S
                                                          ? null !== m
                                                              ? _
                                                                  ? n.compressedTexSubImage2D(
                                                                        t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                            e,
                                                                        i,
                                                                        0,
                                                                        0,
                                                                        a.width,
                                                                        a.height,
                                                                        m,
                                                                        a.data
                                                                    )
                                                                  : n.compressedTexImage2D(
                                                                        t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                            e,
                                                                        i,
                                                                        v,
                                                                        a.width,
                                                                        a.height,
                                                                        0,
                                                                        a.data
                                                                    )
                                                              : console.warn(
                                                                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                                                                )
                                                          : _
                                                            ? n.texSubImage2D(
                                                                  t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                      e,
                                                                  i,
                                                                  0,
                                                                  0,
                                                                  a.width,
                                                                  a.height,
                                                                  m,
                                                                  g,
                                                                  a.data
                                                              )
                                                            : n.texImage2D(
                                                                  t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                      e,
                                                                  i,
                                                                  v,
                                                                  a.width,
                                                                  a.height,
                                                                  0,
                                                                  m,
                                                                  g,
                                                                  a.data
                                                              );
                                                  }
                                              }
                                          } else {
                                              (y = r.mipmaps),
                                                  _ &&
                                                      x &&
                                                      (y.length > 0 && M++,
                                                      n.texStorage2D(
                                                          t.TEXTURE_CUBE_MAP,
                                                          M,
                                                          v,
                                                          d[0].width,
                                                          d[0].height
                                                      ));
                                              for (let e = 0; e < 6; e++)
                                                  if (i) {
                                                      _
                                                          ? n.texSubImage2D(
                                                                t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                    e,
                                                                0,
                                                                0,
                                                                0,
                                                                d[e].width,
                                                                d[e].height,
                                                                m,
                                                                g,
                                                                d[e].data
                                                            )
                                                          : n.texImage2D(
                                                                t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                    e,
                                                                0,
                                                                v,
                                                                d[e].width,
                                                                d[e].height,
                                                                0,
                                                                m,
                                                                g,
                                                                d[e].data
                                                            );
                                                      for (
                                                          let i = 0;
                                                          i < y.length;
                                                          i++
                                                      ) {
                                                          const r =
                                                              y[i].image[e]
                                                                  .image;
                                                          _
                                                              ? n.texSubImage2D(
                                                                    t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                        e,
                                                                    i + 1,
                                                                    0,
                                                                    0,
                                                                    r.width,
                                                                    r.height,
                                                                    m,
                                                                    g,
                                                                    r.data
                                                                )
                                                              : n.texImage2D(
                                                                    t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                        e,
                                                                    i + 1,
                                                                    v,
                                                                    r.width,
                                                                    r.height,
                                                                    0,
                                                                    m,
                                                                    g,
                                                                    r.data
                                                                );
                                                      }
                                                  } else {
                                                      _
                                                          ? n.texSubImage2D(
                                                                t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                    e,
                                                                0,
                                                                0,
                                                                0,
                                                                m,
                                                                g,
                                                                d[e]
                                                            )
                                                          : n.texImage2D(
                                                                t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                    e,
                                                                0,
                                                                v,
                                                                m,
                                                                g,
                                                                d[e]
                                                            );
                                                      for (
                                                          let i = 0;
                                                          i < y.length;
                                                          i++
                                                      ) {
                                                          const r = y[i];
                                                          _
                                                              ? n.texSubImage2D(
                                                                    t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                        e,
                                                                    i + 1,
                                                                    0,
                                                                    0,
                                                                    m,
                                                                    g,
                                                                    r.image[e]
                                                                )
                                                              : n.texImage2D(
                                                                    t.TEXTURE_CUBE_MAP_POSITIVE_X +
                                                                        e,
                                                                    i + 1,
                                                                    v,
                                                                    m,
                                                                    g,
                                                                    r.image[e]
                                                                );
                                                      }
                                                  }
                                          }
                                          N(r, f) && B(t.TEXTURE_CUBE_MAP),
                                              (h.__version = u.version),
                                              r.onUpdate && r.onUpdate(r);
                                      }
                                      e.__version = r.version;
                                  })(o, e, r)
                                : n.bindTexture(
                                      t.TEXTURE_CUBE_MAP,
                                      o.__webglTexture,
                                      t.TEXTURE0 + r
                                  );
                        }),
                        (this.rebindTextures = function (e, n, r) {
                            const a = i.get(e);
                            void 0 !== n &&
                                nt(
                                    a.__webglFramebuffer,
                                    e,
                                    e.texture,
                                    t.COLOR_ATTACHMENT0,
                                    t.TEXTURE_2D
                                ),
                                void 0 !== r && at(e);
                        }),
                        (this.setupRenderTarget = function (e) {
                            const l = e.texture,
                                c = i.get(e),
                                u = i.get(l);
                            e.addEventListener('dispose', j),
                                !0 !== e.isWebGLMultipleRenderTargets &&
                                    (void 0 === u.__webglTexture &&
                                        (u.__webglTexture = t.createTexture()),
                                    (u.__version = l.version),
                                    o.memory.textures++);
                            const h = !0 === e.isWebGLCubeRenderTarget,
                                d = !0 === e.isWebGLMultipleRenderTargets,
                                p = O(e) || s;
                            if (h) {
                                c.__webglFramebuffer = [];
                                for (let e = 0; e < 6; e++)
                                    c.__webglFramebuffer[e] =
                                        t.createFramebuffer();
                            } else {
                                if (
                                    ((c.__webglFramebuffer =
                                        t.createFramebuffer()),
                                    d)
                                )
                                    if (r.drawBuffers) {
                                        const n = e.texture;
                                        for (
                                            let e = 0, r = n.length;
                                            e < r;
                                            e++
                                        ) {
                                            const r = i.get(n[e]);
                                            void 0 === r.__webglTexture &&
                                                ((r.__webglTexture =
                                                    t.createTexture()),
                                                o.memory.textures++);
                                        }
                                    } else
                                        console.warn(
                                            'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.'
                                        );
                                if (s && e.samples > 0 && !1 === st(e)) {
                                    const i = d ? l : [l];
                                    (c.__webglMultisampledFramebuffer =
                                        t.createFramebuffer()),
                                        (c.__webglColorRenderbuffer = []),
                                        n.bindFramebuffer(
                                            t.FRAMEBUFFER,
                                            c.__webglMultisampledFramebuffer
                                        );
                                    for (let n = 0; n < i.length; n++) {
                                        const r = i[n];
                                        (c.__webglColorRenderbuffer[n] =
                                            t.createRenderbuffer()),
                                            t.bindRenderbuffer(
                                                t.RENDERBUFFER,
                                                c.__webglColorRenderbuffer[n]
                                            );
                                        const o = a.convert(
                                                r.format,
                                                r.colorSpace
                                            ),
                                            s = a.convert(r.type),
                                            l = k(
                                                r.internalFormat,
                                                o,
                                                s,
                                                r.colorSpace,
                                                !0 === e.isXRRenderTarget
                                            ),
                                            u = ot(e);
                                        t.renderbufferStorageMultisample(
                                            t.RENDERBUFFER,
                                            u,
                                            l,
                                            e.width,
                                            e.height
                                        ),
                                            t.framebufferRenderbuffer(
                                                t.FRAMEBUFFER,
                                                t.COLOR_ATTACHMENT0 + n,
                                                t.RENDERBUFFER,
                                                c.__webglColorRenderbuffer[n]
                                            );
                                    }
                                    t.bindRenderbuffer(t.RENDERBUFFER, null),
                                        e.depthBuffer &&
                                            ((c.__webglDepthRenderbuffer =
                                                t.createRenderbuffer()),
                                            it(
                                                c.__webglDepthRenderbuffer,
                                                e,
                                                !0
                                            )),
                                        n.bindFramebuffer(t.FRAMEBUFFER, null);
                                }
                            }
                            if (h) {
                                n.bindTexture(
                                    t.TEXTURE_CUBE_MAP,
                                    u.__webglTexture
                                ),
                                    $(t.TEXTURE_CUBE_MAP, l, p);
                                for (let n = 0; n < 6; n++)
                                    nt(
                                        c.__webglFramebuffer[n],
                                        e,
                                        l,
                                        t.COLOR_ATTACHMENT0,
                                        t.TEXTURE_CUBE_MAP_POSITIVE_X + n
                                    );
                                N(l, p) && B(t.TEXTURE_CUBE_MAP),
                                    n.unbindTexture();
                            } else if (d) {
                                const r = e.texture;
                                for (let a = 0, o = r.length; a < o; a++) {
                                    const o = r[a],
                                        s = i.get(o);
                                    n.bindTexture(
                                        t.TEXTURE_2D,
                                        s.__webglTexture
                                    ),
                                        $(t.TEXTURE_2D, o, p),
                                        nt(
                                            c.__webglFramebuffer,
                                            e,
                                            o,
                                            t.COLOR_ATTACHMENT0 + a,
                                            t.TEXTURE_2D
                                        ),
                                        N(o, p) && B(t.TEXTURE_2D);
                                }
                                n.unbindTexture();
                            } else {
                                let i = t.TEXTURE_2D;
                                (e.isWebGL3DRenderTarget ||
                                    e.isWebGLArrayRenderTarget) &&
                                    (s
                                        ? (i = e.isWebGL3DRenderTarget
                                              ? t.TEXTURE_3D
                                              : t.TEXTURE_2D_ARRAY)
                                        : console.error(
                                              'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.'
                                          )),
                                    n.bindTexture(i, u.__webglTexture),
                                    $(i, l, p),
                                    nt(
                                        c.__webglFramebuffer,
                                        e,
                                        l,
                                        t.COLOR_ATTACHMENT0,
                                        i
                                    ),
                                    N(l, p) && B(i),
                                    n.unbindTexture();
                            }
                            e.depthBuffer && at(e);
                        }),
                        (this.updateRenderTargetMipmap = function (e) {
                            const r = O(e) || s,
                                a =
                                    !0 === e.isWebGLMultipleRenderTargets
                                        ? e.texture
                                        : [e.texture];
                            for (let o = 0, s = a.length; o < s; o++) {
                                const s = a[o];
                                if (N(s, r)) {
                                    const r = e.isWebGLCubeRenderTarget
                                            ? t.TEXTURE_CUBE_MAP
                                            : t.TEXTURE_2D,
                                        a = i.get(s).__webglTexture;
                                    n.bindTexture(r, a),
                                        B(r),
                                        n.unbindTexture();
                                }
                            }
                        }),
                        (this.updateMultisampleRenderTarget = function (e) {
                            if (s && e.samples > 0 && !1 === st(e)) {
                                const r = e.isWebGLMultipleRenderTargets
                                        ? e.texture
                                        : [e.texture],
                                    a = e.width,
                                    o = e.height;
                                let s = t.COLOR_BUFFER_BIT;
                                const l = [],
                                    c = e.stencilBuffer
                                        ? t.DEPTH_STENCIL_ATTACHMENT
                                        : t.DEPTH_ATTACHMENT,
                                    u = i.get(e),
                                    h = !0 === e.isWebGLMultipleRenderTargets;
                                if (h)
                                    for (let e = 0; e < r.length; e++)
                                        n.bindFramebuffer(
                                            t.FRAMEBUFFER,
                                            u.__webglMultisampledFramebuffer
                                        ),
                                            t.framebufferRenderbuffer(
                                                t.FRAMEBUFFER,
                                                t.COLOR_ATTACHMENT0 + e,
                                                t.RENDERBUFFER,
                                                null
                                            ),
                                            n.bindFramebuffer(
                                                t.FRAMEBUFFER,
                                                u.__webglFramebuffer
                                            ),
                                            t.framebufferTexture2D(
                                                t.DRAW_FRAMEBUFFER,
                                                t.COLOR_ATTACHMENT0 + e,
                                                t.TEXTURE_2D,
                                                null,
                                                0
                                            );
                                n.bindFramebuffer(
                                    t.READ_FRAMEBUFFER,
                                    u.__webglMultisampledFramebuffer
                                ),
                                    n.bindFramebuffer(
                                        t.DRAW_FRAMEBUFFER,
                                        u.__webglFramebuffer
                                    );
                                for (let n = 0; n < r.length; n++) {
                                    l.push(t.COLOR_ATTACHMENT0 + n),
                                        e.depthBuffer && l.push(c);
                                    const d =
                                        void 0 !== u.__ignoreDepthValues &&
                                        u.__ignoreDepthValues;
                                    if (
                                        (!1 === d &&
                                            (e.depthBuffer &&
                                                (s |= t.DEPTH_BUFFER_BIT),
                                            e.stencilBuffer &&
                                                (s |= t.STENCIL_BUFFER_BIT)),
                                        h &&
                                            t.framebufferRenderbuffer(
                                                t.READ_FRAMEBUFFER,
                                                t.COLOR_ATTACHMENT0,
                                                t.RENDERBUFFER,
                                                u.__webglColorRenderbuffer[n]
                                            ),
                                        !0 === d &&
                                            (t.invalidateFramebuffer(
                                                t.READ_FRAMEBUFFER,
                                                [c]
                                            ),
                                            t.invalidateFramebuffer(
                                                t.DRAW_FRAMEBUFFER,
                                                [c]
                                            )),
                                        h)
                                    ) {
                                        const e = i.get(r[n]).__webglTexture;
                                        t.framebufferTexture2D(
                                            t.DRAW_FRAMEBUFFER,
                                            t.COLOR_ATTACHMENT0,
                                            t.TEXTURE_2D,
                                            e,
                                            0
                                        );
                                    }
                                    t.blitFramebuffer(
                                        0,
                                        0,
                                        a,
                                        o,
                                        0,
                                        0,
                                        a,
                                        o,
                                        s,
                                        t.NEAREST
                                    ),
                                        C &&
                                            t.invalidateFramebuffer(
                                                t.READ_FRAMEBUFFER,
                                                l
                                            );
                                }
                                if (
                                    (n.bindFramebuffer(
                                        t.READ_FRAMEBUFFER,
                                        null
                                    ),
                                    n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                                    h)
                                )
                                    for (let e = 0; e < r.length; e++) {
                                        n.bindFramebuffer(
                                            t.FRAMEBUFFER,
                                            u.__webglMultisampledFramebuffer
                                        ),
                                            t.framebufferRenderbuffer(
                                                t.FRAMEBUFFER,
                                                t.COLOR_ATTACHMENT0 + e,
                                                t.RENDERBUFFER,
                                                u.__webglColorRenderbuffer[e]
                                            );
                                        const a = i.get(r[e]).__webglTexture;
                                        n.bindFramebuffer(
                                            t.FRAMEBUFFER,
                                            u.__webglFramebuffer
                                        ),
                                            t.framebufferTexture2D(
                                                t.DRAW_FRAMEBUFFER,
                                                t.COLOR_ATTACHMENT0 + e,
                                                t.TEXTURE_2D,
                                                a,
                                                0
                                            );
                                    }
                                n.bindFramebuffer(
                                    t.DRAW_FRAMEBUFFER,
                                    u.__webglMultisampledFramebuffer
                                );
                            }
                        }),
                        (this.setupDepthRenderbuffer = at),
                        (this.setupFrameBufferTexture = nt),
                        (this.useMultisampledRTT = st);
                }
                function fa(t, e, n) {
                    const i = n.isWebGL2;
                    return {
                        convert: function (n, r = '') {
                            let a;
                            if (n === x) return t.UNSIGNED_BYTE;
                            if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
                            if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
                            if (1010 === n) return t.BYTE;
                            if (1011 === n) return t.SHORT;
                            if (1012 === n) return t.UNSIGNED_SHORT;
                            if (1013 === n) return t.INT;
                            if (n === y) return t.UNSIGNED_INT;
                            if (n === M) return t.FLOAT;
                            if (n === b)
                                return i
                                    ? t.HALF_FLOAT
                                    : ((a = e.get('OES_texture_half_float')),
                                      null !== a ? a.HALF_FLOAT_OES : null);
                            if (1021 === n) return t.ALPHA;
                            if (n === S) return t.RGBA;
                            if (1024 === n) return t.LUMINANCE;
                            if (1025 === n) return t.LUMINANCE_ALPHA;
                            if (n === T) return t.DEPTH_COMPONENT;
                            if (n === w) return t.DEPTH_STENCIL;
                            if (n === G)
                                return (
                                    (a = e.get('EXT_sRGB')),
                                    null !== a ? a.SRGB_ALPHA_EXT : null
                                );
                            if (n === A) return t.RED;
                            if (1029 === n) return t.RED_INTEGER;
                            if (1030 === n) return t.RG;
                            if (1031 === n) return t.RG_INTEGER;
                            if (1033 === n) return t.RGBA_INTEGER;
                            if (n === C || n === R || n === L || n === P)
                                if (r === F) {
                                    if (
                                        ((a = e.get(
                                            'WEBGL_compressed_texture_s3tc_srgb'
                                        )),
                                        null === a)
                                    )
                                        return null;
                                    if (n === C)
                                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                    if (n === R)
                                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                    if (n === L)
                                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                    if (n === P)
                                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                                } else {
                                    if (
                                        ((a = e.get(
                                            'WEBGL_compressed_texture_s3tc'
                                        )),
                                        null === a)
                                    )
                                        return null;
                                    if (n === C)
                                        return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                    if (n === R)
                                        return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                    if (n === L)
                                        return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                    if (n === P)
                                        return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                                }
                            if (
                                35840 === n ||
                                35841 === n ||
                                35842 === n ||
                                35843 === n
                            ) {
                                if (
                                    ((a = e.get(
                                        'WEBGL_compressed_texture_pvrtc'
                                    )),
                                    null === a)
                                )
                                    return null;
                                if (35840 === n)
                                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (35841 === n)
                                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (35842 === n)
                                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (35843 === n)
                                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                            }
                            if (36196 === n)
                                return (
                                    (a = e.get(
                                        'WEBGL_compressed_texture_etc1'
                                    )),
                                    null !== a
                                        ? a.COMPRESSED_RGB_ETC1_WEBGL
                                        : null
                                );
                            if (37492 === n || 37496 === n) {
                                if (
                                    ((a = e.get(
                                        'WEBGL_compressed_texture_etc'
                                    )),
                                    null === a)
                                )
                                    return null;
                                if (37492 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ETC2
                                        : a.COMPRESSED_RGB8_ETC2;
                                if (37496 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                                        : a.COMPRESSED_RGBA8_ETC2_EAC;
                            }
                            if (
                                37808 === n ||
                                37809 === n ||
                                37810 === n ||
                                37811 === n ||
                                37812 === n ||
                                37813 === n ||
                                37814 === n ||
                                37815 === n ||
                                37816 === n ||
                                37817 === n ||
                                37818 === n ||
                                37819 === n ||
                                37820 === n ||
                                37821 === n
                            ) {
                                if (
                                    ((a = e.get(
                                        'WEBGL_compressed_texture_astc'
                                    )),
                                    null === a)
                                )
                                    return null;
                                if (37808 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                                        : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (37809 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                                        : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (37810 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                                        : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (37811 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                                        : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (37812 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                                        : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (37813 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                                        : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (37814 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                                        : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (37815 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                                        : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (37816 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                                        : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (37817 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                                        : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (37818 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                                        : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (37819 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                                        : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (37820 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                                        : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (37821 === n)
                                    return r === F
                                        ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                                        : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
                            }
                            if (n === D) {
                                if (
                                    ((a = e.get(
                                        'EXT_texture_compression_bptc'
                                    )),
                                    null === a)
                                )
                                    return null;
                                if (n === D)
                                    return r === F
                                        ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                                        : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                            }
                            if (
                                36283 === n ||
                                36284 === n ||
                                36285 === n ||
                                36286 === n
                            ) {
                                if (
                                    ((a = e.get(
                                        'EXT_texture_compression_rgtc'
                                    )),
                                    null === a)
                                )
                                    return null;
                                if (n === D) return a.COMPRESSED_RED_RGTC1_EXT;
                                if (36284 === n)
                                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                if (36285 === n)
                                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                if (36286 === n)
                                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
                            }
                            return n === E
                                ? i
                                    ? t.UNSIGNED_INT_24_8
                                    : ((a = e.get('WEBGL_depth_texture')),
                                      null !== a
                                          ? a.UNSIGNED_INT_24_8_WEBGL
                                          : null)
                                : void 0 !== t[n]
                                  ? t[n]
                                  : null;
                        },
                    };
                }
                class ma extends On {
                    constructor(t = []) {
                        super(), (this.isArrayCamera = !0), (this.cameras = t);
                    }
                }
                class ga extends we {
                    constructor() {
                        super(), (this.isGroup = !0), (this.type = 'Group');
                    }
                }
                const va = { type: 'move' };
                class _a {
                    constructor() {
                        (this._targetRay = null),
                            (this._grip = null),
                            (this._hand = null);
                    }
                    getHandSpace() {
                        return (
                            null === this._hand &&
                                ((this._hand = new ga()),
                                (this._hand.matrixAutoUpdate = !1),
                                (this._hand.visible = !1),
                                (this._hand.joints = {}),
                                (this._hand.inputState = { pinching: !1 })),
                            this._hand
                        );
                    }
                    getTargetRaySpace() {
                        return (
                            null === this._targetRay &&
                                ((this._targetRay = new ga()),
                                (this._targetRay.matrixAutoUpdate = !1),
                                (this._targetRay.visible = !1),
                                (this._targetRay.hasLinearVelocity = !1),
                                (this._targetRay.linearVelocity = new Tt()),
                                (this._targetRay.hasAngularVelocity = !1),
                                (this._targetRay.angularVelocity = new Tt())),
                            this._targetRay
                        );
                    }
                    getGripSpace() {
                        return (
                            null === this._grip &&
                                ((this._grip = new ga()),
                                (this._grip.matrixAutoUpdate = !1),
                                (this._grip.visible = !1),
                                (this._grip.hasLinearVelocity = !1),
                                (this._grip.linearVelocity = new Tt()),
                                (this._grip.hasAngularVelocity = !1),
                                (this._grip.angularVelocity = new Tt())),
                            this._grip
                        );
                    }
                    dispatchEvent(t) {
                        return (
                            null !== this._targetRay &&
                                this._targetRay.dispatchEvent(t),
                            null !== this._grip && this._grip.dispatchEvent(t),
                            null !== this._hand && this._hand.dispatchEvent(t),
                            this
                        );
                    }
                    connect(t) {
                        if (t && t.hand) {
                            const e = this._hand;
                            if (e)
                                for (const n of t.hand.values())
                                    this._getHandJoint(e, n);
                        }
                        return (
                            this.dispatchEvent({ type: 'connected', data: t }),
                            this
                        );
                    }
                    disconnect(t) {
                        return (
                            this.dispatchEvent({
                                type: 'disconnected',
                                data: t,
                            }),
                            null !== this._targetRay &&
                                (this._targetRay.visible = !1),
                            null !== this._grip && (this._grip.visible = !1),
                            null !== this._hand && (this._hand.visible = !1),
                            this
                        );
                    }
                    update(t, e, n) {
                        let i = null,
                            r = null,
                            a = null;
                        const o = this._targetRay,
                            s = this._grip,
                            l = this._hand;
                        if (
                            t &&
                            'visible-blurred' !== e.session.visibilityState
                        ) {
                            if (l && t.hand) {
                                a = !0;
                                for (const i of t.hand.values()) {
                                    const t = e.getJointPose(i, n),
                                        r = this._getHandJoint(l, i);
                                    null !== t &&
                                        (r.matrix.fromArray(t.transform.matrix),
                                        r.matrix.decompose(
                                            r.position,
                                            r.rotation,
                                            r.scale
                                        ),
                                        (r.matrixWorldNeedsUpdate = !0),
                                        (r.jointRadius = t.radius)),
                                        (r.visible = null !== t);
                                }
                                const i = l.joints['index-finger-tip'],
                                    r = l.joints['thumb-tip'],
                                    o = i.position.distanceTo(r.position),
                                    s = 0.02,
                                    c = 0.005;
                                l.inputState.pinching && o > s + c
                                    ? ((l.inputState.pinching = !1),
                                      this.dispatchEvent({
                                          type: 'pinchend',
                                          handedness: t.handedness,
                                          target: this,
                                      }))
                                    : !l.inputState.pinching &&
                                      o <= s - c &&
                                      ((l.inputState.pinching = !0),
                                      this.dispatchEvent({
                                          type: 'pinchstart',
                                          handedness: t.handedness,
                                          target: this,
                                      }));
                            } else
                                null !== s &&
                                    t.gripSpace &&
                                    ((r = e.getPose(t.gripSpace, n)),
                                    null !== r &&
                                        (s.matrix.fromArray(r.transform.matrix),
                                        s.matrix.decompose(
                                            s.position,
                                            s.rotation,
                                            s.scale
                                        ),
                                        (s.matrixWorldNeedsUpdate = !0),
                                        r.linearVelocity
                                            ? ((s.hasLinearVelocity = !0),
                                              s.linearVelocity.copy(
                                                  r.linearVelocity
                                              ))
                                            : (s.hasLinearVelocity = !1),
                                        r.angularVelocity
                                            ? ((s.hasAngularVelocity = !0),
                                              s.angularVelocity.copy(
                                                  r.angularVelocity
                                              ))
                                            : (s.hasAngularVelocity = !1)));
                            null !== o &&
                                ((i = e.getPose(t.targetRaySpace, n)),
                                null === i && null !== r && (i = r),
                                null !== i &&
                                    (o.matrix.fromArray(i.transform.matrix),
                                    o.matrix.decompose(
                                        o.position,
                                        o.rotation,
                                        o.scale
                                    ),
                                    (o.matrixWorldNeedsUpdate = !0),
                                    i.linearVelocity
                                        ? ((o.hasLinearVelocity = !0),
                                          o.linearVelocity.copy(
                                              i.linearVelocity
                                          ))
                                        : (o.hasLinearVelocity = !1),
                                    i.angularVelocity
                                        ? ((o.hasAngularVelocity = !0),
                                          o.angularVelocity.copy(
                                              i.angularVelocity
                                          ))
                                        : (o.hasAngularVelocity = !1),
                                    this.dispatchEvent(va)));
                        }
                        return (
                            null !== o && (o.visible = null !== i),
                            null !== s && (s.visible = null !== r),
                            null !== l && (l.visible = null !== a),
                            this
                        );
                    }
                    _getHandJoint(t, e) {
                        if (void 0 === t.joints[e.jointName]) {
                            const n = new ga();
                            (n.matrixAutoUpdate = !1),
                                (n.visible = !1),
                                (t.joints[e.jointName] = n),
                                t.add(n);
                        }
                        return t.joints[e.jointName];
                    }
                }
                class xa extends xt {
                    constructor(t, e, n, i, r, a, o, s, l, c) {
                        if ((c = void 0 !== c ? c : T) !== T && c !== w)
                            throw new Error(
                                'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
                            );
                        void 0 === n && c === T && (n = y),
                            void 0 === n && c === w && (n = E),
                            super(null, i, r, a, o, s, c, n, l),
                            (this.isDepthTexture = !0),
                            (this.image = { width: t, height: e }),
                            (this.magFilter = void 0 !== o ? o : m),
                            (this.minFilter = void 0 !== s ? s : m),
                            (this.flipY = !1),
                            (this.generateMipmaps = !1);
                    }
                }
                class ya extends V {
                    constructor(t, e) {
                        super();
                        const n = this;
                        let i = null,
                            r = 1,
                            a = null,
                            o = 'local-floor',
                            s = 1,
                            l = null,
                            c = null,
                            u = null,
                            h = null,
                            d = null,
                            p = null;
                        const f = e.getContextAttributes();
                        let m = null,
                            g = null;
                        const v = [],
                            _ = [],
                            M = new Set(),
                            b = new Map(),
                            A = new On();
                        A.layers.enable(1), (A.viewport = new yt());
                        const C = new On();
                        C.layers.enable(2), (C.viewport = new yt());
                        const R = [A, C],
                            L = new ma();
                        L.layers.enable(1), L.layers.enable(2);
                        let P = null,
                            D = null;
                        function I(t) {
                            const e = _.indexOf(t.inputSource);
                            if (-1 === e) return;
                            const n = v[e];
                            void 0 !== n &&
                                (n.update(t.inputSource, t.frame, l || a),
                                n.dispatchEvent({
                                    type: t.type,
                                    data: t.inputSource,
                                }));
                        }
                        function U() {
                            i.removeEventListener('select', I),
                                i.removeEventListener('selectstart', I),
                                i.removeEventListener('selectend', I),
                                i.removeEventListener('squeeze', I),
                                i.removeEventListener('squeezestart', I),
                                i.removeEventListener('squeezeend', I),
                                i.removeEventListener('end', U),
                                i.removeEventListener('inputsourceschange', O);
                            for (let t = 0; t < v.length; t++) {
                                const e = _[t];
                                null !== e &&
                                    ((_[t] = null), v[t].disconnect(e));
                            }
                            (P = null),
                                (D = null),
                                t.setRenderTarget(m),
                                (d = null),
                                (h = null),
                                (u = null),
                                (i = null),
                                (g = null),
                                k.stop(),
                                (n.isPresenting = !1),
                                n.dispatchEvent({ type: 'sessionend' });
                        }
                        function O(t) {
                            for (let e = 0; e < t.removed.length; e++) {
                                const n = t.removed[e],
                                    i = _.indexOf(n);
                                i >= 0 && ((_[i] = null), v[i].disconnect(n));
                            }
                            for (let e = 0; e < t.added.length; e++) {
                                const n = t.added[e];
                                let i = _.indexOf(n);
                                if (-1 === i) {
                                    for (let t = 0; t < v.length; t++) {
                                        if (t >= _.length) {
                                            _.push(n), (i = t);
                                            break;
                                        }
                                        if (null === _[t]) {
                                            (_[t] = n), (i = t);
                                            break;
                                        }
                                    }
                                    if (-1 === i) break;
                                }
                                const r = v[i];
                                r && r.connect(n);
                            }
                        }
                        (this.cameraAutoUpdate = !0),
                            (this.enabled = !1),
                            (this.isPresenting = !1),
                            (this.getController = function (t) {
                                let e = v[t];
                                return (
                                    void 0 === e &&
                                        ((e = new _a()), (v[t] = e)),
                                    e.getTargetRaySpace()
                                );
                            }),
                            (this.getControllerGrip = function (t) {
                                let e = v[t];
                                return (
                                    void 0 === e &&
                                        ((e = new _a()), (v[t] = e)),
                                    e.getGripSpace()
                                );
                            }),
                            (this.getHand = function (t) {
                                let e = v[t];
                                return (
                                    void 0 === e &&
                                        ((e = new _a()), (v[t] = e)),
                                    e.getHandSpace()
                                );
                            }),
                            (this.setFramebufferScaleFactor = function (t) {
                                (r = t),
                                    !0 === n.isPresenting &&
                                        console.warn(
                                            'THREE.WebXRManager: Cannot change framebuffer scale while presenting.'
                                        );
                            }),
                            (this.setReferenceSpaceType = function (t) {
                                (o = t),
                                    !0 === n.isPresenting &&
                                        console.warn(
                                            'THREE.WebXRManager: Cannot change reference space type while presenting.'
                                        );
                            }),
                            (this.getReferenceSpace = function () {
                                return l || a;
                            }),
                            (this.setReferenceSpace = function (t) {
                                l = t;
                            }),
                            (this.getBaseLayer = function () {
                                return null !== h ? h : d;
                            }),
                            (this.getBinding = function () {
                                return u;
                            }),
                            (this.getFrame = function () {
                                return p;
                            }),
                            (this.getSession = function () {
                                return i;
                            }),
                            (this.setSession = async function (c) {
                                if (((i = c), null !== i)) {
                                    if (
                                        ((m = t.getRenderTarget()),
                                        i.addEventListener('select', I),
                                        i.addEventListener('selectstart', I),
                                        i.addEventListener('selectend', I),
                                        i.addEventListener('squeeze', I),
                                        i.addEventListener('squeezestart', I),
                                        i.addEventListener('squeezeend', I),
                                        i.addEventListener('end', U),
                                        i.addEventListener(
                                            'inputsourceschange',
                                            O
                                        ),
                                        !0 !== f.xrCompatible &&
                                            (await e.makeXRCompatible()),
                                        void 0 === i.renderState.layers ||
                                            !1 === t.capabilities.isWebGL2)
                                    ) {
                                        const n = {
                                            antialias:
                                                void 0 !==
                                                    i.renderState.layers ||
                                                f.antialias,
                                            alpha: !0,
                                            depth: f.depth,
                                            stencil: f.stencil,
                                            framebufferScaleFactor: r,
                                        };
                                        (d = new XRWebGLLayer(i, e, n)),
                                            i.updateRenderState({
                                                baseLayer: d,
                                            }),
                                            (g = new Mt(
                                                d.framebufferWidth,
                                                d.framebufferHeight,
                                                {
                                                    format: S,
                                                    type: x,
                                                    colorSpace:
                                                        t.outputColorSpace,
                                                    stencilBuffer: f.stencil,
                                                }
                                            ));
                                    } else {
                                        let n = null,
                                            a = null,
                                            o = null;
                                        f.depth &&
                                            ((o = f.stencil
                                                ? e.DEPTH24_STENCIL8
                                                : e.DEPTH_COMPONENT24),
                                            (n = f.stencil ? w : T),
                                            (a = f.stencil ? E : y));
                                        const s = {
                                            colorFormat: e.RGBA8,
                                            depthFormat: o,
                                            scaleFactor: r,
                                        };
                                        (u = new XRWebGLBinding(i, e)),
                                            (h = u.createProjectionLayer(s)),
                                            i.updateRenderState({
                                                layers: [h],
                                            }),
                                            (g = new Mt(
                                                h.textureWidth,
                                                h.textureHeight,
                                                {
                                                    format: S,
                                                    type: x,
                                                    depthTexture: new xa(
                                                        h.textureWidth,
                                                        h.textureHeight,
                                                        a,
                                                        void 0,
                                                        void 0,
                                                        void 0,
                                                        void 0,
                                                        void 0,
                                                        void 0,
                                                        n
                                                    ),
                                                    stencilBuffer: f.stencil,
                                                    colorSpace:
                                                        t.outputColorSpace,
                                                    samples: f.antialias
                                                        ? 4
                                                        : 0,
                                                }
                                            )),
                                            (t.properties.get(
                                                g
                                            ).__ignoreDepthValues =
                                                h.ignoreDepthValues);
                                    }
                                    (g.isXRRenderTarget = !0),
                                        this.setFoveation(s),
                                        (l = null),
                                        (a = await i.requestReferenceSpace(o)),
                                        k.setContext(i),
                                        k.start(),
                                        (n.isPresenting = !0),
                                        n.dispatchEvent({
                                            type: 'sessionstart',
                                        });
                                }
                            }),
                            (this.getEnvironmentBlendMode = function () {
                                if (null !== i) return i.environmentBlendMode;
                            });
                        const N = new Tt(),
                            F = new Tt();
                        function z(t, e) {
                            null === e
                                ? t.matrixWorld.copy(t.matrix)
                                : t.matrixWorld.multiplyMatrices(
                                      e.matrixWorld,
                                      t.matrix
                                  ),
                                t.matrixWorldInverse
                                    .copy(t.matrixWorld)
                                    .invert();
                        }
                        (this.updateCamera = function (t) {
                            if (null === i) return;
                            (L.near = C.near = A.near = t.near),
                                (L.far = C.far = A.far = t.far),
                                (P === L.near && D === L.far) ||
                                    (i.updateRenderState({
                                        depthNear: L.near,
                                        depthFar: L.far,
                                    }),
                                    (P = L.near),
                                    (D = L.far));
                            const e = t.parent,
                                n = L.cameras;
                            z(L, e);
                            for (let t = 0; t < n.length; t++) z(n[t], e);
                            2 === n.length
                                ? (function (t, e, n) {
                                      N.setFromMatrixPosition(e.matrixWorld),
                                          F.setFromMatrixPosition(
                                              n.matrixWorld
                                          );
                                      const i = N.distanceTo(F),
                                          r = e.projectionMatrix.elements,
                                          a = n.projectionMatrix.elements,
                                          o = r[14] / (r[10] - 1),
                                          s = r[14] / (r[10] + 1),
                                          l = (r[9] + 1) / r[5],
                                          c = (r[9] - 1) / r[5],
                                          u = (r[8] - 1) / r[0],
                                          h = (a[8] + 1) / a[0],
                                          d = o * u,
                                          p = o * h,
                                          f = i / (-u + h),
                                          m = f * -u;
                                      e.matrixWorld.decompose(
                                          t.position,
                                          t.quaternion,
                                          t.scale
                                      ),
                                          t.translateX(m),
                                          t.translateZ(f),
                                          t.matrixWorld.compose(
                                              t.position,
                                              t.quaternion,
                                              t.scale
                                          ),
                                          t.matrixWorldInverse
                                              .copy(t.matrixWorld)
                                              .invert();
                                      const g = o + f,
                                          v = s + f,
                                          _ = d - m,
                                          x = p + (i - m),
                                          y = ((l * s) / v) * g,
                                          M = ((c * s) / v) * g;
                                      t.projectionMatrix.makePerspective(
                                          _,
                                          x,
                                          y,
                                          M,
                                          g,
                                          v
                                      ),
                                          t.projectionMatrixInverse
                                              .copy(t.projectionMatrix)
                                              .invert();
                                  })(L, A, C)
                                : L.projectionMatrix.copy(A.projectionMatrix),
                                (function (t, e, n) {
                                    null === n
                                        ? t.matrix.copy(e.matrixWorld)
                                        : (t.matrix.copy(n.matrixWorld),
                                          t.matrix.invert(),
                                          t.matrix.multiply(e.matrixWorld)),
                                        t.matrix.decompose(
                                            t.position,
                                            t.quaternion,
                                            t.scale
                                        ),
                                        t.updateMatrixWorld(!0);
                                    const i = t.children;
                                    for (let t = 0, e = i.length; t < e; t++)
                                        i[t].updateMatrixWorld(!0);
                                    t.projectionMatrix.copy(e.projectionMatrix),
                                        t.projectionMatrixInverse.copy(
                                            e.projectionMatrixInverse
                                        ),
                                        t.isPerspectiveCamera &&
                                            ((t.fov =
                                                2 *
                                                X *
                                                Math.atan(
                                                    1 /
                                                        t.projectionMatrix
                                                            .elements[5]
                                                )),
                                            (t.zoom = 1));
                                })(t, L, e);
                        }),
                            (this.getCamera = function () {
                                return L;
                            }),
                            (this.getFoveation = function () {
                                if (null !== h || null !== d) return s;
                            }),
                            (this.setFoveation = function (t) {
                                (s = t),
                                    null !== h && (h.fixedFoveation = t),
                                    null !== d &&
                                        void 0 !== d.fixedFoveation &&
                                        (d.fixedFoveation = t);
                            }),
                            (this.getPlanes = function () {
                                return M;
                            });
                        let B = null;
                        const k = new Yn();
                        k.setAnimationLoop(function (e, i) {
                            if (
                                ((c = i.getViewerPose(l || a)),
                                (p = i),
                                null !== c)
                            ) {
                                const e = c.views;
                                null !== d &&
                                    (t.setRenderTargetFramebuffer(
                                        g,
                                        d.framebuffer
                                    ),
                                    t.setRenderTarget(g));
                                let n = !1;
                                e.length !== L.cameras.length &&
                                    ((L.cameras.length = 0), (n = !0));
                                for (let i = 0; i < e.length; i++) {
                                    const r = e[i];
                                    let a = null;
                                    if (null !== d) a = d.getViewport(r);
                                    else {
                                        const e = u.getViewSubImage(h, r);
                                        (a = e.viewport),
                                            0 === i &&
                                                (t.setRenderTargetTextures(
                                                    g,
                                                    e.colorTexture,
                                                    h.ignoreDepthValues
                                                        ? void 0
                                                        : e.depthStencilTexture
                                                ),
                                                t.setRenderTarget(g));
                                    }
                                    let o = R[i];
                                    void 0 === o &&
                                        ((o = new On()),
                                        o.layers.enable(i),
                                        (o.viewport = new yt()),
                                        (R[i] = o)),
                                        o.matrix.fromArray(r.transform.matrix),
                                        o.matrix.decompose(
                                            o.position,
                                            o.quaternion,
                                            o.scale
                                        ),
                                        o.projectionMatrix.fromArray(
                                            r.projectionMatrix
                                        ),
                                        o.projectionMatrixInverse
                                            .copy(o.projectionMatrix)
                                            .invert(),
                                        o.viewport.set(
                                            a.x,
                                            a.y,
                                            a.width,
                                            a.height
                                        ),
                                        0 === i &&
                                            (L.matrix.copy(o.matrix),
                                            L.matrix.decompose(
                                                L.position,
                                                L.quaternion,
                                                L.scale
                                            )),
                                        !0 === n && L.cameras.push(o);
                                }
                            }
                            for (let t = 0; t < v.length; t++) {
                                const e = _[t],
                                    n = v[t];
                                null !== e &&
                                    void 0 !== n &&
                                    n.update(e, i, l || a);
                            }
                            if ((B && B(e, i), i.detectedPlanes)) {
                                n.dispatchEvent({
                                    type: 'planesdetected',
                                    data: i.detectedPlanes,
                                });
                                let t = null;
                                for (const e of M)
                                    i.detectedPlanes.has(e) ||
                                        (null === t && (t = []), t.push(e));
                                if (null !== t)
                                    for (const e of t)
                                        M.delete(e),
                                            b.delete(e),
                                            n.dispatchEvent({
                                                type: 'planeremoved',
                                                data: e,
                                            });
                                for (const t of i.detectedPlanes)
                                    if (M.has(t)) {
                                        const e = b.get(t);
                                        t.lastChangedTime > e &&
                                            (b.set(t, t.lastChangedTime),
                                            n.dispatchEvent({
                                                type: 'planechanged',
                                                data: t,
                                            }));
                                    } else
                                        M.add(t),
                                            b.set(t, i.lastChangedTime),
                                            n.dispatchEvent({
                                                type: 'planeadded',
                                                data: t,
                                            });
                            }
                            p = null;
                        }),
                            (this.setAnimationLoop = function (t) {
                                B = t;
                            }),
                            (this.dispose = function () {});
                    }
                }
                function Ma(t, e) {
                    function n(t, e) {
                        !0 === t.matrixAutoUpdate && t.updateMatrix(),
                            e.value.copy(t.matrix);
                    }
                    function i(i, r) {
                        (i.opacity.value = r.opacity),
                            r.color && i.diffuse.value.copy(r.color),
                            r.emissive &&
                                i.emissive.value
                                    .copy(r.emissive)
                                    .multiplyScalar(r.emissiveIntensity),
                            r.map &&
                                ((i.map.value = r.map),
                                n(r.map, i.mapTransform)),
                            r.alphaMap &&
                                ((i.alphaMap.value = r.alphaMap),
                                n(r.alphaMap, i.alphaMapTransform)),
                            r.bumpMap &&
                                ((i.bumpMap.value = r.bumpMap),
                                n(r.bumpMap, i.bumpMapTransform),
                                (i.bumpScale.value = r.bumpScale),
                                r.side === o && (i.bumpScale.value *= -1)),
                            r.normalMap &&
                                ((i.normalMap.value = r.normalMap),
                                n(r.normalMap, i.normalMapTransform),
                                i.normalScale.value.copy(r.normalScale),
                                r.side === o && i.normalScale.value.negate()),
                            r.displacementMap &&
                                ((i.displacementMap.value = r.displacementMap),
                                n(
                                    r.displacementMap,
                                    i.displacementMapTransform
                                ),
                                (i.displacementScale.value =
                                    r.displacementScale),
                                (i.displacementBias.value =
                                    r.displacementBias)),
                            r.emissiveMap &&
                                ((i.emissiveMap.value = r.emissiveMap),
                                n(r.emissiveMap, i.emissiveMapTransform)),
                            r.specularMap &&
                                ((i.specularMap.value = r.specularMap),
                                n(r.specularMap, i.specularMapTransform)),
                            r.alphaTest > 0 &&
                                (i.alphaTest.value = r.alphaTest);
                        const a = e.get(r).envMap;
                        if (
                            (a &&
                                ((i.envMap.value = a),
                                (i.flipEnvMap.value =
                                    a.isCubeTexture &&
                                    !1 === a.isRenderTargetTexture
                                        ? -1
                                        : 1),
                                (i.reflectivity.value = r.reflectivity),
                                (i.ior.value = r.ior),
                                (i.refractionRatio.value = r.refractionRatio)),
                            r.lightMap)
                        ) {
                            i.lightMap.value = r.lightMap;
                            const e = !0 === t.useLegacyLights ? Math.PI : 1;
                            (i.lightMapIntensity.value =
                                r.lightMapIntensity * e),
                                n(r.lightMap, i.lightMapTransform);
                        }
                        r.aoMap &&
                            ((i.aoMap.value = r.aoMap),
                            (i.aoMapIntensity.value = r.aoMapIntensity),
                            n(r.aoMap, i.aoMapTransform));
                    }
                    return {
                        refreshFogUniforms: function (e, n) {
                            n.color.getRGB(e.fogColor.value, Pn(t)),
                                n.isFog
                                    ? ((e.fogNear.value = n.near),
                                      (e.fogFar.value = n.far))
                                    : n.isFogExp2 &&
                                      (e.fogDensity.value = n.density);
                        },
                        refreshMaterialUniforms: function (t, r, a, s, l) {
                            r.isMeshBasicMaterial || r.isMeshLambertMaterial
                                ? i(t, r)
                                : r.isMeshToonMaterial
                                  ? (i(t, r),
                                    (function (t, e) {
                                        e.gradientMap &&
                                            (t.gradientMap.value =
                                                e.gradientMap);
                                    })(t, r))
                                  : r.isMeshPhongMaterial
                                    ? (i(t, r),
                                      (function (t, e) {
                                          t.specular.value.copy(e.specular),
                                              (t.shininess.value = Math.max(
                                                  e.shininess,
                                                  1e-4
                                              ));
                                      })(t, r))
                                    : r.isMeshStandardMaterial
                                      ? (i(t, r),
                                        (function (t, i) {
                                            (t.metalness.value = i.metalness),
                                                i.metalnessMap &&
                                                    ((t.metalnessMap.value =
                                                        i.metalnessMap),
                                                    n(
                                                        i.metalnessMap,
                                                        t.metalnessMapTransform
                                                    )),
                                                (t.roughness.value =
                                                    i.roughness),
                                                i.roughnessMap &&
                                                    ((t.roughnessMap.value =
                                                        i.roughnessMap),
                                                    n(
                                                        i.roughnessMap,
                                                        t.roughnessMapTransform
                                                    ));
                                            e.get(i).envMap &&
                                                (t.envMapIntensity.value =
                                                    i.envMapIntensity);
                                        })(t, r),
                                        r.isMeshPhysicalMaterial &&
                                            (function (t, e, i) {
                                                (t.ior.value = e.ior),
                                                    e.sheen > 0 &&
                                                        (t.sheenColor.value
                                                            .copy(e.sheenColor)
                                                            .multiplyScalar(
                                                                e.sheen
                                                            ),
                                                        (t.sheenRoughness.value =
                                                            e.sheenRoughness),
                                                        e.sheenColorMap &&
                                                            ((t.sheenColorMap.value =
                                                                e.sheenColorMap),
                                                            n(
                                                                e.sheenColorMap,
                                                                t.sheenColorMapTransform
                                                            )),
                                                        e.sheenRoughnessMap &&
                                                            ((t.sheenRoughnessMap.value =
                                                                e.sheenRoughnessMap),
                                                            n(
                                                                e.sheenRoughnessMap,
                                                                t.sheenRoughnessMapTransform
                                                            ))),
                                                    e.clearcoat > 0 &&
                                                        ((t.clearcoat.value =
                                                            e.clearcoat),
                                                        (t.clearcoatRoughness.value =
                                                            e.clearcoatRoughness),
                                                        e.clearcoatMap &&
                                                            ((t.clearcoatMap.value =
                                                                e.clearcoatMap),
                                                            n(
                                                                e.clearcoatMap,
                                                                t.clearcoatMapTransform
                                                            )),
                                                        e.clearcoatRoughnessMap &&
                                                            ((t.clearcoatRoughnessMap.value =
                                                                e.clearcoatRoughnessMap),
                                                            n(
                                                                e.clearcoatRoughnessMap,
                                                                t.clearcoatRoughnessMapTransform
                                                            )),
                                                        e.clearcoatNormalMap &&
                                                            ((t.clearcoatNormalMap.value =
                                                                e.clearcoatNormalMap),
                                                            n(
                                                                e.clearcoatNormalMap,
                                                                t.clearcoatNormalMapTransform
                                                            ),
                                                            t.clearcoatNormalScale.value.copy(
                                                                e.clearcoatNormalScale
                                                            ),
                                                            e.side === o &&
                                                                t.clearcoatNormalScale.value.negate())),
                                                    e.iridescence > 0 &&
                                                        ((t.iridescence.value =
                                                            e.iridescence),
                                                        (t.iridescenceIOR.value =
                                                            e.iridescenceIOR),
                                                        (t.iridescenceThicknessMinimum.value =
                                                            e.iridescenceThicknessRange[0]),
                                                        (t.iridescenceThicknessMaximum.value =
                                                            e.iridescenceThicknessRange[1]),
                                                        e.iridescenceMap &&
                                                            ((t.iridescenceMap.value =
                                                                e.iridescenceMap),
                                                            n(
                                                                e.iridescenceMap,
                                                                t.iridescenceMapTransform
                                                            )),
                                                        e.iridescenceThicknessMap &&
                                                            ((t.iridescenceThicknessMap.value =
                                                                e.iridescenceThicknessMap),
                                                            n(
                                                                e.iridescenceThicknessMap,
                                                                t.iridescenceThicknessMapTransform
                                                            ))),
                                                    e.transmission > 0 &&
                                                        ((t.transmission.value =
                                                            e.transmission),
                                                        (t.transmissionSamplerMap.value =
                                                            i.texture),
                                                        t.transmissionSamplerSize.value.set(
                                                            i.width,
                                                            i.height
                                                        ),
                                                        e.transmissionMap &&
                                                            ((t.transmissionMap.value =
                                                                e.transmissionMap),
                                                            n(
                                                                e.transmissionMap,
                                                                t.transmissionMapTransform
                                                            )),
                                                        (t.thickness.value =
                                                            e.thickness),
                                                        e.thicknessMap &&
                                                            ((t.thicknessMap.value =
                                                                e.thicknessMap),
                                                            n(
                                                                e.thicknessMap,
                                                                t.thicknessMapTransform
                                                            )),
                                                        (t.attenuationDistance.value =
                                                            e.attenuationDistance),
                                                        t.attenuationColor.value.copy(
                                                            e.attenuationColor
                                                        )),
                                                    (t.specularIntensity.value =
                                                        e.specularIntensity),
                                                    t.specularColor.value.copy(
                                                        e.specularColor
                                                    ),
                                                    e.specularColorMap &&
                                                        ((t.specularColorMap.value =
                                                            e.specularColorMap),
                                                        n(
                                                            e.specularColorMap,
                                                            t.specularColorMapTransform
                                                        )),
                                                    e.specularIntensityMap &&
                                                        ((t.specularIntensityMap.value =
                                                            e.specularIntensityMap),
                                                        n(
                                                            e.specularIntensityMap,
                                                            t.specularIntensityMapTransform
                                                        ));
                                            })(t, r, l))
                                      : r.isMeshMatcapMaterial
                                        ? (i(t, r),
                                          (function (t, e) {
                                              e.matcap &&
                                                  (t.matcap.value = e.matcap);
                                          })(t, r))
                                        : r.isMeshDepthMaterial
                                          ? i(t, r)
                                          : r.isMeshDistanceMaterial
                                            ? (i(t, r),
                                              (function (t, n) {
                                                  const i = e.get(n).light;
                                                  t.referencePosition.value.setFromMatrixPosition(
                                                      i.matrixWorld
                                                  ),
                                                      (t.nearDistance.value =
                                                          i.shadow.camera.near),
                                                      (t.farDistance.value =
                                                          i.shadow.camera.far);
                                              })(t, r))
                                            : r.isMeshNormalMaterial
                                              ? i(t, r)
                                              : r.isLineBasicMaterial
                                                ? ((function (t, e) {
                                                      t.diffuse.value.copy(
                                                          e.color
                                                      ),
                                                          (t.opacity.value =
                                                              e.opacity),
                                                          e.map &&
                                                              ((t.map.value =
                                                                  e.map),
                                                              n(
                                                                  e.map,
                                                                  t.mapTransform
                                                              ));
                                                  })(t, r),
                                                  r.isLineDashedMaterial &&
                                                      (function (t, e) {
                                                          (t.dashSize.value =
                                                              e.dashSize),
                                                              (t.totalSize.value =
                                                                  e.dashSize +
                                                                  e.gapSize),
                                                              (t.scale.value =
                                                                  e.scale);
                                                      })(t, r))
                                                : r.isPointsMaterial
                                                  ? (function (t, e, i, r) {
                                                        t.diffuse.value.copy(
                                                            e.color
                                                        ),
                                                            (t.opacity.value =
                                                                e.opacity),
                                                            (t.size.value =
                                                                e.size * i),
                                                            (t.scale.value =
                                                                0.5 * r),
                                                            e.map &&
                                                                ((t.map.value =
                                                                    e.map),
                                                                n(
                                                                    e.map,
                                                                    t.uvTransform
                                                                )),
                                                            e.alphaMap &&
                                                                (t.alphaMap.value =
                                                                    e.alphaMap),
                                                            e.alphaTest > 0 &&
                                                                (t.alphaTest.value =
                                                                    e.alphaTest);
                                                    })(t, r, a, s)
                                                  : r.isSpriteMaterial
                                                    ? (function (t, e) {
                                                          t.diffuse.value.copy(
                                                              e.color
                                                          ),
                                                              (t.opacity.value =
                                                                  e.opacity),
                                                              (t.rotation.value =
                                                                  e.rotation),
                                                              e.map &&
                                                                  ((t.map.value =
                                                                      e.map),
                                                                  n(
                                                                      e.map,
                                                                      t.mapTransform
                                                                  )),
                                                              e.alphaMap &&
                                                                  (t.alphaMap.value =
                                                                      e.alphaMap),
                                                              e.alphaTest > 0 &&
                                                                  (t.alphaTest.value =
                                                                      e.alphaTest);
                                                      })(t, r)
                                                    : r.isShadowMaterial
                                                      ? (t.color.value.copy(
                                                            r.color
                                                        ),
                                                        (t.opacity.value =
                                                            r.opacity))
                                                      : r.isShaderMaterial &&
                                                        (r.uniformsNeedUpdate =
                                                            !1);
                        },
                    };
                }
                function ba(t, e, n, i) {
                    let r = {},
                        a = {},
                        o = [];
                    const s = n.isWebGL2
                        ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS)
                        : 0;
                    function l(t, e, n) {
                        const i = t.value;
                        if (void 0 === n[e]) {
                            if ('number' == typeof i) n[e] = i;
                            else {
                                const t = Array.isArray(i) ? i : [i],
                                    r = [];
                                for (let e = 0; e < t.length; e++)
                                    r.push(t[e].clone());
                                n[e] = r;
                            }
                            return !0;
                        }
                        if ('number' == typeof i) {
                            if (n[e] !== i) return (n[e] = i), !0;
                        } else {
                            const t = Array.isArray(n[e]) ? n[e] : [n[e]],
                                r = Array.isArray(i) ? i : [i];
                            for (let e = 0; e < t.length; e++) {
                                const n = t[e];
                                if (!1 === n.equals(r[e]))
                                    return n.copy(r[e]), !0;
                            }
                        }
                        return !1;
                    }
                    function c(t) {
                        const e = { boundary: 0, storage: 0 };
                        return (
                            'number' == typeof t
                                ? ((e.boundary = 4), (e.storage = 4))
                                : t.isVector2
                                  ? ((e.boundary = 8), (e.storage = 8))
                                  : t.isVector3 || t.isColor
                                    ? ((e.boundary = 16), (e.storage = 12))
                                    : t.isVector4
                                      ? ((e.boundary = 16), (e.storage = 16))
                                      : t.isMatrix3
                                        ? ((e.boundary = 48), (e.storage = 48))
                                        : t.isMatrix4
                                          ? ((e.boundary = 64),
                                            (e.storage = 64))
                                          : t.isTexture
                                            ? console.warn(
                                                  'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.'
                                              )
                                            : console.warn(
                                                  'THREE.WebGLRenderer: Unsupported uniform value type.',
                                                  t
                                              ),
                            e
                        );
                    }
                    function u(e) {
                        const n = e.target;
                        n.removeEventListener('dispose', u);
                        const i = o.indexOf(n.__bindingPointIndex);
                        o.splice(i, 1),
                            t.deleteBuffer(r[n.id]),
                            delete r[n.id],
                            delete a[n.id];
                    }
                    return {
                        bind: function (t, e) {
                            const n = e.program;
                            i.uniformBlockBinding(t, n);
                        },
                        update: function (n, h) {
                            let d = r[n.id];
                            void 0 === d &&
                                ((function (t) {
                                    const e = t.uniforms;
                                    let n = 0;
                                    let i = 0;
                                    for (let t = 0, r = e.length; t < r; t++) {
                                        const r = e[t],
                                            a = { boundary: 0, storage: 0 },
                                            o = Array.isArray(r.value)
                                                ? r.value
                                                : [r.value];
                                        for (
                                            let t = 0, e = o.length;
                                            t < e;
                                            t++
                                        ) {
                                            const e = c(o[t]);
                                            (a.boundary += e.boundary),
                                                (a.storage += e.storage);
                                        }
                                        (r.__data = new Float32Array(
                                            a.storage /
                                                Float32Array.BYTES_PER_ELEMENT
                                        )),
                                            (r.__offset = n),
                                            t > 0 &&
                                                ((i = n % 16),
                                                0 !== i &&
                                                    16 - i - a.boundary < 0 &&
                                                    ((n += 16 - i),
                                                    (r.__offset = n))),
                                            (n += a.storage);
                                    }
                                    (i = n % 16),
                                        i > 0 && (n += 16 - i),
                                        (t.__size = n),
                                        (t.__cache = {});
                                })(n),
                                (d = (function (e) {
                                    const n = (function () {
                                        for (let t = 0; t < s; t++)
                                            if (-1 === o.indexOf(t))
                                                return o.push(t), t;
                                        return (
                                            console.error(
                                                'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'
                                            ),
                                            0
                                        );
                                    })();
                                    e.__bindingPointIndex = n;
                                    const i = t.createBuffer(),
                                        r = e.__size,
                                        a = e.usage;
                                    return (
                                        t.bindBuffer(t.UNIFORM_BUFFER, i),
                                        t.bufferData(t.UNIFORM_BUFFER, r, a),
                                        t.bindBuffer(t.UNIFORM_BUFFER, null),
                                        t.bindBufferBase(
                                            t.UNIFORM_BUFFER,
                                            n,
                                            i
                                        ),
                                        i
                                    );
                                })(n)),
                                (r[n.id] = d),
                                n.addEventListener('dispose', u));
                            const p = h.program;
                            i.updateUBOMapping(n, p);
                            const f = e.render.frame;
                            a[n.id] !== f &&
                                ((function (e) {
                                    const n = r[e.id],
                                        i = e.uniforms,
                                        a = e.__cache;
                                    t.bindBuffer(t.UNIFORM_BUFFER, n);
                                    for (let e = 0, n = i.length; e < n; e++) {
                                        const n = i[e];
                                        if (!0 === l(n, e, a)) {
                                            const e = n.__offset,
                                                i = Array.isArray(n.value)
                                                    ? n.value
                                                    : [n.value];
                                            let r = 0;
                                            for (let a = 0; a < i.length; a++) {
                                                const o = i[a],
                                                    s = c(o);
                                                'number' == typeof o
                                                    ? ((n.__data[0] = o),
                                                      t.bufferSubData(
                                                          t.UNIFORM_BUFFER,
                                                          e + r,
                                                          n.__data
                                                      ))
                                                    : o.isMatrix3
                                                      ? ((n.__data[0] =
                                                            o.elements[0]),
                                                        (n.__data[1] =
                                                            o.elements[1]),
                                                        (n.__data[2] =
                                                            o.elements[2]),
                                                        (n.__data[3] =
                                                            o.elements[0]),
                                                        (n.__data[4] =
                                                            o.elements[3]),
                                                        (n.__data[5] =
                                                            o.elements[4]),
                                                        (n.__data[6] =
                                                            o.elements[5]),
                                                        (n.__data[7] =
                                                            o.elements[0]),
                                                        (n.__data[8] =
                                                            o.elements[6]),
                                                        (n.__data[9] =
                                                            o.elements[7]),
                                                        (n.__data[10] =
                                                            o.elements[8]),
                                                        (n.__data[11] =
                                                            o.elements[0]))
                                                      : (o.toArray(n.__data, r),
                                                        (r +=
                                                            s.storage /
                                                            Float32Array.BYTES_PER_ELEMENT));
                                            }
                                            t.bufferSubData(
                                                t.UNIFORM_BUFFER,
                                                e,
                                                n.__data
                                            );
                                        }
                                    }
                                    t.bindBuffer(t.UNIFORM_BUFFER, null);
                                })(n),
                                (a[n.id] = f));
                        },
                        dispose: function () {
                            for (const e in r) t.deleteBuffer(r[e]);
                            (o = []), (r = {}), (a = {});
                        },
                    };
                }
                function Ea() {
                    const t = rt('canvas');
                    return (t.style.display = 'block'), t;
                }
                class Sa {
                    constructor(t = {}) {
                        const {
                            canvas: e = Ea(),
                            context: n = null,
                            depth: r = !0,
                            stencil: a = !0,
                            alpha: l = !1,
                            antialias: c = !1,
                            premultipliedAlpha: u = !0,
                            preserveDrawingBuffer: h = !1,
                            powerPreference: d = 'default',
                            failIfMajorPerformanceCaveat: p = !1,
                        } = t;
                        let f;
                        (this.isWebGLRenderer = !0),
                            (f =
                                null !== n
                                    ? n.getContextAttributes().alpha
                                    : l);
                        let m = null,
                            g = null;
                        const v = [],
                            y = [];
                        (this.domElement = e),
                            (this.debug = {
                                checkShaderErrors: !0,
                                onShaderError: null,
                            }),
                            (this.autoClear = !0),
                            (this.autoClearColor = !0),
                            (this.autoClearDepth = !0),
                            (this.autoClearStencil = !0),
                            (this.sortObjects = !0),
                            (this.clippingPlanes = []),
                            (this.localClippingEnabled = !1),
                            (this.outputColorSpace = F),
                            (this.useLegacyLights = !0),
                            (this.toneMapping = 0),
                            (this.toneMappingExposure = 1);
                        const E = this;
                        let T = !1,
                            w = 0,
                            A = 0,
                            C = null,
                            R = -1,
                            L = null;
                        const P = new yt(),
                            D = new yt();
                        let I = null,
                            U = e.width,
                            O = e.height,
                            N = 1,
                            B = null,
                            k = null;
                        const H = new yt(0, 0, U, O),
                            G = new yt(0, 0, U, O);
                        let V = !1;
                        const W = new Xn();
                        let j = !1,
                            X = !1,
                            Y = null;
                        const q = new ee(),
                            K = new Tt(),
                            Z = {
                                background: null,
                                fog: null,
                                environment: null,
                                overrideMaterial: null,
                                isScene: !0,
                            };
                        function J() {
                            return null === C ? N : 1;
                        }
                        let Q,
                            $,
                            tt,
                            et,
                            nt,
                            it,
                            rt,
                            at,
                            ot,
                            st,
                            lt,
                            ct,
                            ut,
                            ht,
                            dt,
                            pt,
                            ft,
                            mt,
                            gt,
                            vt,
                            _t,
                            xt,
                            bt,
                            Et,
                            St = n;
                        function wt(t, n) {
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i],
                                    a = e.getContext(r, n);
                                if (null !== a) return a;
                            }
                            return null;
                        }
                        try {
                            const t = {
                                alpha: !0,
                                depth: r,
                                stencil: a,
                                antialias: c,
                                premultipliedAlpha: u,
                                preserveDrawingBuffer: h,
                                powerPreference: d,
                                failIfMajorPerformanceCaveat: p,
                            };
                            if (
                                ('setAttribute' in e &&
                                    e.setAttribute(
                                        'data-engine',
                                        `three.js r${i}`
                                    ),
                                e.addEventListener('webglcontextlost', Rt, !1),
                                e.addEventListener(
                                    'webglcontextrestored',
                                    Lt,
                                    !1
                                ),
                                e.addEventListener(
                                    'webglcontextcreationerror',
                                    Pt,
                                    !1
                                ),
                                null === St)
                            ) {
                                const e = [
                                    'webgl2',
                                    'webgl',
                                    'experimental-webgl',
                                ];
                                if (
                                    (!0 === E.isWebGL1Renderer && e.shift(),
                                    (St = wt(e, t)),
                                    null === St)
                                )
                                    throw wt(e)
                                        ? new Error(
                                              'Error creating WebGL context with your selected attributes.'
                                          )
                                        : new Error(
                                              'Error creating WebGL context.'
                                          );
                            }
                            void 0 === St.getShaderPrecisionFormat &&
                                (St.getShaderPrecisionFormat = function () {
                                    return {
                                        rangeMin: 1,
                                        rangeMax: 1,
                                        precision: 1,
                                    };
                                });
                        } catch (t) {
                            throw (
                                (console.error(
                                    'THREE.WebGLRenderer: ' + t.message
                                ),
                                t)
                            );
                        }
                        function At() {
                            (Q = new yi(St)),
                                ($ = new ii(St, Q, t)),
                                Q.init($),
                                (xt = new fa(St, Q, $)),
                                (tt = new da(St, Q, $)),
                                (et = new Ei(St)),
                                (nt = new Qr()),
                                (it = new pa(St, Q, tt, nt, $, xt, et)),
                                (rt = new ai(E)),
                                (at = new xi(E)),
                                (ot = new qn(St, $)),
                                (bt = new ei(St, Q, ot, $)),
                                (st = new Mi(St, ot, et, bt)),
                                (lt = new Ai(St, st, ot, et)),
                                (gt = new wi(St, $, it)),
                                (pt = new ri(nt)),
                                (ct = new Jr(E, rt, at, Q, $, bt, pt)),
                                (ut = new Ma(E, nt)),
                                (ht = new na()),
                                (dt = new la(Q, $)),
                                (mt = new ti(E, rt, at, tt, lt, f, u)),
                                (ft = new ha(E, lt, $)),
                                (Et = new ba(St, et, $, tt)),
                                (vt = new ni(St, Q, et, $)),
                                (_t = new bi(St, Q, et, $)),
                                (et.programs = ct.programs),
                                (E.capabilities = $),
                                (E.extensions = Q),
                                (E.properties = nt),
                                (E.renderLists = ht),
                                (E.shadowMap = ft),
                                (E.state = tt),
                                (E.info = et);
                        }
                        At();
                        const Ct = new ya(E, St);
                        function Rt(t) {
                            t.preventDefault(),
                                console.log(
                                    'THREE.WebGLRenderer: Context Lost.'
                                ),
                                (T = !0);
                        }
                        function Lt() {
                            console.log(
                                'THREE.WebGLRenderer: Context Restored.'
                            ),
                                (T = !1);
                            const t = et.autoReset,
                                e = ft.enabled,
                                n = ft.autoUpdate,
                                i = ft.needsUpdate,
                                r = ft.type;
                            At(),
                                (et.autoReset = t),
                                (ft.enabled = e),
                                (ft.autoUpdate = n),
                                (ft.needsUpdate = i),
                                (ft.type = r);
                        }
                        function Pt(t) {
                            console.error(
                                'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
                                t.statusMessage
                            );
                        }
                        function Dt(t) {
                            const e = t.target;
                            e.removeEventListener('dispose', Dt),
                                (function (t) {
                                    (function (t) {
                                        const e = nt.get(t).programs;
                                        void 0 !== e &&
                                            (e.forEach(function (t) {
                                                ct.releaseProgram(t);
                                            }),
                                            t.isShaderMaterial &&
                                                ct.releaseShaderCache(t));
                                    })(t),
                                        nt.remove(t);
                                })(e);
                        }
                        (this.xr = Ct),
                            (this.getContext = function () {
                                return St;
                            }),
                            (this.getContextAttributes = function () {
                                return St.getContextAttributes();
                            }),
                            (this.forceContextLoss = function () {
                                const t = Q.get('WEBGL_lose_context');
                                t && t.loseContext();
                            }),
                            (this.forceContextRestore = function () {
                                const t = Q.get('WEBGL_lose_context');
                                t && t.restoreContext();
                            }),
                            (this.getPixelRatio = function () {
                                return N;
                            }),
                            (this.setPixelRatio = function (t) {
                                void 0 !== t &&
                                    ((N = t), this.setSize(U, O, !1));
                            }),
                            (this.getSize = function (t) {
                                return t.set(U, O);
                            }),
                            (this.setSize = function (t, n, i = !0) {
                                Ct.isPresenting
                                    ? console.warn(
                                          "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                                      )
                                    : ((U = t),
                                      (O = n),
                                      (e.width = Math.floor(t * N)),
                                      (e.height = Math.floor(n * N)),
                                      !0 === i &&
                                          ((e.style.width = t + 'px'),
                                          (e.style.height = n + 'px')),
                                      this.setViewport(0, 0, t, n));
                            }),
                            (this.getDrawingBufferSize = function (t) {
                                return t.set(U * N, O * N).floor();
                            }),
                            (this.setDrawingBufferSize = function (t, n, i) {
                                (U = t),
                                    (O = n),
                                    (N = i),
                                    (e.width = Math.floor(t * i)),
                                    (e.height = Math.floor(n * i)),
                                    this.setViewport(0, 0, t, n);
                            }),
                            (this.getCurrentViewport = function (t) {
                                return t.copy(P);
                            }),
                            (this.getViewport = function (t) {
                                return t.copy(H);
                            }),
                            (this.setViewport = function (t, e, n, i) {
                                t.isVector4
                                    ? H.set(t.x, t.y, t.z, t.w)
                                    : H.set(t, e, n, i),
                                    tt.viewport(
                                        P.copy(H).multiplyScalar(N).floor()
                                    );
                            }),
                            (this.getScissor = function (t) {
                                return t.copy(G);
                            }),
                            (this.setScissor = function (t, e, n, i) {
                                t.isVector4
                                    ? G.set(t.x, t.y, t.z, t.w)
                                    : G.set(t, e, n, i),
                                    tt.scissor(
                                        D.copy(G).multiplyScalar(N).floor()
                                    );
                            }),
                            (this.getScissorTest = function () {
                                return V;
                            }),
                            (this.setScissorTest = function (t) {
                                tt.setScissorTest((V = t));
                            }),
                            (this.setOpaqueSort = function (t) {
                                B = t;
                            }),
                            (this.setTransparentSort = function (t) {
                                k = t;
                            }),
                            (this.getClearColor = function (t) {
                                return t.copy(mt.getClearColor());
                            }),
                            (this.setClearColor = function () {
                                mt.setClearColor.apply(mt, arguments);
                            }),
                            (this.getClearAlpha = function () {
                                return mt.getClearAlpha();
                            }),
                            (this.setClearAlpha = function () {
                                mt.setClearAlpha.apply(mt, arguments);
                            }),
                            (this.clear = function (t = !0, e = !0, n = !0) {
                                let i = 0;
                                t && (i |= St.COLOR_BUFFER_BIT),
                                    e && (i |= St.DEPTH_BUFFER_BIT),
                                    n && (i |= St.STENCIL_BUFFER_BIT),
                                    St.clear(i);
                            }),
                            (this.clearColor = function () {
                                this.clear(!0, !1, !1);
                            }),
                            (this.clearDepth = function () {
                                this.clear(!1, !0, !1);
                            }),
                            (this.clearStencil = function () {
                                this.clear(!1, !1, !0);
                            }),
                            (this.dispose = function () {
                                e.removeEventListener(
                                    'webglcontextlost',
                                    Rt,
                                    !1
                                ),
                                    e.removeEventListener(
                                        'webglcontextrestored',
                                        Lt,
                                        !1
                                    ),
                                    e.removeEventListener(
                                        'webglcontextcreationerror',
                                        Pt,
                                        !1
                                    ),
                                    ht.dispose(),
                                    dt.dispose(),
                                    nt.dispose(),
                                    rt.dispose(),
                                    at.dispose(),
                                    lt.dispose(),
                                    bt.dispose(),
                                    Et.dispose(),
                                    ct.dispose(),
                                    Ct.dispose(),
                                    Ct.removeEventListener('sessionstart', Ut),
                                    Ct.removeEventListener('sessionend', Ot),
                                    Y && (Y.dispose(), (Y = null)),
                                    Nt.stop();
                            }),
                            (this.renderBufferDirect = function (
                                t,
                                e,
                                n,
                                i,
                                r,
                                a
                            ) {
                                null === e && (e = Z);
                                const o =
                                        r.isMesh &&
                                        r.matrixWorld.determinant() < 0,
                                    s = (function (t, e, n, i, r) {
                                        !0 !== e.isScene && (e = Z),
                                            it.resetTextureUnits();
                                        const a = e.fog,
                                            o = i.isMeshStandardMaterial
                                                ? e.environment
                                                : null,
                                            s =
                                                null === C
                                                    ? E.outputColorSpace
                                                    : !0 === C.isXRRenderTarget
                                                      ? C.texture.colorSpace
                                                      : z,
                                            l = (
                                                i.isMeshStandardMaterial
                                                    ? at
                                                    : rt
                                            ).get(i.envMap || o),
                                            c =
                                                !0 === i.vertexColors &&
                                                !!n.attributes.color &&
                                                4 ===
                                                    n.attributes.color.itemSize,
                                            u =
                                                !!i.normalMap &&
                                                !!n.attributes.tangent,
                                            h = !!n.morphAttributes.position,
                                            d = !!n.morphAttributes.normal,
                                            p = !!n.morphAttributes.color,
                                            f = i.toneMapped
                                                ? E.toneMapping
                                                : 0,
                                            m =
                                                n.morphAttributes.position ||
                                                n.morphAttributes.normal ||
                                                n.morphAttributes.color,
                                            v = void 0 !== m ? m.length : 0,
                                            _ = nt.get(i),
                                            x = g.state.lights;
                                        if (!0 === j && (!0 === X || t !== L)) {
                                            const e = t === L && i.id === R;
                                            pt.setState(i, t, e);
                                        }
                                        let y = !1;
                                        i.version === _.__version
                                            ? (_.needsLights &&
                                                  _.lightsStateVersion !==
                                                      x.state.version) ||
                                              _.outputColorSpace !== s ||
                                              (r.isInstancedMesh &&
                                                  !1 === _.instancing)
                                                ? (y = !0)
                                                : r.isInstancedMesh ||
                                                    !0 !== _.instancing
                                                  ? r.isSkinnedMesh &&
                                                    !1 === _.skinning
                                                      ? (y = !0)
                                                      : r.isSkinnedMesh ||
                                                          !0 !== _.skinning
                                                        ? _.envMap !== l ||
                                                          (!0 === i.fog &&
                                                              _.fog !== a)
                                                            ? (y = !0)
                                                            : void 0 ===
                                                                    _.numClippingPlanes ||
                                                                (_.numClippingPlanes ===
                                                                    pt.numPlanes &&
                                                                    _.numIntersection ===
                                                                        pt.numIntersection)
                                                              ? (_.vertexAlphas !==
                                                                    c ||
                                                                    _.vertexTangents !==
                                                                        u ||
                                                                    _.morphTargets !==
                                                                        h ||
                                                                    _.morphNormals !==
                                                                        d ||
                                                                    _.morphColors !==
                                                                        p ||
                                                                    _.toneMapping !==
                                                                        f ||
                                                                    (!0 ===
                                                                        $.isWebGL2 &&
                                                                        _.morphTargetsCount !==
                                                                            v)) &&
                                                                (y = !0)
                                                              : (y = !0)
                                                        : (y = !0)
                                                  : (y = !0)
                                            : ((y = !0),
                                              (_.__version = i.version));
                                        let M = _.currentProgram;
                                        !0 === y && (M = Ht(i, e, r));
                                        let b = !1,
                                            S = !1,
                                            T = !1;
                                        const w = M.getUniforms(),
                                            A = _.uniforms;
                                        if (
                                            (tt.useProgram(M.program) &&
                                                ((b = !0), (S = !0), (T = !0)),
                                            i.id !== R &&
                                                ((R = i.id), (S = !0)),
                                            b || L !== t)
                                        ) {
                                            if (
                                                (w.setValue(
                                                    St,
                                                    'projectionMatrix',
                                                    t.projectionMatrix
                                                ),
                                                $.logarithmicDepthBuffer &&
                                                    w.setValue(
                                                        St,
                                                        'logDepthBufFC',
                                                        2 /
                                                            (Math.log(
                                                                t.far + 1
                                                            ) /
                                                                Math.LN2)
                                                    ),
                                                L !== t &&
                                                    ((L = t),
                                                    (S = !0),
                                                    (T = !0)),
                                                i.isShaderMaterial ||
                                                    i.isMeshPhongMaterial ||
                                                    i.isMeshToonMaterial ||
                                                    i.isMeshStandardMaterial ||
                                                    i.envMap)
                                            ) {
                                                const e = w.map.cameraPosition;
                                                void 0 !== e &&
                                                    e.setValue(
                                                        St,
                                                        K.setFromMatrixPosition(
                                                            t.matrixWorld
                                                        )
                                                    );
                                            }
                                            (i.isMeshPhongMaterial ||
                                                i.isMeshToonMaterial ||
                                                i.isMeshLambertMaterial ||
                                                i.isMeshBasicMaterial ||
                                                i.isMeshStandardMaterial ||
                                                i.isShaderMaterial) &&
                                                w.setValue(
                                                    St,
                                                    'isOrthographic',
                                                    !0 ===
                                                        t.isOrthographicCamera
                                                ),
                                                (i.isMeshPhongMaterial ||
                                                    i.isMeshToonMaterial ||
                                                    i.isMeshLambertMaterial ||
                                                    i.isMeshBasicMaterial ||
                                                    i.isMeshStandardMaterial ||
                                                    i.isShaderMaterial ||
                                                    i.isShadowMaterial ||
                                                    r.isSkinnedMesh) &&
                                                    w.setValue(
                                                        St,
                                                        'viewMatrix',
                                                        t.matrixWorldInverse
                                                    );
                                        }
                                        if (r.isSkinnedMesh) {
                                            w.setOptional(St, r, 'bindMatrix'),
                                                w.setOptional(
                                                    St,
                                                    r,
                                                    'bindMatrixInverse'
                                                );
                                            const t = r.skeleton;
                                            t &&
                                                ($.floatVertexTextures
                                                    ? (null === t.boneTexture &&
                                                          t.computeBoneTexture(),
                                                      w.setValue(
                                                          St,
                                                          'boneTexture',
                                                          t.boneTexture,
                                                          it
                                                      ),
                                                      w.setValue(
                                                          St,
                                                          'boneTextureSize',
                                                          t.boneTextureSize
                                                      ))
                                                    : console.warn(
                                                          'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.'
                                                      ));
                                        }
                                        const P = n.morphAttributes;
                                        var D, I;
                                        if (
                                            ((void 0 !== P.position ||
                                                void 0 !== P.normal ||
                                                (void 0 !== P.color &&
                                                    !0 === $.isWebGL2)) &&
                                                gt.update(r, n, M),
                                            (S ||
                                                _.receiveShadow !==
                                                    r.receiveShadow) &&
                                                ((_.receiveShadow =
                                                    r.receiveShadow),
                                                w.setValue(
                                                    St,
                                                    'receiveShadow',
                                                    r.receiveShadow
                                                )),
                                            i.isMeshGouraudMaterial &&
                                                null !== i.envMap &&
                                                ((A.envMap.value = l),
                                                (A.flipEnvMap.value =
                                                    l.isCubeTexture &&
                                                    !1 ===
                                                        l.isRenderTargetTexture
                                                        ? -1
                                                        : 1)),
                                            S &&
                                                (w.setValue(
                                                    St,
                                                    'toneMappingExposure',
                                                    E.toneMappingExposure
                                                ),
                                                _.needsLights &&
                                                    ((I = T),
                                                    ((D =
                                                        A).ambientLightColor.needsUpdate =
                                                        I),
                                                    (D.lightProbe.needsUpdate =
                                                        I),
                                                    (D.directionalLights.needsUpdate =
                                                        I),
                                                    (D.directionalLightShadows.needsUpdate =
                                                        I),
                                                    (D.pointLights.needsUpdate =
                                                        I),
                                                    (D.pointLightShadows.needsUpdate =
                                                        I),
                                                    (D.spotLights.needsUpdate =
                                                        I),
                                                    (D.spotLightShadows.needsUpdate =
                                                        I),
                                                    (D.rectAreaLights.needsUpdate =
                                                        I),
                                                    (D.hemisphereLights.needsUpdate =
                                                        I)),
                                                a &&
                                                    !0 === i.fog &&
                                                    ut.refreshFogUniforms(A, a),
                                                ut.refreshMaterialUniforms(
                                                    A,
                                                    i,
                                                    N,
                                                    O,
                                                    Y
                                                ),
                                                Pr.upload(
                                                    St,
                                                    _.uniformsList,
                                                    A,
                                                    it
                                                )),
                                            i.isShaderMaterial &&
                                                !0 === i.uniformsNeedUpdate &&
                                                (Pr.upload(
                                                    St,
                                                    _.uniformsList,
                                                    A,
                                                    it
                                                ),
                                                (i.uniformsNeedUpdate = !1)),
                                            i.isSpriteMaterial &&
                                                w.setValue(
                                                    St,
                                                    'center',
                                                    r.center
                                                ),
                                            w.setValue(
                                                St,
                                                'modelViewMatrix',
                                                r.modelViewMatrix
                                            ),
                                            w.setValue(
                                                St,
                                                'normalMatrix',
                                                r.normalMatrix
                                            ),
                                            w.setValue(
                                                St,
                                                'modelMatrix',
                                                r.matrixWorld
                                            ),
                                            i.isShaderMaterial ||
                                                i.isRawShaderMaterial)
                                        ) {
                                            const t = i.uniformsGroups;
                                            for (
                                                let e = 0, n = t.length;
                                                e < n;
                                                e++
                                            )
                                                if ($.isWebGL2) {
                                                    const n = t[e];
                                                    Et.update(n, M),
                                                        Et.bind(n, M);
                                                } else
                                                    console.warn(
                                                        'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.'
                                                    );
                                        }
                                        return M;
                                    })(t, e, n, i, r);
                                tt.setMaterial(i, o);
                                let l = n.index,
                                    c = 1;
                                !0 === i.wireframe &&
                                    ((l = st.getWireframeAttribute(n)),
                                    (c = 2));
                                const u = n.drawRange,
                                    h = n.attributes.position;
                                let d = u.start * c,
                                    p = (u.start + u.count) * c;
                                null !== a &&
                                    ((d = Math.max(d, a.start * c)),
                                    (p = Math.min(p, (a.start + a.count) * c))),
                                    null !== l
                                        ? ((d = Math.max(d, 0)),
                                          (p = Math.min(p, l.count)))
                                        : null != h &&
                                          ((d = Math.max(d, 0)),
                                          (p = Math.min(p, h.count)));
                                const f = p - d;
                                if (f < 0 || f === 1 / 0) return;
                                let m;
                                bt.setup(r, i, s, n, l);
                                let v = vt;
                                if (
                                    (null !== l &&
                                        ((m = ot.get(l)),
                                        (v = _t),
                                        v.setIndex(m)),
                                    r.isMesh)
                                )
                                    !0 === i.wireframe
                                        ? (tt.setLineWidth(
                                              i.wireframeLinewidth * J()
                                          ),
                                          v.setMode(St.LINES))
                                        : v.setMode(St.TRIANGLES);
                                else if (r.isLine) {
                                    let t = i.linewidth;
                                    void 0 === t && (t = 1),
                                        tt.setLineWidth(t * J()),
                                        r.isLineSegments
                                            ? v.setMode(St.LINES)
                                            : r.isLineLoop
                                              ? v.setMode(St.LINE_LOOP)
                                              : v.setMode(St.LINE_STRIP);
                                } else
                                    r.isPoints
                                        ? v.setMode(St.POINTS)
                                        : r.isSprite && v.setMode(St.TRIANGLES);
                                if (r.isInstancedMesh)
                                    v.renderInstances(d, f, r.count);
                                else if (n.isInstancedBufferGeometry) {
                                    const t =
                                            void 0 !== n._maxInstanceCount
                                                ? n._maxInstanceCount
                                                : 1 / 0,
                                        e = Math.min(n.instanceCount, t);
                                    v.renderInstances(d, f, e);
                                } else v.render(d, f);
                            }),
                            (this.compile = function (t, e) {
                                function n(t, e, n) {
                                    !0 === t.transparent &&
                                    t.side === s &&
                                    !1 === t.forceSinglePass
                                        ? ((t.side = o),
                                          (t.needsUpdate = !0),
                                          Ht(t, e, n),
                                          (t.side = 0),
                                          (t.needsUpdate = !0),
                                          Ht(t, e, n),
                                          (t.side = s))
                                        : Ht(t, e, n);
                                }
                                (g = dt.get(t)),
                                    g.init(),
                                    y.push(g),
                                    t.traverseVisible(function (t) {
                                        t.isLight &&
                                            t.layers.test(e.layers) &&
                                            (g.pushLight(t),
                                            t.castShadow && g.pushShadow(t));
                                    }),
                                    g.setupLights(E.useLegacyLights),
                                    t.traverse(function (e) {
                                        const i = e.material;
                                        if (i)
                                            if (Array.isArray(i))
                                                for (
                                                    let r = 0;
                                                    r < i.length;
                                                    r++
                                                )
                                                    n(i[r], t, e);
                                            else n(i, t, e);
                                    }),
                                    y.pop(),
                                    (g = null);
                            });
                        let It = null;
                        function Ut() {
                            Nt.stop();
                        }
                        function Ot() {
                            Nt.start();
                        }
                        const Nt = new Yn();
                        function Ft(t, e, n, i) {
                            if (!1 === t.visible) return;
                            if (t.layers.test(e.layers))
                                if (t.isGroup) n = t.renderOrder;
                                else if (t.isLOD)
                                    !0 === t.autoUpdate && t.update(e);
                                else if (t.isLight)
                                    g.pushLight(t),
                                        t.castShadow && g.pushShadow(t);
                                else if (t.isSprite) {
                                    if (
                                        !t.frustumCulled ||
                                        W.intersectsSprite(t)
                                    ) {
                                        i &&
                                            K.setFromMatrixPosition(
                                                t.matrixWorld
                                            ).applyMatrix4(q);
                                        const e = lt.update(t),
                                            r = t.material;
                                        r.visible &&
                                            m.push(t, e, r, n, K.z, null);
                                    }
                                } else if (
                                    (t.isMesh || t.isLine || t.isPoints) &&
                                    (!t.frustumCulled || W.intersectsObject(t))
                                ) {
                                    t.isSkinnedMesh &&
                                        t.skeleton.frame !== et.render.frame &&
                                        (t.skeleton.update(),
                                        (t.skeleton.frame = et.render.frame));
                                    const e = lt.update(t),
                                        r = t.material;
                                    if (
                                        (i &&
                                            (null === e.boundingSphere &&
                                                e.computeBoundingSphere(),
                                            K.copy(e.boundingSphere.center)
                                                .applyMatrix4(t.matrixWorld)
                                                .applyMatrix4(q)),
                                        Array.isArray(r))
                                    ) {
                                        const i = e.groups;
                                        for (
                                            let a = 0, o = i.length;
                                            a < o;
                                            a++
                                        ) {
                                            const o = i[a],
                                                s = r[o.materialIndex];
                                            s &&
                                                s.visible &&
                                                m.push(t, e, s, n, K.z, o);
                                        }
                                    } else
                                        r.visible &&
                                            m.push(t, e, r, n, K.z, null);
                                }
                            const r = t.children;
                            for (let t = 0, a = r.length; t < a; t++)
                                Ft(r[t], e, n, i);
                        }
                        function zt(t, e, n, i) {
                            const r = t.opaque,
                                a = t.transmissive,
                                l = t.transparent;
                            g.setupLightsView(n),
                                !0 === j &&
                                    pt.setGlobalState(E.clippingPlanes, n),
                                a.length > 0 &&
                                    (function (t, e, n, i) {
                                        if (null === Y) {
                                            const t = $.isWebGL2;
                                            Y = new Mt(1024, 1024, {
                                                generateMipmaps: !0,
                                                type: Q.has(
                                                    'EXT_color_buffer_half_float'
                                                )
                                                    ? b
                                                    : x,
                                                minFilter: _,
                                                samples: t && !0 === c ? 4 : 0,
                                            });
                                        }
                                        const r = E.getRenderTarget();
                                        E.setRenderTarget(Y), E.clear();
                                        const a = E.toneMapping;
                                        (E.toneMapping = 0),
                                            Bt(t, n, i),
                                            it.updateMultisampleRenderTarget(Y),
                                            it.updateRenderTargetMipmap(Y);
                                        let l = !1;
                                        for (
                                            let t = 0, r = e.length;
                                            t < r;
                                            t++
                                        ) {
                                            const r = e[t],
                                                a = r.object,
                                                c = r.geometry,
                                                u = r.material,
                                                h = r.group;
                                            if (
                                                u.side === s &&
                                                a.layers.test(i.layers)
                                            ) {
                                                const t = u.side;
                                                (u.side = o),
                                                    (u.needsUpdate = !0),
                                                    kt(a, n, i, c, u, h),
                                                    (u.side = t),
                                                    (u.needsUpdate = !0),
                                                    (l = !0);
                                            }
                                        }
                                        !0 === l &&
                                            (it.updateMultisampleRenderTarget(
                                                Y
                                            ),
                                            it.updateRenderTargetMipmap(Y)),
                                            E.setRenderTarget(r),
                                            (E.toneMapping = a);
                                    })(r, a, e, n),
                                i && tt.viewport(P.copy(i)),
                                r.length > 0 && Bt(r, e, n),
                                a.length > 0 && Bt(a, e, n),
                                l.length > 0 && Bt(l, e, n),
                                tt.buffers.depth.setTest(!0),
                                tt.buffers.depth.setMask(!0),
                                tt.buffers.color.setMask(!0),
                                tt.setPolygonOffset(!1);
                        }
                        function Bt(t, e, n) {
                            const i =
                                !0 === e.isScene ? e.overrideMaterial : null;
                            for (let r = 0, a = t.length; r < a; r++) {
                                const a = t[r],
                                    o = a.object,
                                    s = a.geometry,
                                    l = null === i ? a.material : i,
                                    c = a.group;
                                o.layers.test(n.layers) && kt(o, e, n, s, l, c);
                            }
                        }
                        function kt(t, e, n, i, r, a) {
                            t.onBeforeRender(E, e, n, i, r, a),
                                t.modelViewMatrix.multiplyMatrices(
                                    n.matrixWorldInverse,
                                    t.matrixWorld
                                ),
                                t.normalMatrix.getNormalMatrix(
                                    t.modelViewMatrix
                                ),
                                r.onBeforeRender(E, e, n, i, t, a),
                                !0 === r.transparent &&
                                r.side === s &&
                                !1 === r.forceSinglePass
                                    ? ((r.side = o),
                                      (r.needsUpdate = !0),
                                      E.renderBufferDirect(n, e, i, r, t, a),
                                      (r.side = 0),
                                      (r.needsUpdate = !0),
                                      E.renderBufferDirect(n, e, i, r, t, a),
                                      (r.side = s))
                                    : E.renderBufferDirect(n, e, i, r, t, a),
                                t.onAfterRender(E, e, n, i, r, a);
                        }
                        function Ht(t, e, n) {
                            !0 !== e.isScene && (e = Z);
                            const i = nt.get(t),
                                r = g.state.lights,
                                a = g.state.shadowsArray,
                                o = r.state.version,
                                s = ct.getParameters(t, r.state, a, e, n),
                                l = ct.getProgramCacheKey(s);
                            let c = i.programs;
                            (i.environment = t.isMeshStandardMaterial
                                ? e.environment
                                : null),
                                (i.fog = e.fog),
                                (i.envMap = (
                                    t.isMeshStandardMaterial ? at : rt
                                ).get(t.envMap || i.environment)),
                                void 0 === c &&
                                    (t.addEventListener('dispose', Dt),
                                    (c = new Map()),
                                    (i.programs = c));
                            let u = c.get(l);
                            if (void 0 !== u) {
                                if (
                                    i.currentProgram === u &&
                                    i.lightsStateVersion === o
                                )
                                    return Gt(t, s), u;
                            } else
                                (s.uniforms = ct.getUniforms(t)),
                                    t.onBuild(n, s, E),
                                    t.onBeforeCompile(s, E),
                                    (u = ct.acquireProgram(s, l)),
                                    c.set(l, u),
                                    (i.uniforms = s.uniforms);
                            const h = i.uniforms;
                            ((t.isShaderMaterial || t.isRawShaderMaterial) &&
                                !0 !== t.clipping) ||
                                (h.clippingPlanes = pt.uniform),
                                Gt(t, s),
                                (i.needsLights = (function (t) {
                                    return (
                                        t.isMeshLambertMaterial ||
                                        t.isMeshToonMaterial ||
                                        t.isMeshPhongMaterial ||
                                        t.isMeshStandardMaterial ||
                                        t.isShadowMaterial ||
                                        (t.isShaderMaterial && !0 === t.lights)
                                    );
                                })(t)),
                                (i.lightsStateVersion = o),
                                i.needsLights &&
                                    ((h.ambientLightColor.value =
                                        r.state.ambient),
                                    (h.lightProbe.value = r.state.probe),
                                    (h.directionalLights.value =
                                        r.state.directional),
                                    (h.directionalLightShadows.value =
                                        r.state.directionalShadow),
                                    (h.spotLights.value = r.state.spot),
                                    (h.spotLightShadows.value =
                                        r.state.spotShadow),
                                    (h.rectAreaLights.value = r.state.rectArea),
                                    (h.ltc_1.value = r.state.rectAreaLTC1),
                                    (h.ltc_2.value = r.state.rectAreaLTC2),
                                    (h.pointLights.value = r.state.point),
                                    (h.pointLightShadows.value =
                                        r.state.pointShadow),
                                    (h.hemisphereLights.value = r.state.hemi),
                                    (h.directionalShadowMap.value =
                                        r.state.directionalShadowMap),
                                    (h.directionalShadowMatrix.value =
                                        r.state.directionalShadowMatrix),
                                    (h.spotShadowMap.value =
                                        r.state.spotShadowMap),
                                    (h.spotLightMatrix.value =
                                        r.state.spotLightMatrix),
                                    (h.spotLightMap.value =
                                        r.state.spotLightMap),
                                    (h.pointShadowMap.value =
                                        r.state.pointShadowMap),
                                    (h.pointShadowMatrix.value =
                                        r.state.pointShadowMatrix));
                            const d = u.getUniforms(),
                                p = Pr.seqWithValue(d.seq, h);
                            return (
                                (i.currentProgram = u), (i.uniformsList = p), u
                            );
                        }
                        function Gt(t, e) {
                            const n = nt.get(t);
                            (n.outputColorSpace = e.outputColorSpace),
                                (n.instancing = e.instancing),
                                (n.skinning = e.skinning),
                                (n.morphTargets = e.morphTargets),
                                (n.morphNormals = e.morphNormals),
                                (n.morphColors = e.morphColors),
                                (n.morphTargetsCount = e.morphTargetsCount),
                                (n.numClippingPlanes = e.numClippingPlanes),
                                (n.numIntersection = e.numClipIntersection),
                                (n.vertexAlphas = e.vertexAlphas),
                                (n.vertexTangents = e.vertexTangents),
                                (n.toneMapping = e.toneMapping);
                        }
                        Nt.setAnimationLoop(function (t) {
                            It && It(t);
                        }),
                            'undefined' != typeof self && Nt.setContext(self),
                            (this.setAnimationLoop = function (t) {
                                (It = t),
                                    Ct.setAnimationLoop(t),
                                    null === t ? Nt.stop() : Nt.start();
                            }),
                            Ct.addEventListener('sessionstart', Ut),
                            Ct.addEventListener('sessionend', Ot),
                            (this.render = function (t, e) {
                                if (void 0 !== e && !0 !== e.isCamera)
                                    return void console.error(
                                        'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
                                    );
                                if (!0 === T) return;
                                !0 === t.matrixWorldAutoUpdate &&
                                    t.updateMatrixWorld(),
                                    null === e.parent &&
                                        !0 === e.matrixWorldAutoUpdate &&
                                        e.updateMatrixWorld(),
                                    !0 === Ct.enabled &&
                                        !0 === Ct.isPresenting &&
                                        (!0 === Ct.cameraAutoUpdate &&
                                            Ct.updateCamera(e),
                                        (e = Ct.getCamera())),
                                    !0 === t.isScene &&
                                        t.onBeforeRender(E, t, e, C),
                                    (g = dt.get(t, y.length)),
                                    g.init(),
                                    y.push(g),
                                    q.multiplyMatrices(
                                        e.projectionMatrix,
                                        e.matrixWorldInverse
                                    ),
                                    W.setFromProjectionMatrix(q),
                                    (X = this.localClippingEnabled),
                                    (j = pt.init(this.clippingPlanes, X)),
                                    (m = ht.get(t, v.length)),
                                    m.init(),
                                    v.push(m),
                                    Ft(t, e, 0, E.sortObjects),
                                    m.finish(),
                                    !0 === E.sortObjects && m.sort(B, k),
                                    !0 === j && pt.beginShadows();
                                const n = g.state.shadowsArray;
                                if (
                                    (ft.render(n, t, e),
                                    !0 === j && pt.endShadows(),
                                    !0 === this.info.autoReset &&
                                        this.info.reset(),
                                    mt.render(m, t),
                                    g.setupLights(E.useLegacyLights),
                                    e.isArrayCamera)
                                ) {
                                    const n = e.cameras;
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = n[e];
                                        zt(m, t, i, i.viewport);
                                    }
                                } else zt(m, t, e);
                                null !== C &&
                                    (it.updateMultisampleRenderTarget(C),
                                    it.updateRenderTargetMipmap(C)),
                                    !0 === t.isScene &&
                                        t.onAfterRender(E, t, e),
                                    bt.resetDefaultState(),
                                    (R = -1),
                                    (L = null),
                                    y.pop(),
                                    (g = y.length > 0 ? y[y.length - 1] : null),
                                    v.pop(),
                                    (m = v.length > 0 ? v[v.length - 1] : null);
                            }),
                            (this.getActiveCubeFace = function () {
                                return w;
                            }),
                            (this.getActiveMipmapLevel = function () {
                                return A;
                            }),
                            (this.getRenderTarget = function () {
                                return C;
                            }),
                            (this.setRenderTargetTextures = function (t, e, n) {
                                (nt.get(t.texture).__webglTexture = e),
                                    (nt.get(t.depthTexture).__webglTexture = n);
                                const i = nt.get(t);
                                (i.__hasExternalTextures = !0),
                                    i.__hasExternalTextures &&
                                        ((i.__autoAllocateDepthBuffer =
                                            void 0 === n),
                                        i.__autoAllocateDepthBuffer ||
                                            (!0 ===
                                                Q.has(
                                                    'WEBGL_multisampled_render_to_texture'
                                                ) &&
                                                (console.warn(
                                                    'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
                                                ),
                                                (i.__useRenderToTexture =
                                                    !1))));
                            }),
                            (this.setRenderTargetFramebuffer = function (t, e) {
                                const n = nt.get(t);
                                (n.__webglFramebuffer = e),
                                    (n.__useDefaultFramebuffer = void 0 === e);
                            }),
                            (this.setRenderTarget = function (t, e = 0, n = 0) {
                                (C = t), (w = e), (A = n);
                                let i = !0,
                                    r = null,
                                    a = !1,
                                    o = !1;
                                if (t) {
                                    const n = nt.get(t);
                                    void 0 !== n.__useDefaultFramebuffer
                                        ? (tt.bindFramebuffer(
                                              St.FRAMEBUFFER,
                                              null
                                          ),
                                          (i = !1))
                                        : void 0 === n.__webglFramebuffer
                                          ? it.setupRenderTarget(t)
                                          : n.__hasExternalTextures &&
                                            it.rebindTextures(
                                                t,
                                                nt.get(t.texture)
                                                    .__webglTexture,
                                                nt.get(t.depthTexture)
                                                    .__webglTexture
                                            );
                                    const s = t.texture;
                                    (s.isData3DTexture ||
                                        s.isDataArrayTexture ||
                                        s.isCompressedArrayTexture) &&
                                        (o = !0);
                                    const l = nt.get(t).__webglFramebuffer;
                                    t.isWebGLCubeRenderTarget
                                        ? ((r = l[e]), (a = !0))
                                        : (r =
                                              $.isWebGL2 &&
                                              t.samples > 0 &&
                                              !1 === it.useMultisampledRTT(t)
                                                  ? nt.get(t)
                                                        .__webglMultisampledFramebuffer
                                                  : l),
                                        P.copy(t.viewport),
                                        D.copy(t.scissor),
                                        (I = t.scissorTest);
                                } else
                                    P.copy(H).multiplyScalar(N).floor(),
                                        D.copy(G).multiplyScalar(N).floor(),
                                        (I = V);
                                if (
                                    (tt.bindFramebuffer(St.FRAMEBUFFER, r) &&
                                        $.drawBuffers &&
                                        i &&
                                        tt.drawBuffers(t, r),
                                    tt.viewport(P),
                                    tt.scissor(D),
                                    tt.setScissorTest(I),
                                    a)
                                ) {
                                    const i = nt.get(t.texture);
                                    St.framebufferTexture2D(
                                        St.FRAMEBUFFER,
                                        St.COLOR_ATTACHMENT0,
                                        St.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                        i.__webglTexture,
                                        n
                                    );
                                } else if (o) {
                                    const i = nt.get(t.texture),
                                        r = e || 0;
                                    St.framebufferTextureLayer(
                                        St.FRAMEBUFFER,
                                        St.COLOR_ATTACHMENT0,
                                        i.__webglTexture,
                                        n || 0,
                                        r
                                    );
                                }
                                R = -1;
                            }),
                            (this.readRenderTargetPixels = function (
                                t,
                                e,
                                n,
                                i,
                                r,
                                a,
                                o
                            ) {
                                if (!t || !t.isWebGLRenderTarget)
                                    return void console.error(
                                        'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
                                    );
                                let s = nt.get(t).__webglFramebuffer;
                                if (
                                    (t.isWebGLCubeRenderTarget &&
                                        void 0 !== o &&
                                        (s = s[o]),
                                    s)
                                ) {
                                    tt.bindFramebuffer(St.FRAMEBUFFER, s);
                                    try {
                                        const o = t.texture,
                                            s = o.format,
                                            l = o.type;
                                        if (
                                            s !== S &&
                                            xt.convert(s) !==
                                                St.getParameter(
                                                    St.IMPLEMENTATION_COLOR_READ_FORMAT
                                                )
                                        )
                                            return void console.error(
                                                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
                                            );
                                        const c =
                                            l === b &&
                                            (Q.has(
                                                'EXT_color_buffer_half_float'
                                            ) ||
                                                ($.isWebGL2 &&
                                                    Q.has(
                                                        'EXT_color_buffer_float'
                                                    )));
                                        if (
                                            !(
                                                l === x ||
                                                xt.convert(l) ===
                                                    St.getParameter(
                                                        St.IMPLEMENTATION_COLOR_READ_TYPE
                                                    ) ||
                                                (l === M &&
                                                    ($.isWebGL2 ||
                                                        Q.has(
                                                            'OES_texture_float'
                                                        ) ||
                                                        Q.has(
                                                            'WEBGL_color_buffer_float'
                                                        ))) ||
                                                c
                                            )
                                        )
                                            return void console.error(
                                                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
                                            );
                                        e >= 0 &&
                                            e <= t.width - i &&
                                            n >= 0 &&
                                            n <= t.height - r &&
                                            St.readPixels(
                                                e,
                                                n,
                                                i,
                                                r,
                                                xt.convert(s),
                                                xt.convert(l),
                                                a
                                            );
                                    } finally {
                                        const t =
                                            null !== C
                                                ? nt.get(C).__webglFramebuffer
                                                : null;
                                        tt.bindFramebuffer(St.FRAMEBUFFER, t);
                                    }
                                }
                            }),
                            (this.copyFramebufferToTexture = function (
                                t,
                                e,
                                n = 0
                            ) {
                                const i = Math.pow(2, -n),
                                    r = Math.floor(e.image.width * i),
                                    a = Math.floor(e.image.height * i);
                                it.setTexture2D(e, 0),
                                    St.copyTexSubImage2D(
                                        St.TEXTURE_2D,
                                        n,
                                        0,
                                        0,
                                        t.x,
                                        t.y,
                                        r,
                                        a
                                    ),
                                    tt.unbindTexture();
                            }),
                            (this.copyTextureToTexture = function (
                                t,
                                e,
                                n,
                                i = 0
                            ) {
                                const r = e.image.width,
                                    a = e.image.height,
                                    o = xt.convert(n.format),
                                    s = xt.convert(n.type);
                                it.setTexture2D(n, 0),
                                    St.pixelStorei(
                                        St.UNPACK_FLIP_Y_WEBGL,
                                        n.flipY
                                    ),
                                    St.pixelStorei(
                                        St.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                                        n.premultiplyAlpha
                                    ),
                                    St.pixelStorei(
                                        St.UNPACK_ALIGNMENT,
                                        n.unpackAlignment
                                    ),
                                    e.isDataTexture
                                        ? St.texSubImage2D(
                                              St.TEXTURE_2D,
                                              i,
                                              t.x,
                                              t.y,
                                              r,
                                              a,
                                              o,
                                              s,
                                              e.image.data
                                          )
                                        : e.isCompressedTexture
                                          ? St.compressedTexSubImage2D(
                                                St.TEXTURE_2D,
                                                i,
                                                t.x,
                                                t.y,
                                                e.mipmaps[0].width,
                                                e.mipmaps[0].height,
                                                o,
                                                e.mipmaps[0].data
                                            )
                                          : St.texSubImage2D(
                                                St.TEXTURE_2D,
                                                i,
                                                t.x,
                                                t.y,
                                                o,
                                                s,
                                                e.image
                                            ),
                                    0 === i &&
                                        n.generateMipmaps &&
                                        St.generateMipmap(St.TEXTURE_2D),
                                    tt.unbindTexture();
                            }),
                            (this.copyTextureToTexture3D = function (
                                t,
                                e,
                                n,
                                i,
                                r = 0
                            ) {
                                if (E.isWebGL1Renderer)
                                    return void console.warn(
                                        'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.'
                                    );
                                const a = t.max.x - t.min.x + 1,
                                    o = t.max.y - t.min.y + 1,
                                    s = t.max.z - t.min.z + 1,
                                    l = xt.convert(i.format),
                                    c = xt.convert(i.type);
                                let u;
                                if (i.isData3DTexture)
                                    it.setTexture3D(i, 0), (u = St.TEXTURE_3D);
                                else {
                                    if (!i.isDataArrayTexture)
                                        return void console.warn(
                                            'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
                                        );
                                    it.setTexture2DArray(i, 0),
                                        (u = St.TEXTURE_2D_ARRAY);
                                }
                                St.pixelStorei(St.UNPACK_FLIP_Y_WEBGL, i.flipY),
                                    St.pixelStorei(
                                        St.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                                        i.premultiplyAlpha
                                    ),
                                    St.pixelStorei(
                                        St.UNPACK_ALIGNMENT,
                                        i.unpackAlignment
                                    );
                                const h = St.getParameter(St.UNPACK_ROW_LENGTH),
                                    d = St.getParameter(St.UNPACK_IMAGE_HEIGHT),
                                    p = St.getParameter(St.UNPACK_SKIP_PIXELS),
                                    f = St.getParameter(St.UNPACK_SKIP_ROWS),
                                    m = St.getParameter(St.UNPACK_SKIP_IMAGES),
                                    g = n.isCompressedTexture
                                        ? n.mipmaps[0]
                                        : n.image;
                                St.pixelStorei(St.UNPACK_ROW_LENGTH, g.width),
                                    St.pixelStorei(
                                        St.UNPACK_IMAGE_HEIGHT,
                                        g.height
                                    ),
                                    St.pixelStorei(
                                        St.UNPACK_SKIP_PIXELS,
                                        t.min.x
                                    ),
                                    St.pixelStorei(
                                        St.UNPACK_SKIP_ROWS,
                                        t.min.y
                                    ),
                                    St.pixelStorei(
                                        St.UNPACK_SKIP_IMAGES,
                                        t.min.z
                                    ),
                                    n.isDataTexture || n.isData3DTexture
                                        ? St.texSubImage3D(
                                              u,
                                              r,
                                              e.x,
                                              e.y,
                                              e.z,
                                              a,
                                              o,
                                              s,
                                              l,
                                              c,
                                              g.data
                                          )
                                        : n.isCompressedArrayTexture
                                          ? (console.warn(
                                                'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.'
                                            ),
                                            St.compressedTexSubImage3D(
                                                u,
                                                r,
                                                e.x,
                                                e.y,
                                                e.z,
                                                a,
                                                o,
                                                s,
                                                l,
                                                g.data
                                            ))
                                          : St.texSubImage3D(
                                                u,
                                                r,
                                                e.x,
                                                e.y,
                                                e.z,
                                                a,
                                                o,
                                                s,
                                                l,
                                                c,
                                                g
                                            ),
                                    St.pixelStorei(St.UNPACK_ROW_LENGTH, h),
                                    St.pixelStorei(St.UNPACK_IMAGE_HEIGHT, d),
                                    St.pixelStorei(St.UNPACK_SKIP_PIXELS, p),
                                    St.pixelStorei(St.UNPACK_SKIP_ROWS, f),
                                    St.pixelStorei(St.UNPACK_SKIP_IMAGES, m),
                                    0 === r &&
                                        i.generateMipmaps &&
                                        St.generateMipmap(u),
                                    tt.unbindTexture();
                            }),
                            (this.initTexture = function (t) {
                                t.isCubeTexture
                                    ? it.setTextureCube(t, 0)
                                    : t.isData3DTexture
                                      ? it.setTexture3D(t, 0)
                                      : t.isDataArrayTexture ||
                                          t.isCompressedArrayTexture
                                        ? it.setTexture2DArray(t, 0)
                                        : it.setTexture2D(t, 0),
                                    tt.unbindTexture();
                            }),
                            (this.resetState = function () {
                                (w = 0),
                                    (A = 0),
                                    (C = null),
                                    tt.reset(),
                                    bt.reset();
                            }),
                            'undefined' != typeof __THREE_DEVTOOLS__ &&
                                __THREE_DEVTOOLS__.dispatchEvent(
                                    new CustomEvent('observe', { detail: this })
                                );
                    }
                    get physicallyCorrectLights() {
                        return (
                            console.warn(
                                'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.'
                            ),
                            !this.useLegacyLights
                        );
                    }
                    set physicallyCorrectLights(t) {
                        console.warn(
                            'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.'
                        ),
                            (this.useLegacyLights = !t);
                    }
                    get outputEncoding() {
                        return (
                            console.warn(
                                'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.'
                            ),
                            this.outputColorSpace === F ? N : 3e3
                        );
                    }
                    set outputEncoding(t) {
                        console.warn(
                            'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.'
                        ),
                            (this.outputColorSpace = t === N ? F : z);
                    }
                }
                (class extends Sa {}).prototype.isWebGL1Renderer = !0;
                class Ta extends we {
                    constructor() {
                        super(),
                            (this.isScene = !0),
                            (this.type = 'Scene'),
                            (this.background = null),
                            (this.environment = null),
                            (this.fog = null),
                            (this.backgroundBlurriness = 0),
                            (this.backgroundIntensity = 1),
                            (this.overrideMaterial = null),
                            'undefined' != typeof __THREE_DEVTOOLS__ &&
                                __THREE_DEVTOOLS__.dispatchEvent(
                                    new CustomEvent('observe', { detail: this })
                                );
                    }
                    copy(t, e) {
                        return (
                            super.copy(t, e),
                            null !== t.background &&
                                (this.background = t.background.clone()),
                            null !== t.environment &&
                                (this.environment = t.environment.clone()),
                            null !== t.fog && (this.fog = t.fog.clone()),
                            (this.backgroundBlurriness =
                                t.backgroundBlurriness),
                            (this.backgroundIntensity = t.backgroundIntensity),
                            null !== t.overrideMaterial &&
                                (this.overrideMaterial =
                                    t.overrideMaterial.clone()),
                            (this.matrixAutoUpdate = t.matrixAutoUpdate),
                            this
                        );
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (
                            null !== this.fog &&
                                (e.object.fog = this.fog.toJSON()),
                            this.backgroundBlurriness > 0 &&
                                (e.object.backgroundBlurriness =
                                    this.backgroundBlurriness),
                            1 !== this.backgroundIntensity &&
                                (e.object.backgroundIntensity =
                                    this.backgroundIntensity),
                            e
                        );
                    }
                    get autoUpdate() {
                        return (
                            console.warn(
                                'THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.'
                            ),
                            this.matrixWorldAutoUpdate
                        );
                    }
                    set autoUpdate(t) {
                        console.warn(
                            'THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.'
                        ),
                            (this.matrixWorldAutoUpdate = t);
                    }
                }
                class wa extends ke {
                    constructor(t) {
                        super(),
                            (this.isLineBasicMaterial = !0),
                            (this.type = 'LineBasicMaterial'),
                            (this.color = new je(16777215)),
                            (this.map = null),
                            (this.linewidth = 1),
                            (this.linecap = 'round'),
                            (this.linejoin = 'round'),
                            (this.fog = !0),
                            this.setValues(t);
                    }
                    copy(t) {
                        return (
                            super.copy(t),
                            this.color.copy(t.color),
                            (this.map = t.map),
                            (this.linewidth = t.linewidth),
                            (this.linecap = t.linecap),
                            (this.linejoin = t.linejoin),
                            (this.fog = t.fog),
                            this
                        );
                    }
                }
                class Aa extends In {
                    constructor(t) {
                        super(t),
                            (this.isRawShaderMaterial = !0),
                            (this.type = 'RawShaderMaterial');
                    }
                }
                function Ca(t, e, n) {
                    return La(t)
                        ? new t.constructor(
                              t.subarray(e, void 0 !== n ? n : t.length)
                          )
                        : t.slice(e, n);
                }
                function Ra(t, e, n) {
                    return !t || (!n && t.constructor === e)
                        ? t
                        : 'number' == typeof e.BYTES_PER_ELEMENT
                          ? new e(t)
                          : Array.prototype.slice.call(t);
                }
                function La(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView);
                }
                class Pa {
                    constructor(t, e, n, i) {
                        (this.parameterPositions = t),
                            (this._cachedIndex = 0),
                            (this.resultBuffer =
                                void 0 !== i ? i : new e.constructor(n)),
                            (this.sampleValues = e),
                            (this.valueSize = n),
                            (this.settings = null),
                            (this.DefaultSettings_ = {});
                    }
                    evaluate(t) {
                        const e = this.parameterPositions;
                        let n = this._cachedIndex,
                            i = e[n],
                            r = e[n - 1];
                        t: {
                            e: {
                                let a;
                                n: {
                                    i: if (!(t < i)) {
                                        for (let a = n + 2; ; ) {
                                            if (void 0 === i) {
                                                if (t < r) break i;
                                                return (
                                                    (n = e.length),
                                                    (this._cachedIndex = n),
                                                    this.copySampleValue_(n - 1)
                                                );
                                            }
                                            if (n === a) break;
                                            if (((r = i), (i = e[++n]), t < i))
                                                break e;
                                        }
                                        a = e.length;
                                        break n;
                                    }
                                    if (t >= r) break t;
                                    {
                                        const o = e[1];
                                        t < o && ((n = 2), (r = o));
                                        for (let a = n - 2; ; ) {
                                            if (void 0 === r)
                                                return (
                                                    (this._cachedIndex = 0),
                                                    this.copySampleValue_(0)
                                                );
                                            if (n === a) break;
                                            if (
                                                ((i = r),
                                                (r = e[--n - 1]),
                                                t >= r)
                                            )
                                                break e;
                                        }
                                        (a = n), (n = 0);
                                    }
                                }
                                for (; n < a; ) {
                                    const i = (n + a) >>> 1;
                                    t < e[i] ? (a = i) : (n = i + 1);
                                }
                                if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                                    return (
                                        (this._cachedIndex = 0),
                                        this.copySampleValue_(0)
                                    );
                                if (void 0 === i)
                                    return (
                                        (n = e.length),
                                        (this._cachedIndex = n),
                                        this.copySampleValue_(n - 1)
                                    );
                            }
                            (this._cachedIndex = n),
                                this.intervalChanged_(n, r, i);
                        }
                        return this.interpolate_(n, r, t, i);
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_;
                    }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            i = this.valueSize,
                            r = t * i;
                        for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                        return e;
                    }
                    interpolate_() {
                        throw new Error('call to abstract method');
                    }
                    intervalChanged_() {}
                }
                class Da extends Pa {
                    constructor(t, e, n, i) {
                        super(t, e, n, i),
                            (this._weightPrev = -0),
                            (this._offsetPrev = -0),
                            (this._weightNext = -0),
                            (this._offsetNext = -0),
                            (this.DefaultSettings_ = {
                                endingStart: 2400,
                                endingEnd: 2400,
                            });
                    }
                    intervalChanged_(t, e, n) {
                        const i = this.parameterPositions;
                        let r = t - 2,
                            a = t + 1,
                            o = i[r],
                            s = i[a];
                        if (void 0 === o)
                            switch (this.getSettings_().endingStart) {
                                case 2401:
                                    (r = t), (o = 2 * e - n);
                                    break;
                                case 2402:
                                    (r = i.length - 2),
                                        (o = e + i[r] - i[r + 1]);
                                    break;
                                default:
                                    (r = t), (o = n);
                            }
                        if (void 0 === s)
                            switch (this.getSettings_().endingEnd) {
                                case 2401:
                                    (a = t), (s = 2 * n - e);
                                    break;
                                case 2402:
                                    (a = 1), (s = n + i[1] - i[0]);
                                    break;
                                default:
                                    (a = t - 1), (s = e);
                            }
                        const l = 0.5 * (n - e),
                            c = this.valueSize;
                        (this._weightPrev = l / (e - o)),
                            (this._weightNext = l / (s - n)),
                            (this._offsetPrev = r * c),
                            (this._offsetNext = a * c);
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            a = this.sampleValues,
                            o = this.valueSize,
                            s = t * o,
                            l = s - o,
                            c = this._offsetPrev,
                            u = this._offsetNext,
                            h = this._weightPrev,
                            d = this._weightNext,
                            p = (n - e) / (i - e),
                            f = p * p,
                            m = f * p,
                            g = -h * m + 2 * h * f - h * p,
                            v =
                                (1 + h) * m +
                                (-1.5 - 2 * h) * f +
                                (-0.5 + h) * p +
                                1,
                            _ = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
                            x = d * m - d * f;
                        for (let t = 0; t !== o; ++t)
                            r[t] =
                                g * a[c + t] +
                                v * a[l + t] +
                                _ * a[s + t] +
                                x * a[u + t];
                        return r;
                    }
                }
                class Ia extends Pa {
                    constructor(t, e, n, i) {
                        super(t, e, n, i);
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            a = this.sampleValues,
                            o = this.valueSize,
                            s = t * o,
                            l = s - o,
                            c = (n - e) / (i - e),
                            u = 1 - c;
                        for (let t = 0; t !== o; ++t)
                            r[t] = a[l + t] * u + a[s + t] * c;
                        return r;
                    }
                }
                class Ua extends Pa {
                    constructor(t, e, n, i) {
                        super(t, e, n, i);
                    }
                    interpolate_(t) {
                        return this.copySampleValue_(t - 1);
                    }
                }
                class Oa {
                    constructor(t, e, n, i) {
                        if (void 0 === t)
                            throw new Error(
                                'THREE.KeyframeTrack: track name is undefined'
                            );
                        if (void 0 === e || 0 === e.length)
                            throw new Error(
                                'THREE.KeyframeTrack: no keyframes in track named ' +
                                    t
                            );
                        (this.name = t),
                            (this.times = Ra(e, this.TimeBufferType)),
                            (this.values = Ra(n, this.ValueBufferType)),
                            this.setInterpolation(
                                i || this.DefaultInterpolation
                            );
                    }
                    static toJSON(t) {
                        const e = t.constructor;
                        let n;
                        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                        else {
                            n = {
                                name: t.name,
                                times: Ra(t.times, Array),
                                values: Ra(t.values, Array),
                            };
                            const e = t.getInterpolation();
                            e !== t.DefaultInterpolation &&
                                (n.interpolation = e);
                        }
                        return (n.type = t.ValueTypeName), n;
                    }
                    InterpolantFactoryMethodDiscrete(t) {
                        return new Ua(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            t
                        );
                    }
                    InterpolantFactoryMethodLinear(t) {
                        return new Ia(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            t
                        );
                    }
                    InterpolantFactoryMethodSmooth(t) {
                        return new Da(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            t
                        );
                    }
                    setInterpolation(t) {
                        let e;
                        switch (t) {
                            case I:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case U:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case O:
                                e = this.InterpolantFactoryMethodSmooth;
                        }
                        if (void 0 === e) {
                            const e =
                                'unsupported interpolation for ' +
                                this.ValueTypeName +
                                ' keyframe track named ' +
                                this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation)
                                    throw new Error(e);
                                this.setInterpolation(
                                    this.DefaultInterpolation
                                );
                            }
                            return (
                                console.warn('THREE.KeyframeTrack:', e), this
                            );
                        }
                        return (this.createInterpolant = e), this;
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return I;
                            case this.InterpolantFactoryMethodLinear:
                                return U;
                            case this.InterpolantFactoryMethodSmooth:
                                return O;
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length;
                    }
                    shift(t) {
                        if (0 !== t) {
                            const e = this.times;
                            for (let n = 0, i = e.length; n !== i; ++n)
                                e[n] += t;
                        }
                        return this;
                    }
                    scale(t) {
                        if (1 !== t) {
                            const e = this.times;
                            for (let n = 0, i = e.length; n !== i; ++n)
                                e[n] *= t;
                        }
                        return this;
                    }
                    trim(t, e) {
                        const n = this.times,
                            i = n.length;
                        let r = 0,
                            a = i - 1;
                        for (; r !== i && n[r] < t; ) ++r;
                        for (; -1 !== a && n[a] > e; ) --a;
                        if ((++a, 0 !== r || a !== i)) {
                            r >= a && ((a = Math.max(a, 1)), (r = a - 1));
                            const t = this.getValueSize();
                            (this.times = Ca(n, r, a)),
                                (this.values = Ca(this.values, r * t, a * t));
                        }
                        return this;
                    }
                    validate() {
                        let t = !0;
                        const e = this.getValueSize();
                        e - Math.floor(e) != 0 &&
                            (console.error(
                                'THREE.KeyframeTrack: Invalid value size in track.',
                                this
                            ),
                            (t = !1));
                        const n = this.times,
                            i = this.values,
                            r = n.length;
                        0 === r &&
                            (console.error(
                                'THREE.KeyframeTrack: Track is empty.',
                                this
                            ),
                            (t = !1));
                        let a = null;
                        for (let e = 0; e !== r; e++) {
                            const i = n[e];
                            if ('number' == typeof i && isNaN(i)) {
                                console.error(
                                    'THREE.KeyframeTrack: Time is not a valid number.',
                                    this,
                                    e,
                                    i
                                ),
                                    (t = !1);
                                break;
                            }
                            if (null !== a && a > i) {
                                console.error(
                                    'THREE.KeyframeTrack: Out of order keys.',
                                    this,
                                    e,
                                    i,
                                    a
                                ),
                                    (t = !1);
                                break;
                            }
                            a = i;
                        }
                        if (void 0 !== i && La(i))
                            for (let e = 0, n = i.length; e !== n; ++e) {
                                const n = i[e];
                                if (isNaN(n)) {
                                    console.error(
                                        'THREE.KeyframeTrack: Value is not a valid number.',
                                        this,
                                        e,
                                        n
                                    ),
                                        (t = !1);
                                    break;
                                }
                            }
                        return t;
                    }
                    optimize() {
                        const t = Ca(this.times),
                            e = Ca(this.values),
                            n = this.getValueSize(),
                            i = this.getInterpolation() === O,
                            r = t.length - 1;
                        let a = 1;
                        for (let o = 1; o < r; ++o) {
                            let r = !1;
                            const s = t[o];
                            if (s !== t[o + 1] && (1 !== o || s !== t[0]))
                                if (i) r = !0;
                                else {
                                    const t = o * n,
                                        i = t - n,
                                        a = t + n;
                                    for (let o = 0; o !== n; ++o) {
                                        const n = e[t + o];
                                        if (n !== e[i + o] || n !== e[a + o]) {
                                            r = !0;
                                            break;
                                        }
                                    }
                                }
                            if (r) {
                                if (o !== a) {
                                    t[a] = t[o];
                                    const i = o * n,
                                        r = a * n;
                                    for (let t = 0; t !== n; ++t)
                                        e[r + t] = e[i + t];
                                }
                                ++a;
                            }
                        }
                        if (r > 0) {
                            t[a] = t[r];
                            for (let t = r * n, i = a * n, o = 0; o !== n; ++o)
                                e[i + o] = e[t + o];
                            ++a;
                        }
                        return (
                            a !== t.length
                                ? ((this.times = Ca(t, 0, a)),
                                  (this.values = Ca(e, 0, a * n)))
                                : ((this.times = t), (this.values = e)),
                            this
                        );
                    }
                    clone() {
                        const t = Ca(this.times, 0),
                            e = Ca(this.values, 0),
                            n = new (0, this.constructor)(this.name, t, e);
                        return (
                            (n.createInterpolant = this.createInterpolant), n
                        );
                    }
                }
                (Oa.prototype.TimeBufferType = Float32Array),
                    (Oa.prototype.ValueBufferType = Float32Array),
                    (Oa.prototype.DefaultInterpolation = U);
                class Na extends Oa {}
                (Na.prototype.ValueTypeName = 'bool'),
                    (Na.prototype.ValueBufferType = Array),
                    (Na.prototype.DefaultInterpolation = I),
                    (Na.prototype.InterpolantFactoryMethodLinear = void 0),
                    (Na.prototype.InterpolantFactoryMethodSmooth = void 0);
                (class extends Oa {}).prototype.ValueTypeName = 'color';
                (class extends Oa {}).prototype.ValueTypeName = 'number';
                class Fa extends Pa {
                    constructor(t, e, n, i) {
                        super(t, e, n, i);
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            a = this.sampleValues,
                            o = this.valueSize,
                            s = (n - e) / (i - e);
                        let l = t * o;
                        for (let t = l + o; l !== t; l += 4)
                            St.slerpFlat(r, 0, a, l - o, a, l, s);
                        return r;
                    }
                }
                class za extends Oa {
                    InterpolantFactoryMethodLinear(t) {
                        return new Fa(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            t
                        );
                    }
                }
                (za.prototype.ValueTypeName = 'quaternion'),
                    (za.prototype.DefaultInterpolation = U),
                    (za.prototype.InterpolantFactoryMethodSmooth = void 0);
                class Ba extends Oa {}
                (Ba.prototype.ValueTypeName = 'string'),
                    (Ba.prototype.ValueBufferType = Array),
                    (Ba.prototype.DefaultInterpolation = I),
                    (Ba.prototype.InterpolantFactoryMethodLinear = void 0),
                    (Ba.prototype.InterpolantFactoryMethodSmooth = void 0);
                (class extends Oa {}).prototype.ValueTypeName = 'vector';
                class ka extends Error {
                    constructor(t, e) {
                        super(t), (this.response = e);
                    }
                }
                const Ha = '\\[\\]\\.:\\/',
                    Ga = new RegExp('[' + Ha + ']', 'g'),
                    Va = '[^' + Ha + ']',
                    Wa = '[^' + Ha.replace('\\.', '') + ']',
                    ja = new RegExp(
                        '^' +
                            /((?:WC+[\/:])*)/.source.replace('WC', Va) +
                            /(WCOD+)?/.source.replace('WCOD', Wa) +
                            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
                                'WC',
                                Va
                            ) +
                            /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', Va) +
                            '$'
                    ),
                    Xa = ['material', 'materials', 'bones', 'map'];
                class Ya {
                    constructor(t, e, n) {
                        (this.path = e),
                            (this.parsedPath = n || Ya.parseTrackName(e)),
                            (this.node = Ya.findNode(
                                t,
                                this.parsedPath.nodeName
                            )),
                            (this.rootNode = t),
                            (this.getValue = this._getValue_unbound),
                            (this.setValue = this._setValue_unbound);
                    }
                    static create(t, e, n) {
                        return t && t.isAnimationObjectGroup
                            ? new Ya.Composite(t, e, n)
                            : new Ya(t, e, n);
                    }
                    static sanitizeNodeName(t) {
                        return t.replace(/\s/g, '_').replace(Ga, '');
                    }
                    static parseTrackName(t) {
                        const e = ja.exec(t);
                        if (null === e)
                            throw new Error(
                                'PropertyBinding: Cannot parse trackName: ' + t
                            );
                        const n = {
                                nodeName: e[2],
                                objectName: e[3],
                                objectIndex: e[4],
                                propertyName: e[5],
                                propertyIndex: e[6],
                            },
                            i = n.nodeName && n.nodeName.lastIndexOf('.');
                        if (void 0 !== i && -1 !== i) {
                            const t = n.nodeName.substring(i + 1);
                            -1 !== Xa.indexOf(t) &&
                                ((n.nodeName = n.nodeName.substring(0, i)),
                                (n.objectName = t));
                        }
                        if (
                            null === n.propertyName ||
                            0 === n.propertyName.length
                        )
                            throw new Error(
                                'PropertyBinding: can not parse propertyName from trackName: ' +
                                    t
                            );
                        return n;
                    }
                    static findNode(t, e) {
                        if (
                            void 0 === e ||
                            '' === e ||
                            '.' === e ||
                            -1 === e ||
                            e === t.name ||
                            e === t.uuid
                        )
                            return t;
                        if (t.skeleton) {
                            const n = t.skeleton.getBoneByName(e);
                            if (void 0 !== n) return n;
                        }
                        if (t.children) {
                            const n = function (t) {
                                    for (let i = 0; i < t.length; i++) {
                                        const r = t[i];
                                        if (r.name === e || r.uuid === e)
                                            return r;
                                        const a = n(r.children);
                                        if (a) return a;
                                    }
                                    return null;
                                },
                                i = n(t.children);
                            if (i) return i;
                        }
                        return null;
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, e) {
                        t[e] = this.targetObject[this.propertyName];
                    }
                    _getValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            t[e++] = n[i];
                    }
                    _getValue_arrayElement(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex];
                    }
                    _getValue_toArray(t, e) {
                        this.resolvedProperty.toArray(t, e);
                    }
                    _setValue_direct(t, e) {
                        this.targetObject[this.propertyName] = t[e];
                    }
                    _setValue_direct_setNeedsUpdate(t, e) {
                        (this.targetObject[this.propertyName] = t[e]),
                            (this.targetObject.needsUpdate = !0);
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                        (this.targetObject[this.propertyName] = t[e]),
                            (this.targetObject.matrixWorldNeedsUpdate = !0);
                    }
                    _setValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            n[i] = t[e++];
                    }
                    _setValue_array_setNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            n[i] = t[e++];
                        this.targetObject.needsUpdate = !0;
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0;
                    }
                    _setValue_arrayElement(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e];
                    }
                    _setValue_arrayElement_setNeedsUpdate(t, e) {
                        (this.resolvedProperty[this.propertyIndex] = t[e]),
                            (this.targetObject.needsUpdate = !0);
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                        (this.resolvedProperty[this.propertyIndex] = t[e]),
                            (this.targetObject.matrixWorldNeedsUpdate = !0);
                    }
                    _setValue_fromArray(t, e) {
                        this.resolvedProperty.fromArray(t, e);
                    }
                    _setValue_fromArray_setNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e),
                            (this.targetObject.needsUpdate = !0);
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e),
                            (this.targetObject.matrixWorldNeedsUpdate = !0);
                    }
                    _getValue_unbound(t, e) {
                        this.bind(), this.getValue(t, e);
                    }
                    _setValue_unbound(t, e) {
                        this.bind(), this.setValue(t, e);
                    }
                    bind() {
                        let t = this.node;
                        const e = this.parsedPath,
                            n = e.objectName,
                            i = e.propertyName;
                        let r = e.propertyIndex;
                        if (
                            (t ||
                                ((t = Ya.findNode(this.rootNode, e.nodeName)),
                                (this.node = t)),
                            (this.getValue = this._getValue_unavailable),
                            (this.setValue = this._setValue_unavailable),
                            !t)
                        )
                            return void console.error(
                                'THREE.PropertyBinding: Trying to update node for track: ' +
                                    this.path +
                                    " but it wasn't found."
                            );
                        if (n) {
                            let i = e.objectIndex;
                            switch (n) {
                                case 'materials':
                                    if (!t.material)
                                        return void console.error(
                                            'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                                            this
                                        );
                                    if (!t.material.materials)
                                        return void console.error(
                                            'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                                            this
                                        );
                                    t = t.material.materials;
                                    break;
                                case 'bones':
                                    if (!t.skeleton)
                                        return void console.error(
                                            'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                                            this
                                        );
                                    t = t.skeleton.bones;
                                    for (let e = 0; e < t.length; e++)
                                        if (t[e].name === i) {
                                            i = e;
                                            break;
                                        }
                                    break;
                                case 'map':
                                    if ('map' in t) {
                                        t = t.map;
                                        break;
                                    }
                                    if (!t.material)
                                        return void console.error(
                                            'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                                            this
                                        );
                                    if (!t.material.map)
                                        return void console.error(
                                            'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.',
                                            this
                                        );
                                    t = t.material.map;
                                    break;
                                default:
                                    if (void 0 === t[n])
                                        return void console.error(
                                            'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                                            this
                                        );
                                    t = t[n];
                            }
                            if (void 0 !== i) {
                                if (void 0 === t[i])
                                    return void console.error(
                                        'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                                        this,
                                        t
                                    );
                                t = t[i];
                            }
                        }
                        const a = t[i];
                        if (void 0 === a) {
                            const n = e.nodeName;
                            return void console.error(
                                'THREE.PropertyBinding: Trying to update property for track: ' +
                                    n +
                                    '.' +
                                    i +
                                    " but it wasn't found.",
                                t
                            );
                        }
                        let o = this.Versioning.None;
                        (this.targetObject = t),
                            void 0 !== t.needsUpdate
                                ? (o = this.Versioning.NeedsUpdate)
                                : void 0 !== t.matrixWorldNeedsUpdate &&
                                  (o = this.Versioning.MatrixWorldNeedsUpdate);
                        let s = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ('morphTargetInfluences' === i) {
                                if (!t.geometry)
                                    return void console.error(
                                        'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                                        this
                                    );
                                if (!t.geometry.morphAttributes)
                                    return void console.error(
                                        'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                                        this
                                    );
                                void 0 !== t.morphTargetDictionary[r] &&
                                    (r = t.morphTargetDictionary[r]);
                            }
                            (s = this.BindingType.ArrayElement),
                                (this.resolvedProperty = a),
                                (this.propertyIndex = r);
                        } else
                            void 0 !== a.fromArray && void 0 !== a.toArray
                                ? ((s = this.BindingType.HasFromToArray),
                                  (this.resolvedProperty = a))
                                : Array.isArray(a)
                                  ? ((s = this.BindingType.EntireArray),
                                    (this.resolvedProperty = a))
                                  : (this.propertyName = i);
                        (this.getValue = this.GetterByBindingType[s]),
                            (this.setValue =
                                this.SetterByBindingTypeAndVersioning[s][o]);
                    }
                    unbind() {
                        (this.node = null),
                            (this.getValue = this._getValue_unbound),
                            (this.setValue = this._setValue_unbound);
                    }
                }
                (Ya.Composite = class {
                    constructor(t, e, n) {
                        const i = n || Ya.parseTrackName(e);
                        (this._targetGroup = t),
                            (this._bindings = t.subscribe_(e, i));
                    }
                    getValue(t, e) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_,
                            i = this._bindings[n];
                        void 0 !== i && i.getValue(t, e);
                    }
                    setValue(t, e) {
                        const n = this._bindings;
                        for (
                            let i = this._targetGroup.nCachedObjects_,
                                r = n.length;
                            i !== r;
                            ++i
                        )
                            n[i].setValue(t, e);
                    }
                    bind() {
                        const t = this._bindings;
                        for (
                            let e = this._targetGroup.nCachedObjects_,
                                n = t.length;
                            e !== n;
                            ++e
                        )
                            t[e].bind();
                    }
                    unbind() {
                        const t = this._bindings;
                        for (
                            let e = this._targetGroup.nCachedObjects_,
                                n = t.length;
                            e !== n;
                            ++e
                        )
                            t[e].unbind();
                    }
                }),
                    (Ya.prototype.BindingType = {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3,
                    }),
                    (Ya.prototype.Versioning = {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2,
                    }),
                    (Ya.prototype.GetterByBindingType = [
                        Ya.prototype._getValue_direct,
                        Ya.prototype._getValue_array,
                        Ya.prototype._getValue_arrayElement,
                        Ya.prototype._getValue_toArray,
                    ]),
                    (Ya.prototype.SetterByBindingTypeAndVersioning = [
                        [
                            Ya.prototype._setValue_direct,
                            Ya.prototype._setValue_direct_setNeedsUpdate,
                            Ya.prototype
                                ._setValue_direct_setMatrixWorldNeedsUpdate,
                        ],
                        [
                            Ya.prototype._setValue_array,
                            Ya.prototype._setValue_array_setNeedsUpdate,
                            Ya.prototype
                                ._setValue_array_setMatrixWorldNeedsUpdate,
                        ],
                        [
                            Ya.prototype._setValue_arrayElement,
                            Ya.prototype._setValue_arrayElement_setNeedsUpdate,
                            Ya.prototype
                                ._setValue_arrayElement_setMatrixWorldNeedsUpdate,
                        ],
                        [
                            Ya.prototype._setValue_fromArray,
                            Ya.prototype._setValue_fromArray_setNeedsUpdate,
                            Ya.prototype
                                ._setValue_fromArray_setMatrixWorldNeedsUpdate,
                        ],
                    ]),
                    new Float32Array(1);
                class qa {
                    constructor(t = 1, e = 0, n = 0) {
                        return (
                            (this.radius = t),
                            (this.phi = e),
                            (this.theta = n),
                            this
                        );
                    }
                    set(t, e, n) {
                        return (
                            (this.radius = t),
                            (this.phi = e),
                            (this.theta = n),
                            this
                        );
                    }
                    copy(t) {
                        return (
                            (this.radius = t.radius),
                            (this.phi = t.phi),
                            (this.theta = t.theta),
                            this
                        );
                    }
                    makeSafe() {
                        const t = 1e-6;
                        return (
                            (this.phi = Math.max(
                                t,
                                Math.min(Math.PI - t, this.phi)
                            )),
                            this
                        );
                    }
                    setFromVector3(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z);
                    }
                    setFromCartesianCoords(t, e, n) {
                        return (
                            (this.radius = Math.sqrt(t * t + e * e + n * n)),
                            0 === this.radius
                                ? ((this.theta = 0), (this.phi = 0))
                                : ((this.theta = Math.atan2(t, n)),
                                  (this.phi = Math.acos(
                                      q(e / this.radius, -1, 1)
                                  ))),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                'undefined' != typeof __THREE_DEVTOOLS__ &&
                    __THREE_DEVTOOLS__.dispatchEvent(
                        new CustomEvent('register', { detail: { revision: i } })
                    ),
                    'undefined' != typeof window &&
                        (window.__THREE__
                            ? console.warn(
                                  'WARNING: Multiple instances of Three.js being imported.'
                              )
                            : (window.__THREE__ = i));
            },
        },
        e = {};
    function n(i) {
        var r = e[i];
        if (void 0 !== r) return r.exports;
        var a = (e[i] = { id: i, exports: {} });
        return t[i](a, a.exports, n), a.exports;
    }
    (n.m = t),
        (n.n = (t) => {
            var e = t && t.__esModule ? () => t.default : () => t;
            return n.d(e, { a: e }), e;
        }),
        (n.d = (t, e) => {
            for (var i in e)
                n.o(e, i) &&
                    !n.o(t, i) &&
                    Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
        }),
        (n.e = () => Promise.resolve()),
        (n.g = (function () {
            if ('object' == typeof globalThis) return globalThis;
            try {
                return this || new Function('return this')();
            } catch (t) {
                if ('object' == typeof window) return window;
            }
        })()),
        (n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
        (n.r = (t) => {
            'undefined' != typeof Symbol &&
                Symbol.toStringTag &&
                Object.defineProperty(t, Symbol.toStringTag, {
                    value: 'Module',
                }),
                Object.defineProperty(t, '__esModule', { value: !0 });
        }),
        (() => {
            var t;
            n.g.importScripts && (t = n.g.location + '');
            var e = n.g.document;
            if (!t && e && (e.currentScript && (t = e.currentScript.src), !t)) {
                var i = e.getElementsByTagName('script');
                i.length && (t = i[i.length - 1].src);
            }
            if (!t)
                throw new Error(
                    'Automatic publicPath is not supported in this browser'
                );
            (t = t
                .replace(/#.*$/, '')
                .replace(/\?.*$/, '')
                .replace(/\/[^\/]+$/, '/')),
                (n.p = t);
        })(),
        (n.b = document.baseURI || self.location.href),
        (n.nc = void 0),
        (() => {
            'use strict';
            var t = n(379),
                e = n.n(t),
                i = n(795),
                r = n.n(i),
                a = n(569),
                o = n.n(a),
                s = n(565),
                l = n.n(s),
                c = n(216),
                u = n.n(c),
                h = n(589),
                d = n.n(h),
                p = n(800),
                f = {};
            (f.styleTagTransform = d()),
                (f.setAttributes = l()),
                (f.insert = o().bind(null, 'head')),
                (f.domAPI = r()),
                (f.insertStyleElement = u()),
                e()(p.Z, f),
                p.Z && p.Z.locals && p.Z.locals;
            var m = n(91),
                g = n.n(m),
                v = new URL(n(131), n.b);
            g()(v);
            const _ = class {
                static isWebGLAvailable() {
                    try {
                        const t = document.createElement('canvas');
                        return !(
                            !window.WebGLRenderingContext ||
                            (!t.getContext('webgl') &&
                                !t.getContext('experimental-webgl'))
                        );
                    } catch (t) {
                        return !1;
                    }
                }
                static isWebGL2Available() {
                    try {
                        const t = document.createElement('canvas');
                        return !(
                            !window.WebGL2RenderingContext ||
                            !t.getContext('webgl2')
                        );
                    } catch (t) {
                        return !1;
                    }
                }
                static getWebGLErrorMessage() {
                    return this.getErrorMessage(1);
                }
                static getWebGL2ErrorMessage() {
                    return this.getErrorMessage(2);
                }
                static getErrorMessage(t) {
                    const e = {
                        1: window.WebGLRenderingContext,
                        2: window.WebGL2RenderingContext,
                    };
                    let n =
                        'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';
                    const i = document.createElement('div');
                    return (
                        (i.id = 'webglmessage'),
                        (i.style.fontFamily = 'monospace'),
                        (i.style.fontSize = '13px'),
                        (i.style.fontWeight = 'normal'),
                        (i.style.textAlign = 'center'),
                        (i.style.background = '#fff'),
                        (i.style.color = '#000'),
                        (i.style.padding = '1.5em'),
                        (i.style.width = '400px'),
                        (i.style.margin = '5em auto 0'),
                        (n = e[t]
                            ? n.replace('$0', 'graphics card')
                            : n.replace('$0', 'browser')),
                        (n = n.replace('$1', { 1: 'WebGL', 2: 'WebGL 2' }[t])),
                        (i.innerHTML = n),
                        i
                    );
                }
            };
            var x = document.querySelector(':root'),
                y = 1,
                M = document.getElementById('modules'),
                b = document.getElementById('connectLines'),
                E = document.getElementsByTagName('line'),
                S = document.getElementById('workspace'),
                T = (null == S ? void 0 : S.clientWidth)
                    ? null == S
                        ? void 0
                        : S.clientWidth
                    : 0,
                w = (null == S ? void 0 : S.clientHeight)
                    ? null == S
                        ? void 0
                        : S.clientHeight
                    : 0,
                A = 0,
                C = 0;
            function R() {
                var t = null == M ? void 0 : M.getBoundingClientRect();
                if (t) {
                    for (var e = 0; e < E.length; e++) {
                        var n = E[e].getAttribute('x1'),
                            i = E[e].getAttribute('x2'),
                            r = E[e].getAttribute('y1'),
                            a = E[e].getAttribute('y2');
                        n &&
                            i &&
                            r &&
                            a &&
                            (E[e].setAttribute(
                                'x1',
                                ((parseFloat(n) - A) / T) * t.width + t.x + 'px'
                            ),
                            E[e].setAttribute(
                                'x2',
                                ((parseFloat(i) - A) / T) * t.width + t.x + 'px'
                            ),
                            E[e].setAttribute(
                                'y1',
                                ((parseFloat(r) - C) / w) * t.height +
                                    t.y +
                                    'px'
                            ),
                            E[e].setAttribute(
                                'y2',
                                ((parseFloat(a) - C) / w) * t.height +
                                    t.y +
                                    'px'
                            ));
                    }
                    (T = t.width), (w = t.height), (A = t.x), (C = t.y);
                }
            }
            var L,
                P,
                D,
                I =
                    ((L = [1, 0, 0, 1, 0, 0]),
                    (P = !0),
                    (D = { x: 0, y: 0 }),
                    {
                        applyTo: function (t) {
                            P && this.update(),
                                (t.style.transform = 'matrix('
                                    .concat(L[0], ',')
                                    .concat(L[1], ',')
                                    .concat(L[2], ',')
                                    .concat(L[3], ',')
                                    .concat(L[4], ',')
                                    .concat(L[5], ')'));
                        },
                        update: function () {
                            (P = !1),
                                (L[3] = L[0] = y),
                                (L[2] = L[1] = 0),
                                (L[4] = D.x),
                                (L[5] = D.y);
                        },
                        pan: function (t) {
                            P && this.update(),
                                (D.x += t.x),
                                (D.y += t.y),
                                (P = !0);
                        },
                        scaleAt: function (t, e) {
                            P && this.update(),
                                (y *= e),
                                x.style.setProperty(
                                    '--zoomFactor',
                                    y.toString()
                                ),
                                (D.x = t.x - (t.x - D.x) * e),
                                (D.y = t.y - (t.y - D.y) * e),
                                (P = !0);
                        },
                        scaleReset: function () {
                            P && this.update(),
                                (y = 1),
                                x.style.setProperty(
                                    '--zoomFactor',
                                    y.toString()
                                ),
                                (D.x = 0),
                                (D.y = 0),
                                (P = !0);
                        },
                    });
            !1 === _.isWebGL2Available() &&
                document.body.appendChild(_.getWebGL2ErrorMessage());
            var U = n(836)
                    .keys()
                    .filter(function (t) {
                        return t.includes('module/modules/');
                    })
                    .map(function (t) {
                        return t
                            .split('/')
                            [t.split('/').length - 1].split('.')[0];
                    }),
                O = document.getElementById('modulesDropdown');
            U.forEach(function (t) {
                var e = document.createElement('button');
                e.addEventListener('click', function () {
                    !(function (t) {
                        var e, i, r, a;
                        (e = this),
                            (i = void 0),
                            (a = function () {
                                return (function (t, e) {
                                    var n,
                                        i,
                                        r,
                                        a,
                                        o = {
                                            label: 0,
                                            sent: function () {
                                                if (1 & r[0]) throw r[1];
                                                return r[1];
                                            },
                                            trys: [],
                                            ops: [],
                                        };
                                    return (
                                        (a = {
                                            next: s(0),
                                            throw: s(1),
                                            return: s(2),
                                        }),
                                        'function' == typeof Symbol &&
                                            (a[Symbol.iterator] = function () {
                                                return this;
                                            }),
                                        a
                                    );
                                    function s(s) {
                                        return function (l) {
                                            return (function (s) {
                                                if (n)
                                                    throw new TypeError(
                                                        'Generator is already executing.'
                                                    );
                                                for (
                                                    ;
                                                    a &&
                                                        ((a = 0),
                                                        s[0] && (o = 0)),
                                                        o;

                                                )
                                                    try {
                                                        if (
                                                            ((n = 1),
                                                            i &&
                                                                (r =
                                                                    2 & s[0]
                                                                        ? i.return
                                                                        : s[0]
                                                                          ? i.throw ||
                                                                            ((r =
                                                                                i.return) &&
                                                                                r.call(
                                                                                    i
                                                                                ),
                                                                            0)
                                                                          : i.next) &&
                                                                !(r = r.call(
                                                                    i,
                                                                    s[1]
                                                                )).done)
                                                        )
                                                            return r;
                                                        switch (
                                                            ((i = 0),
                                                            r &&
                                                                (s = [
                                                                    2 & s[0],
                                                                    r.value,
                                                                ]),
                                                            s[0])
                                                        ) {
                                                            case 0:
                                                            case 1:
                                                                r = s;
                                                                break;
                                                            case 4:
                                                                return (
                                                                    o.label++,
                                                                    {
                                                                        value: s[1],
                                                                        done: !1,
                                                                    }
                                                                );
                                                            case 5:
                                                                o.label++,
                                                                    (i = s[1]),
                                                                    (s = [0]);
                                                                continue;
                                                            case 7:
                                                                (s =
                                                                    o.ops.pop()),
                                                                    o.trys.pop();
                                                                continue;
                                                            default:
                                                                if (
                                                                    !(
                                                                        (r =
                                                                            (r =
                                                                                o.trys)
                                                                                .length >
                                                                                0 &&
                                                                            r[
                                                                                r.length -
                                                                                    1
                                                                            ]) ||
                                                                        (6 !==
                                                                            s[0] &&
                                                                            2 !==
                                                                                s[0])
                                                                    )
                                                                ) {
                                                                    o = 0;
                                                                    continue;
                                                                }
                                                                if (
                                                                    3 ===
                                                                        s[0] &&
                                                                    (!r ||
                                                                        (s[1] >
                                                                            r[0] &&
                                                                            s[1] <
                                                                                r[3]))
                                                                ) {
                                                                    o.label =
                                                                        s[1];
                                                                    break;
                                                                }
                                                                if (
                                                                    6 ===
                                                                        s[0] &&
                                                                    o.label <
                                                                        r[1]
                                                                ) {
                                                                    (o.label =
                                                                        r[1]),
                                                                        (r = s);
                                                                    break;
                                                                }
                                                                if (
                                                                    r &&
                                                                    o.label <
                                                                        r[2]
                                                                ) {
                                                                    (o.label =
                                                                        r[2]),
                                                                        o.ops.push(
                                                                            s
                                                                        );
                                                                    break;
                                                                }
                                                                r[2] &&
                                                                    o.ops.pop(),
                                                                    o.trys.pop();
                                                                continue;
                                                        }
                                                        s = e.call(t, o);
                                                    } catch (t) {
                                                        (s = [6, t]), (i = 0);
                                                    } finally {
                                                        n = r = 0;
                                                    }
                                                if (5 & s[0]) throw s[1];
                                                return {
                                                    value: s[0] ? s[1] : void 0,
                                                    done: !0,
                                                };
                                            })([s, l]);
                                        };
                                    }
                                })(this, function (e) {
                                    switch (e.label) {
                                        case 0:
                                            return [
                                                4,
                                                n(856)('./'.concat(t, '.ts')),
                                            ];
                                        case 1:
                                            return (
                                                new (e.sent().default)(), [2]
                                            );
                                    }
                                });
                            }),
                            new ((r = void 0) || (r = Promise))(function (
                                t,
                                n
                            ) {
                                function o(t) {
                                    try {
                                        l(a.next(t));
                                    } catch (t) {
                                        n(t);
                                    }
                                }
                                function s(t) {
                                    try {
                                        l(a.throw(t));
                                    } catch (t) {
                                        n(t);
                                    }
                                }
                                function l(e) {
                                    var n;
                                    e.done
                                        ? t(e.value)
                                        : ((n = e.value),
                                          n instanceof r
                                              ? n
                                              : new r(function (t) {
                                                    t(n);
                                                })).then(o, s);
                                }
                                l((a = a.apply(e, i || [])).next());
                            });
                    })(t);
                }),
                    (e.innerText = t
                        .split('-')
                        .map(function (t) {
                            return t.charAt(0).toUpperCase() + t.slice(1);
                        })
                        .join(' ')),
                    e.classList.add('moduleButton'),
                    null == O || O.appendChild(e);
            });
            var N = document.getElementById('dropdbutton');
            null == N ||
                N.addEventListener('click', function () {
                    null == O || O.classList.toggle('displayBlock');
                });
            var F = document.getElementById('workspace');
            null == F ||
                F.addEventListener('click', function () {
                    null == O || O.classList.remove('displayBlock');
                });
            var z = document.getElementById('toggleCanvas');
            null == z ||
                z.addEventListener('click', function () {
                    document.getElementById('renderCanvas') &&
                        document.body.classList.toggle('canvasWindowWidth');
                }),
                M &&
                    S &&
                    b &&
                    E &&
                    (S.addEventListener(
                        'wheel',
                        function (t) {
                            t.stopPropagation();
                            var e = t.pageX - M.clientWidth / 2,
                                n = t.pageY - M.clientHeight / 2;
                            t.deltaY > 0
                                ? I.scaleAt({ x: e, y: n }, 1.1)
                                : I.scaleAt({ x: e, y: n }, 1 / 1.1),
                                I.applyTo(M),
                                R(),
                                t.preventDefault();
                        },
                        { passive: !1 }
                    ),
                    S.addEventListener('mousemove', function (t) {
                        1 === t.buttons &&
                            t.altKey &&
                            (I.pan({ x: t.movementX, y: t.movementY }),
                            I.applyTo(M),
                            (function (t) {
                                for (var e = 0; e < E.length; e++) {
                                    var n = E[e].getAttribute('x1'),
                                        i = E[e].getAttribute('x2'),
                                        r = E[e].getAttribute('y1'),
                                        a = E[e].getAttribute('y2');
                                    n &&
                                        i &&
                                        r &&
                                        a &&
                                        (E[e].setAttribute(
                                            'x1',
                                            parseInt(n) + t.movementX + 'px'
                                        ),
                                        E[e].setAttribute(
                                            'x2',
                                            parseInt(i) + t.movementX + 'px'
                                        ),
                                        E[e].setAttribute(
                                            'y1',
                                            parseInt(r) + t.movementY + 'px'
                                        ),
                                        E[e].setAttribute(
                                            'y2',
                                            parseInt(a) + t.movementY + 'px'
                                        ));
                                }
                                (A += t.movementX), (C += t.movementY);
                            })(t));
                    }),
                    S.addEventListener('contextmenu', function () {
                        I.scaleReset(), I.update(), I.applyTo(M), R();
                    }),
                    window.addEventListener('resize', function () {
                        return (function () {
                            if (b) {
                                var t = window.innerWidth / 2,
                                    e = window.innerHeight;
                                if (
                                    (b.setAttribute(
                                        'viewBox',
                                        '0 0 '.concat(t, ' ').concat(e)
                                    ),
                                    M)
                                )
                                    if (1 != y)
                                        I.scaleReset(),
                                            I.update(),
                                            I.applyTo(M),
                                            R();
                                    else {
                                        var n =
                                            null == M
                                                ? void 0
                                                : M.getBoundingClientRect();
                                        (T = n.width),
                                            (w = n.height),
                                            (A = n.x),
                                            (C = n.y);
                                    }
                            }
                        })();
                    }));
        })();
})();
